#!/usr/bin/env python3

import os
import signal
import sys
import time
from urllib.parse import urlsplit
import subprocess


# This is written in Python instead of Bash because I encountered a weird problem I have no idea to fix.
#
# In docker-wrapper.sh, we run each daemon in background with `&`, and
# use `wait` to wait them to exit gracefully.
# This works fine if the daemon is NOT a shell script.
# If the daemon is a shell script, the signal IS NOT delivered to the shell script.
# The process running docker-wrapper.sh will die,
# leaving the shell script running with parent pid becoming pid=1.
#
# It is observed that if the daemon is written in a different runtime, such as Go or Python,
# this problem does not recur.
# Thus this is written in Python.


def handle_signal(signum, _frame):
    print(f"certbot: got signal {signum}")
    sys.exit(0)


def parse_domain(val):
    url = urlsplit(val)
    # Use hostname instead of netloc to strip the port.
    scheme = url.scheme
    if scheme == "https":
        hostname = url.hostname
        if hostname is None:
            raise ValueError(val)
        return hostname
    return None


def get_domains_from_env():
    domains = []
    env_vars = [
        "AUTHGEAR_HTTP_ORIGIN_PORTAL",
        "AUTHGEAR_HTTP_ORIGIN_ACCOUNTS",
        "AUTHGEAR_HTTP_ORIGIN_PROJECT",
    ]
    for env_var in env_vars:
        val = os.getenv(env_var)
        if val is None:
            print(f"certbot: {env_var} is undefined", file=sys.stderr)
            sys.exit(1)
        try:
            domain = parse_domain(val)
            if domain is not None:
                domains.append(domain)
        except ValueError:
            print(f"certbot: {env_var} is invalid: {val}")
            sys.exit(1)
    return domains


def main():
    # SIGINT is usually generated by CTRL-C
    signal.signal(signal.SIGINT, handle_signal)
    # SIGTERM is generated by docker container stop.
    signal.signal(signal.SIGTERM, handle_signal)

    run_internal = 86400
    run_internal_env_name = "AUTHGEAR_CERTBOT_RUN_INTERVAL"
    run_internal_env_val = os.getenv(run_internal_env_name)
    if run_internal_env_val is not None:
        try:
            run_internal = int(run_internal_env_val)
            if run_internal < 0:
                raise ValueError()
        except ValueError:
            print(f"certbot: {run_internal_env_name} is invalid: {run_internal_env_val}", file=sys.stderr)
            sys.exit(1)

    domains = get_domains_from_env()

    certbot_use_staging = True
    if os.getenv("AUTHGEAR_CERTBOT_ENVIRONMENT") == "production":
        certbot_use_staging = False

    email_env_name = "AUTHGEAR_CERTBOT_EMAIL"
    email_env_val = os.getenv(email_env_name)
    if email_env_val is None:
        print(f"certbot: {email_env_name} is undefined", file=sys.stderr)
        sys.exit(1)

    cmd = []
    cmd.append("certbot")
    cmd.append("run")

    if certbot_use_staging:
        cmd.append("--staging")

    cmd.append("--non-interactive")
    cmd.append("--nginx")
    cmd.append("-m")
    cmd.append(email_env_val)
    cmd.append("--agree-tos")
    cmd.append("--no-eff-email")
    cmd.append("--expand")
    cmd.append("--keep-until-expiring")
    cmd.append("--renew-with-new-domains")
    for domain in domains:
        cmd.append("--domain")
        cmd.append(domain)

    print(f"certbot: run_internal={run_internal}")
    while True:
        if len(domains) > 0:
            completed_process = subprocess.run(cmd, stdin=None, stdout=None, stderr=None, shell=False, check=False)
            print(f"certbot: exited with {completed_process.returncode}")
        else:
            print(f"certbot: no domains; skipping")
        time.sleep(run_internal)


if __name__ == "__main__":
    main()
