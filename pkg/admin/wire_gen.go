// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package admin

import (
	"context"
	facade2 "github.com/authgear/authgear-server/pkg/admin/facade"
	"github.com/authgear/authgear-server/pkg/admin/graphql"
	"github.com/authgear/authgear-server/pkg/admin/loader"
	service3 "github.com/authgear/authgear-server/pkg/admin/service"
	"github.com/authgear/authgear-server/pkg/admin/transport"
	"github.com/authgear/authgear-server/pkg/lib/admin/authz"
	"github.com/authgear/authgear-server/pkg/lib/audit"
	"github.com/authgear/authgear-server/pkg/lib/authn/authenticationinfo"
	"github.com/authgear/authgear-server/pkg/lib/authn/authenticator/oob"
	passkey3 "github.com/authgear/authgear-server/pkg/lib/authn/authenticator/passkey"
	"github.com/authgear/authgear-server/pkg/lib/authn/authenticator/password"
	service2 "github.com/authgear/authgear-server/pkg/lib/authn/authenticator/service"
	"github.com/authgear/authgear-server/pkg/lib/authn/authenticator/totp"
	"github.com/authgear/authgear-server/pkg/lib/authn/challenge"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/anonymous"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/biometric"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/ldap"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/loginid"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/oauth"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/passkey"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/service"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/siwe"
	"github.com/authgear/authgear-server/pkg/lib/authn/mfa"
	"github.com/authgear/authgear-server/pkg/lib/authn/otp"
	"github.com/authgear/authgear-server/pkg/lib/authn/sso"
	"github.com/authgear/authgear-server/pkg/lib/authn/stdattrs"
	"github.com/authgear/authgear-server/pkg/lib/authn/user"
	"github.com/authgear/authgear-server/pkg/lib/config"
	"github.com/authgear/authgear-server/pkg/lib/deps"
	"github.com/authgear/authgear-server/pkg/lib/elasticsearch"
	"github.com/authgear/authgear-server/pkg/lib/endpoints"
	"github.com/authgear/authgear-server/pkg/lib/event"
	"github.com/authgear/authgear-server/pkg/lib/facade"
	"github.com/authgear/authgear-server/pkg/lib/feature/customattrs"
	"github.com/authgear/authgear-server/pkg/lib/feature/forgotpassword"
	passkey2 "github.com/authgear/authgear-server/pkg/lib/feature/passkey"
	stdattrs2 "github.com/authgear/authgear-server/pkg/lib/feature/stdattrs"
	"github.com/authgear/authgear-server/pkg/lib/feature/verification"
	"github.com/authgear/authgear-server/pkg/lib/healthz"
	"github.com/authgear/authgear-server/pkg/lib/hook"
	"github.com/authgear/authgear-server/pkg/lib/infra/db/appdb"
	"github.com/authgear/authgear-server/pkg/lib/infra/db/auditdb"
	"github.com/authgear/authgear-server/pkg/lib/infra/db/globaldb"
	"github.com/authgear/authgear-server/pkg/lib/infra/db/searchdb"
	"github.com/authgear/authgear-server/pkg/lib/infra/mail"
	"github.com/authgear/authgear-server/pkg/lib/infra/middleware"
	"github.com/authgear/authgear-server/pkg/lib/infra/redis/globalredis"
	"github.com/authgear/authgear-server/pkg/lib/infra/redisqueue"
	"github.com/authgear/authgear-server/pkg/lib/infra/sms"
	"github.com/authgear/authgear-server/pkg/lib/infra/sms/custom"
	"github.com/authgear/authgear-server/pkg/lib/infra/whatsapp"
	"github.com/authgear/authgear-server/pkg/lib/interaction"
	"github.com/authgear/authgear-server/pkg/lib/lockout"
	"github.com/authgear/authgear-server/pkg/lib/messaging"
	"github.com/authgear/authgear-server/pkg/lib/meter"
	"github.com/authgear/authgear-server/pkg/lib/nonce"
	oauth2 "github.com/authgear/authgear-server/pkg/lib/oauth"
	"github.com/authgear/authgear-server/pkg/lib/oauth/handler"
	"github.com/authgear/authgear-server/pkg/lib/oauth/oauthsession"
	"github.com/authgear/authgear-server/pkg/lib/oauth/oidc"
	"github.com/authgear/authgear-server/pkg/lib/oauth/pq"
	"github.com/authgear/authgear-server/pkg/lib/oauth/redis"
	"github.com/authgear/authgear-server/pkg/lib/oauthclient"
	"github.com/authgear/authgear-server/pkg/lib/otelauthgear"
	"github.com/authgear/authgear-server/pkg/lib/presign"
	"github.com/authgear/authgear-server/pkg/lib/ratelimit"
	"github.com/authgear/authgear-server/pkg/lib/resourcescope"
	"github.com/authgear/authgear-server/pkg/lib/rolesgroups"
	"github.com/authgear/authgear-server/pkg/lib/search"
	"github.com/authgear/authgear-server/pkg/lib/search/pgsearch"
	"github.com/authgear/authgear-server/pkg/lib/search/reindex"
	"github.com/authgear/authgear-server/pkg/lib/session"
	"github.com/authgear/authgear-server/pkg/lib/session/access"
	"github.com/authgear/authgear-server/pkg/lib/session/idpsession"
	"github.com/authgear/authgear-server/pkg/lib/sessionlisting"
	"github.com/authgear/authgear-server/pkg/lib/translation"
	"github.com/authgear/authgear-server/pkg/lib/usage"
	"github.com/authgear/authgear-server/pkg/lib/userexport"
	"github.com/authgear/authgear-server/pkg/lib/userimport"
	"github.com/authgear/authgear-server/pkg/lib/userinfo"
	"github.com/authgear/authgear-server/pkg/lib/web"
	"github.com/authgear/authgear-server/pkg/lib/webappoauth"
	"github.com/authgear/authgear-server/pkg/util/clock"
	"github.com/authgear/authgear-server/pkg/util/httproute"
	"github.com/authgear/authgear-server/pkg/util/httputil"
	"github.com/authgear/authgear-server/pkg/util/rand"
	"github.com/authgear/authgear-server/pkg/util/template"
	"net/http"
)

// Injectors from wire.go:

func newPanicMiddleware(p *deps.RootProvider) httproute.Middleware {
	panicMiddleware := &middleware.PanicMiddleware{}
	return panicMiddleware
}

func newHealthzHandler(p *deps.RootProvider, w http.ResponseWriter, r *http.Request, ctx context.Context) http.Handler {
	pool := p.DatabasePool
	environmentConfig := p.EnvironmentConfig
	globalDatabaseCredentialsEnvironmentConfig := &environmentConfig.GlobalDatabase
	databaseEnvironmentConfig := &environmentConfig.DatabaseConfig
	handle := globaldb.NewHandle(pool, globalDatabaseCredentialsEnvironmentConfig, databaseEnvironmentConfig)
	sqlExecutor := globaldb.NewSQLExecutor(handle)
	redisPool := p.RedisPool
	redisEnvironmentConfig := &environmentConfig.RedisConfig
	globalRedisCredentialsEnvironmentConfig := &environmentConfig.GlobalRedis
	globalredisHandle := globalredis.NewHandle(redisPool, redisEnvironmentConfig, globalRedisCredentialsEnvironmentConfig)
	handler := &healthz.Handler{
		GlobalDatabase: handle,
		GlobalExecutor: sqlExecutor,
		GlobalRedis:    globalredisHandle,
	}
	return handler
}

func newSentryMiddleware(p *deps.RootProvider) httproute.Middleware {
	hub := p.SentryHub
	environmentConfig := p.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	sentryMiddleware := &middleware.SentryMiddleware{
		SentryHub:  hub,
		TrustProxy: trustProxy,
	}
	return sentryMiddleware
}

func newBodyLimitMiddleware(p *deps.RootProvider) httproute.Middleware {
	bodyLimitMiddleware := &middleware.BodyLimitMiddleware{}
	return bodyLimitMiddleware
}

func newOtelMiddleware(p *deps.RootProvider) httproute.Middleware {
	environmentConfig := p.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpInstrumentationMiddleware := &otelauthgear.HTTPInstrumentationMiddleware{
		TrustProxy: trustProxy,
	}
	return httpInstrumentationMiddleware
}

func newAuthorizationMiddleware(p *deps.RequestProvider, auth config.AdminAPIAuth) httproute.Middleware {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	configConfig := appContext.Config
	appConfig := configConfig.AppConfig
	appID := appConfig.ID
	secretConfig := configConfig.SecretConfig
	adminAPIAuthKey := deps.ProvideAdminAPIAuthKeyMaterials(secretConfig)
	clock := _wireSystemClockValue
	authzMiddleware := &authz.Middleware{
		Auth:    auth,
		AppID:   appID,
		AuthKey: adminAPIAuthKey,
		Clock:   clock,
	}
	return authzMiddleware
}

var (
	_wireSystemClockValue = clock.NewSystemClock()
)

func newUIParamMiddleware(p *deps.RequestProvider) httproute.Middleware {
	uiParamMiddleware := &transport.UIParamMiddleware{}
	return uiParamMiddleware
}

func newGraphQLHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	configConfig := appContext.Config
	appConfig := configConfig.AppConfig
	oAuthConfig := appConfig.OAuth
	featureConfig := configConfig.FeatureConfig
	adminAPIFeatureConfig := featureConfig.AdminAPI
	secretConfig := configConfig.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	appID := appConfig.ID
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	handle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(handle)
	clockClock := _wireSystemClockValue
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
		AppID:       appID,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	ssooAuthDemoCredentials := deps.ProvideSSOOAuthDemoCredentials(secretConfig)
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	uiConfig := appConfig.UI
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		UIConfig:      uiConfig,
		LoginIDConfig: loginIDConfig,
		Resources:     manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth.Provider{
		Store: oauthStore,
		Clock: clockClock,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	appredisHandle := appProvider.Redis
	store2 := &passkey2.Store{
		Redis: appredisHandle,
		AppID: appID,
	}
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(configConfig)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(configConfig)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	smtpServerCredentialsSecretItem := deps.ProvideSMTPServerCredentialsItem(secretConfig)
	translationService := &translation.Service{
		TemplateEngine:                  engine,
		StaticAssets:                    staticAssetResolver,
		SMTPServerCredentialsSecretItem: smtpServerCredentialsSecretItem,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
	}
	ldapStore := &ldap.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	normalizer := &stdattrs.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	ldapProvider := &ldap.Provider{
		Store:                        ldapStore,
		Clock:                        clockClock,
		StandardAttributesNormalizer: normalizer,
	}
	serviceService := &service.Service{
		Authentication:          authenticationConfig,
		Identity:                identityConfig,
		IdentityFeatureConfig:   identityFeatureConfig,
		SSOOAuthDemoCredentials: ssooAuthDemoCredentials,
		Store:                   serviceStore,
		LoginID:                 provider,
		OAuth:                   oauthProvider,
		Anonymous:               anonymousProvider,
		Biometric:               biometricProvider,
		Passkey:                 passkeyProvider,
		SIWE:                    siweProvider,
		LDAP:                    ldapProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	expiry := password.ProvideExpiry(authenticatorPasswordConfig, clockClock)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Expiry:          expiry,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeConfig := appConfig.TestMode
	testModeFeatureConfig := featureConfig.TestMode
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storageRedis := ratelimit.NewAppStorageRedis(appredisHandle)
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Storage: storageRedis,
		AppID:   appID,
		Config:  rateLimitsFeatureConfig,
	}
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeConfig:        testModeConfig,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		RateLimiter:           limiter,
		FeatureConfig:         featureConfig,
		EnvConfig:             rateLimitsEnvironmentConfig,
	}
	rateLimits := service2.RateLimits{
		IP:            remoteIP,
		Config:        appConfig,
		FeatureConfig: featureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
		RateLimiter:   limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service4 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs2.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs2.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	rolesgroupsStore := &rolesgroups.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	queries := &rolesgroups.Queries{
		Store: rolesgroupsStore,
	}
	userQueries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service4,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		RolesAndGroups:     queries,
	}
	userLoader := loader.NewUserLoader(userQueries)
	identityLoader := loader.NewIdentityLoader(serviceService)
	authenticatorLoader := loader.NewAuthenticatorLoader(service4)
	roleLoader := loader.NewRoleLoader(queries)
	groupLoader := loader.NewGroupLoader(queries)
	readHandle := appProvider.AuditReadDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	readSQLExecutor := auditdb.NewReadSQLExecutor(readHandle)
	readStore := &audit.ReadStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: readSQLExecutor,
	}
	query := &audit.Query{
		Database: readHandle,
		Store:    readStore,
	}
	auditLogLoader := loader.NewAuditLogLoader(query, readHandle)
	resourcescopeStore := &resourcescope.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	resourcescopeQueries := &resourcescope.Queries{
		Store: resourcescopeStore,
	}
	resourceLoader := loader.NewResourceLoader(resourcescopeQueries)
	resourceClientLoader := loader.NewResourceClientLoader(resourcescopeQueries)
	scopeLoader := loader.NewScopeLoader(resourcescopeQueries)
	searchConfig := appConfig.Search
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	elasticsearchService := &elasticsearch.Service{
		Clock:           clockClock,
		Database:        handle,
		AppID:           appID,
		Client:          client,
		Users:           userQueries,
		UserStore:       store,
		IdentityService: serviceService,
		RolesGroups:     rolesgroupsStore,
	}
	configAppID := &appConfig.ID
	searchDatabaseCredentials := deps.ProvideSearchDatabaseCredentials(secretConfig)
	sqlBuilder := searchdb.NewSQLBuilder(searchDatabaseCredentials)
	searchdbHandle := appProvider.SearchDatabase
	searchdbSQLExecutor := searchdb.NewSQLExecutor(searchdbHandle)
	pgsearchStore := pgsearch.NewStore(appID, sqlBuilder, searchdbSQLExecutor)
	pgsearchService := &pgsearch.Service{
		AppID:    configAppID,
		Store:    pgsearchStore,
		Database: searchdbHandle,
	}
	globalSearchImplementation := environmentConfig.SearchImplementation
	searchService := &search.Service{
		SearchConfig:               searchConfig,
		ElasticsearchService:       elasticsearchService,
		PGSearchService:            pgsearchService,
		GlobalSearchImplementation: globalSearchImplementation,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	appdbSQLBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(appdbSQLBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: userQueries,
	}
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	commands := &rolesgroups.Commands{
		Store: rolesgroupsStore,
	}
	sink := &hook.Sink{
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		RolesAndGroups:     commands,
	}
	writeHandle := appProvider.AuditWriteDatabase
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Database: writeHandle,
		Store:    writeStore,
	}
	userReindexProducer := redisqueue.NewUserReindexProducer(appredisHandle, clockClock)
	sourceProvider := &reindex.SourceProvider{
		AppID:           appID,
		Users:           userQueries,
		UserStore:       store,
		IdentityService: serviceService,
		RolesGroups:     rolesgroupsStore,
	}
	reindexer := &reindex.Reindexer{
		AppID:                      appID,
		SearchConfig:               searchConfig,
		Clock:                      clockClock,
		Database:                   handle,
		UserStore:                  store,
		Producer:                   userReindexProducer,
		SourceProvider:             sourceProvider,
		ElasticsearchReindexer:     elasticsearchService,
		PostgresqlReindexer:        pgsearchService,
		GlobalSearchImplementation: globalSearchImplementation,
	}
	reindexSink := &reindex.Sink{
		Reindexer: reindexer,
		Database:  handle,
	}
	userInfoService := &userinfo.UserInfoService{
		Redis:                 appredisHandle,
		AppID:                 appID,
		UserQueries:           userQueries,
		RolesAndGroupsQueries: queries,
	}
	userinfoSink := &userinfo.Sink{
		UserInfoService: userInfoService,
	}
	eventService := event.NewService(appID, remoteIP, userAgentString, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, reindexSink, userinfoSink)
	userCommands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		RolesAndGroups:     queries,
	}
	userProvider := &user.Provider{
		Commands: userCommands,
		Queries:  userQueries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        appConfig,
		FeatureConfig: featureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	usageLimiter := &usage.Limiter{
		Clock: clockClock,
		AppID: appID,
		Redis: appredisHandle,
	}
	limits := messaging.Limits{
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        appConfig,
		FeatureConfig: featureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	smtpServerCredentials := deps.ProvideSMTPServerCredentials(secretConfig)
	dialer := mail.NewGomailDialer(smtpServerCredentials)
	sender := &mail.Sender{
		GomailDialer: dialer,
	}
	messagingConfig := appConfig.Messaging
	smsProvider := messagingConfig.Deprecated_SMSProvider
	smsGatewayConfig := messagingConfig.SMSGateway
	nexmoCredentials := deps.ProvideNexmoCredentials(secretConfig)
	twilioCredentials := deps.ProvideTwilioCredentials(secretConfig)
	customSMSProviderConfig := deps.ProvideCustomSMSProviderConfig(secretConfig)
	smsGatewayEnvironmentConfig := &environmentConfig.SMSGatewayConfig
	smsGatewayEnvironmentDefaultConfig := &smsGatewayEnvironmentConfig.Default
	smsGatewayEnvironmentDefaultProvider := smsGatewayEnvironmentDefaultConfig.Provider
	smsGatewayEnvironmentDefaultUseConfigFrom := smsGatewayEnvironmentDefaultConfig.UseConfigFrom
	smsGatewayEnvironmentNexmoCredentials := smsGatewayEnvironmentConfig.Nexmo
	smsGatewayEnvironmentTwilioCredentials := smsGatewayEnvironmentConfig.Twilio
	smsGatewayEnvironmentCustomSMSProviderConfig := smsGatewayEnvironmentConfig.Custom
	hookDenoHook := &hook.DenoHook{
		ResourceManager: manager,
	}
	smsHookTimeout := custom.NewSMSHookTimeout(customSMSProviderConfig)
	hookDenoClient := custom.NewHookDenoClient(denoEndpoint, smsHookTimeout)
	smsDenoHook := custom.SMSDenoHook{
		DenoHook: hookDenoHook,
		Client:   hookDenoClient,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := custom.NewHookHTTPClient(smsHookTimeout)
	smsWebHook := custom.SMSWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
	}
	clientResolver := &sms.ClientResolver{
		AuthgearYAMLSMSProvider:                    smsProvider,
		AuthgearYAMLSMSGateway:                     smsGatewayConfig,
		AuthgearSecretsYAMLNexmoCredentials:        nexmoCredentials,
		AuthgearSecretsYAMLTwilioCredentials:       twilioCredentials,
		AuthgearSecretsYAMLCustomSMSProviderConfig: customSMSProviderConfig,
		EnvironmentDefaultProvider:                 smsGatewayEnvironmentDefaultProvider,
		EnvironmentDefaultUseConfigFrom:            smsGatewayEnvironmentDefaultUseConfigFrom,
		EnvironmentNexmoCredentials:                smsGatewayEnvironmentNexmoCredentials,
		EnvironmentTwilioCredentials:               smsGatewayEnvironmentTwilioCredentials,
		EnvironmentCustomSMSProviderConfig:         smsGatewayEnvironmentCustomSMSProviderConfig,
		SMSDenoHook:                                smsDenoHook,
		SMSWebHook:                                 smsWebHook,
	}
	smsSender := &sms.Sender{
		ClientResolver: clientResolver,
	}
	whatsappConfig := messagingConfig.Whatsapp
	globalWhatsappAPIType := environmentConfig.WhatsappAPIType
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	httpClient := whatsapp.NewHTTPClient()
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappOnPremisesCredentials, tokenStore, httpClient)
	whatsappCloudAPICredentials := deps.ProvideWhatsappCloudAPICredentials(secretConfig)
	cloudAPIClient := whatsapp.NewWhatsappCloudAPIClient(whatsappCloudAPICredentials, httpClient)
	pool := rootProvider.RedisPool
	redisEnvironmentConfig := &environmentConfig.RedisConfig
	globalRedisCredentialsEnvironmentConfig := &environmentConfig.GlobalRedis
	globalredisHandle := globalredis.NewHandle(pool, redisEnvironmentConfig, globalRedisCredentialsEnvironmentConfig)
	messageStore := &whatsapp.MessageStore{
		Redis:       globalredisHandle,
		Credentials: whatsappCloudAPICredentials,
	}
	whatsappService := &whatsapp.Service{
		Clock:                 clockClock,
		WhatsappConfig:        whatsappConfig,
		LocalizationConfig:    localizationConfig,
		GlobalWhatsappAPIType: globalWhatsappAPIType,
		OnPremisesClient:      onPremisesClient,
		CloudAPIClient:        cloudAPIClient,
		MessageStore:          messageStore,
		Credentials:           whatsappCloudAPICredentials,
	}
	devMode := environmentConfig.DevMode
	messagingFeatureConfig := featureConfig.Messaging
	featureTestModeEmailSuppressed := deps.ProvideTestModeEmailSuppressed(testModeFeatureConfig)
	testModeEmailConfig := testModeConfig.Email
	featureTestModeSMSSuppressed := deps.ProvideTestModeSMSSuppressed(testModeFeatureConfig)
	testModeSMSConfig := testModeConfig.SMS
	featureTestModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	testModeWhatsappConfig := testModeConfig.Whatsapp
	messagingSender := &messaging.Sender{
		Limits:                            limits,
		Events:                            eventService,
		MailSender:                        sender,
		SMSSender:                         smsSender,
		WhatsappSender:                    whatsappService,
		Database:                          handle,
		DevMode:                           devMode,
		MessagingFeatureConfig:            messagingFeatureConfig,
		FeatureTestModeEmailSuppressed:    featureTestModeEmailSuppressed,
		TestModeEmailConfig:               testModeEmailConfig,
		FeatureTestModeSMSSuppressed:      featureTestModeSMSSuppressed,
		TestModeSMSConfig:                 testModeSMSConfig,
		FeatureTestModeWhatsappSuppressed: featureTestModeWhatsappSuppressed,
		TestModeWhatsappConfig:            testModeWhatsappConfig,
	}
	forgotpasswordSender := &forgotpassword.Sender{
		AppConfg:    appConfig,
		Identities:  serviceService,
		Sender:      messagingSender,
		Translation: translationService,
	}
	stdattrsService := &stdattrs2.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedis := &idpsession.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	sessionConfig := appConfig.Session
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     storeRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisStore := &redis.Store{
		Redis:       appredisHandle,
		AppID:       appID,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	analyticredisHandle := appProvider.AnalyticRedis
	writeStoreRedis := &meter.WriteStoreRedis{
		Redis: analyticredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	meterService := &meter.Service{
		Counter: writeStoreRedis,
	}
	rand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           storeRedis,
		AccessEvents:    eventProvider,
		MeterService:    meterService,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          rand,
	}
	sharedAuthgearEndpoint := environmentConfig.SharedAuthgearEndpoint
	oAuthEndpoints := &endpoints.OAuthEndpoints{
		HTTPHost:               httpHost,
		HTTPProto:              httpProto,
		SharedAuthgearEndpoint: sharedAuthgearEndpoint,
	}
	globalUIImplementation := environmentConfig.UIImplementation
	globalUISettingsImplementation := environmentConfig.UISettingsImplementation
	uiImplementationService := &web.UIImplementationService{
		UIConfig:                       uiConfig,
		GlobalUIImplementation:         globalUIImplementation,
		GlobalUISettingsImplementation: globalUISettingsImplementation,
	}
	endpointsEndpoints := &endpoints.Endpoints{
		OAuthEndpoints:          oAuthEndpoints,
		UIImplementationService: uiImplementationService,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		OAuthConfig:     oAuthConfig,
		Clock:           clockClock,
		IDPSessions:     idpsessionProvider,
		ClientResolver:  oauthclientResolver,
		AccessEvents:    eventProvider,
		MeterService:    meterService,
		OfflineGrants:   redisStore,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	maxTrials := _wireMaxTrialsValue
	passwordRand := password.NewRandSource()
	generator := &password.Generator{
		MaxTrials:      maxTrials,
		Checker:        passwordChecker,
		Rand:           passwordRand,
		PasswordConfig: authenticatorPasswordConfig,
	}
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service4,
		Verification:               verificationService,
		MFA:                        mfaService,
		SendPassword:               forgotpasswordSender,
		UserCommands:               userCommands,
		UserQueries:                userQueries,
		RolesGroupsCommands:        commands,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		AuthenticationConfig:       authenticationConfig,
		Clock:                      clockClock,
		PasswordGenerator:          generator,
	}
	userFacade := &facade.UserFacade{
		UserProvider: userProvider,
		Coordinator:  coordinator,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	messageSender := &otp.MessageSender{
		AppID:       appID,
		Translation: translationService,
		Endpoints:   endpointsEndpoints,
		Sender:      messagingSender,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	oAuthHTTPClient := sso.ProvideOAuthHTTPClient(environmentConfig)
	simpleStoreRedisFactory := &sso.SimpleStoreRedisFactory{
		AppID: appID,
		Redis: appredisHandle,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		SSOOAuthDemoCredentials:      ssooAuthDemoCredentials,
		Clock:                        clockClock,
		StandardAttributesNormalizer: normalizer,
		HTTPClient:                   oAuthHTTPClient,
		SimpleStoreRedisFactory:      simpleStoreRedisFactory,
	}
	webappoauthStore := &webappoauth.Store{
		Redis: globalredisHandle,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	sender2 := forgotpassword.Sender{
		AppConfg:    appConfig,
		Identities:  serviceService,
		Sender:      messagingSender,
		Translation: translationService,
	}
	forgotpasswordService := &forgotpassword.Service{
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     serviceService,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
		PasswordSender: sender2,
		Events:         eventService,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeStore := &challenge.Store{
		Redis: appredisHandle,
		AppID: appID,
	}
	challengeProvider := &challenge.Provider{
		Store: challengeStore,
		AppID: appID,
		Clock: clockClock,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	oauthsessionStoreRedis := &oauthsession.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		RateLimitsEnvConfig:             rateLimitsEnvironmentConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		OAuthStateStore:                 webappoauthStore,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		PasswordGenerator:               generator,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef,
		OAuthSessions:                   oauthsessionStoreRedis,
		MFADeviceTokenCookie:            mfaCookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	serviceInteractionService := &service3.InteractionService{
		Graph: interactionService,
	}
	facadeUserFacade := &facade2.UserFacade{
		Clock:              clockClock,
		UserSearchService:  searchService,
		Users:              userFacade,
		LoginIDConfig:      loginIDConfig,
		Authenticators:     service4,
		StandardAttributes: serviceNoEvent,
		Interaction:        serviceInteractionService,
	}
	rolesGroupsFacade := &facade2.RolesGroupsFacade{
		RolesGroupsCommands: commands,
		RolesGroupsQueries:  queries,
	}
	auditLogFeatureConfig := featureConfig.AuditLog
	auditLogFacade := &facade2.AuditLogFacade{
		AuditLogQuery:         query,
		Clock:                 clockClock,
		AuditDatabase:         readHandle,
		AuditLogFeatureConfig: auditLogFeatureConfig,
	}
	facadeIdentityFacade := &facade.IdentityFacade{
		Coordinator: coordinator,
	}
	identityFacade2 := &facade2.IdentityFacade{
		LoginIDConfig: loginIDConfig,
		Identities:    facadeIdentityFacade,
		Interaction:   serviceInteractionService,
	}
	facadeAuthenticatorFacade := &facade2.AuthenticatorFacade{
		Authenticators: service4,
		Interaction:    serviceInteractionService,
	}
	adminVerificationFacade := &facade.AdminVerificationFacade{
		Verification: verificationService,
		Coordinator:  coordinator,
	}
	verificationFacade := &facade2.VerificationFacade{
		Verification: adminVerificationFacade,
	}
	sessionFacade := &facade2.SessionFacade{
		Sessions: manager2,
	}
	userProfileFacade := &facade2.UserProfileFacade{
		User:               userFacade,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Events:             eventService,
	}
	oauthOfflineGrantService := &oauth2.OfflineGrantService{
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		OAuthConfig:     oAuthConfig,
		Clock:           clockClock,
		IDPSessions:     idpsessionProvider,
		ClientResolver:  oauthclientResolver,
		AccessEvents:    eventProvider,
		MeterService:    meterService,
		OfflineGrants:   redisStore,
	}
	authorizationService := &oauth2.AuthorizationService{
		AppID:               appID,
		Store:               authorizationStore,
		Clock:               clockClock,
		OAuthSessionManager: sessionManager,
		OfflineGrantService: oauthOfflineGrantService,
		OfflineGrantStore:   redisStore,
	}
	authorizationFacade := &facade2.AuthorizationFacade{
		Authorizations: authorizationService,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets:         oAuthKeyMaterials,
		BaseURL:         endpointsEndpoints,
		UserInfoService: userInfoService,
		Clock:           clockClock,
	}
	accessTokenEncoding := &oauth2.AccessTokenEncoding{
		Secrets:       oAuthKeyMaterials,
		Clock:         clockClock,
		IDTokenIssuer: idTokenIssuer,
		BaseURL:       endpointsEndpoints,
		Events:        eventService,
		Identities:    facadeIdentityFacade,
	}
	tokenGenerator := _wireTokenGeneratorValue
	oauthAccessTokenEncoding := oauth2.AccessTokenEncoding{
		Secrets:       oAuthKeyMaterials,
		Clock:         clockClock,
		IDTokenIssuer: idTokenIssuer,
		BaseURL:       endpointsEndpoints,
		Events:        eventService,
		Identities:    facadeIdentityFacade,
	}
	accessGrantService := &oauth2.AccessGrantService{
		AppID:             appID,
		AccessGrants:      redisStore,
		AccessTokenIssuer: oauthAccessTokenEncoding,
		Clock:             clockClock,
	}
	tokenService := &handler.TokenService{
		RemoteIP:            remoteIP,
		UserAgentString:     userAgentString,
		AppID:               appID,
		Config:              oAuthConfig,
		Authorizations:      authorizationStore,
		OfflineGrants:       redisStore,
		AccessGrants:        redisStore,
		OfflineGrantService: oauthOfflineGrantService,
		AccessEvents:        eventProvider,
		AccessTokenIssuer:   accessTokenEncoding,
		GenerateToken:       tokenGenerator,
		Clock:               clockClock,
		Users:               userQueries,
		Events:              eventService,
		AccessGrantService:  accessGrantService,
	}
	oAuthFacade := &facade2.OAuthFacade{
		Config:              oAuthConfig,
		Users:               userFacade,
		Authorizations:      authorizationService,
		Tokens:              tokenService,
		AccessTokenCoding:   accessTokenEncoding,
		Clock:               clockClock,
		OAuthClientResolver: oauthclientResolver,
	}
	sessionListingService := &sessionlisting.SessionListingService{
		OAuthConfig:   oAuthConfig,
		IDPSessions:   idpsessionProvider,
		OfflineGrants: oauthOfflineGrantService,
	}
	resourcescopeCommands := &resourcescope.Commands{
		Store:       resourcescopeStore,
		OAuthConfig: oAuthConfig,
	}
	resourceScopeFacade := &facade2.ResourceScopeFacade{
		ResourceScopeCommands: resourcescopeCommands,
		ResourceScopeQueries:  resourcescopeQueries,
	}
	graphqlContext := &graphql.Context{
		Config:                appConfig,
		OAuthConfig:           oAuthConfig,
		AdminAPIFeatureConfig: adminAPIFeatureConfig,
		Users:                 userLoader,
		Identities:            identityLoader,
		Authenticators:        authenticatorLoader,
		Roles:                 roleLoader,
		Groups:                groupLoader,
		AuditLogs:             auditLogLoader,
		Resources:             resourceLoader,
		ResourceClients:       resourceClientLoader,
		Scopes:                scopeLoader,
		UserFacade:            facadeUserFacade,
		RolesGroupsFacade:     rolesGroupsFacade,
		AuditLogFacade:        auditLogFacade,
		IdentityFacade:        identityFacade2,
		AuthenticatorFacade:   facadeAuthenticatorFacade,
		VerificationFacade:    verificationFacade,
		SessionFacade:         sessionFacade,
		UserProfileFacade:     userProfileFacade,
		AuthorizationFacade:   authorizationFacade,
		OAuthFacade:           oAuthFacade,
		SessionListing:        sessionListingService,
		OTPCode:               otpService,
		ForgotPassword:        forgotpasswordService,
		Events:                eventService,
		ResourceScopeFacade:   resourceScopeFacade,
	}
	graphQLHandler := &transport.GraphQLHandler{
		GraphQLContext: graphqlContext,
		AppDatabase:    handle,
	}
	return graphQLHandler
}

var (
	_wireRandValue           = idpsession.Rand(rand.SecureRand)
	_wireMaxTrialsValue      = password.DefaultMaxTrials
	_wireTokenGeneratorValue = handler.TokenGenerator(oauth2.GenerateToken)
)

func newPresignImagesUploadHandler(p *deps.RequestProvider) http.Handler {
	request := p.Request
	appProvider := p.AppProvider
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	appContext := appProvider.AppContext
	configConfig := appContext.Config
	appConfig := configConfig.AppConfig
	appID := appConfig.ID
	secretConfig := configConfig.SecretConfig
	imagesKeyMaterials := deps.ProvideImagesKeyMaterials(secretConfig)
	clockClock := _wireSystemClockValue
	provider := &presign.Provider{
		Secret: imagesKeyMaterials,
		Clock:  clockClock,
		Host:   httpHost,
	}
	presignImagesUploadHandler := &transport.PresignImagesUploadHandler{
		HTTPProto:       httpProto,
		HTTPHost:        httpHost,
		AppID:           appID,
		PresignProvider: provider,
	}
	return presignImagesUploadHandler
}

func newUserImportCreateHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	configConfig := appContext.Config
	appConfig := configConfig.AppConfig
	appID := appConfig.ID
	clockClock := _wireSystemClockValue
	featureConfig := configConfig.FeatureConfig
	adminAPIFeatureConfig := featureConfig.AdminAPI
	handle := appProvider.Redis
	userImportProducer := redisqueue.NewUserImportProducer(handle, clockClock)
	limiter := &usage.Limiter{
		Clock: clockClock,
		AppID: appID,
		Redis: handle,
	}
	storeRedis := &userimport.StoreRedis{
		AppID: appID,
		Redis: handle,
	}
	jobManager := &userimport.JobManager{
		AppID:                 appID,
		Clock:                 clockClock,
		AdminAPIFeatureConfig: adminAPIFeatureConfig,
		TaskProducer:          userImportProducer,
		UsageLimiter:          limiter,
		Store:                 storeRedis,
	}
	userImportCreateHandler := &transport.UserImportCreateHandler{
		UserImports: jobManager,
	}
	return userImportCreateHandler
}

func newUserImportGetHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	configConfig := appContext.Config
	appConfig := configConfig.AppConfig
	appID := appConfig.ID
	clockClock := _wireSystemClockValue
	featureConfig := configConfig.FeatureConfig
	adminAPIFeatureConfig := featureConfig.AdminAPI
	handle := appProvider.Redis
	userImportProducer := redisqueue.NewUserImportProducer(handle, clockClock)
	limiter := &usage.Limiter{
		Clock: clockClock,
		AppID: appID,
		Redis: handle,
	}
	storeRedis := &userimport.StoreRedis{
		AppID: appID,
		Redis: handle,
	}
	jobManager := &userimport.JobManager{
		AppID:                 appID,
		Clock:                 clockClock,
		AdminAPIFeatureConfig: adminAPIFeatureConfig,
		TaskProducer:          userImportProducer,
		UsageLimiter:          limiter,
		Store:                 storeRedis,
	}
	userImportGetHandler := &transport.UserImportGetHandler{
		AppID:       appID,
		UserImports: jobManager,
	}
	return userImportGetHandler
}

func newUserExportCreateHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	configConfig := appContext.Config
	appConfig := configConfig.AppConfig
	appID := appConfig.ID
	featureConfig := configConfig.FeatureConfig
	adminAPIFeatureConfig := featureConfig.AdminAPI
	handle := appProvider.Redis
	clockClock := _wireSystemClockValue
	userExportProducer := redisqueue.NewUserExportProducer(handle, clockClock)
	limiter := &usage.Limiter{
		Clock: clockClock,
		AppID: appID,
		Redis: handle,
	}
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	userExportObjectStoreConfig := environmentConfig.UserExportObjectStore
	userExportCloudStorage := userexport.NewCloudStorage(userExportObjectStoreConfig, clockClock)
	appdbHandle := appProvider.AppDatabase
	userProfileConfig := appConfig.UserProfile
	secretConfig := configConfig.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	sqlExecutor := appdb.NewSQLExecutor(appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
		AppID:       appID,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	ssooAuthDemoCredentials := deps.ProvideSSOOAuthDemoCredentials(secretConfig)
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	uiConfig := appConfig.UI
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		UIConfig:      uiConfig,
		LoginIDConfig: loginIDConfig,
		Resources:     manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth.Provider{
		Store: oauthStore,
		Clock: clockClock,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Redis: handle,
		AppID: appID,
	}
	request := p.Request
	trustProxy := environmentConfig.TrustProxy
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(configConfig)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(configConfig)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	smtpServerCredentialsSecretItem := deps.ProvideSMTPServerCredentialsItem(secretConfig)
	translationService := &translation.Service{
		TemplateEngine:                  engine,
		StaticAssets:                    staticAssetResolver,
		SMTPServerCredentialsSecretItem: smtpServerCredentialsSecretItem,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
	}
	ldapStore := &ldap.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	normalizer := &stdattrs.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	ldapProvider := &ldap.Provider{
		Store:                        ldapStore,
		Clock:                        clockClock,
		StandardAttributesNormalizer: normalizer,
	}
	serviceService := &service.Service{
		Authentication:          authenticationConfig,
		Identity:                identityConfig,
		IdentityFeatureConfig:   identityFeatureConfig,
		SSOOAuthDemoCredentials: ssooAuthDemoCredentials,
		Store:                   serviceStore,
		LoginID:                 provider,
		OAuth:                   oauthProvider,
		Anonymous:               anonymousProvider,
		Biometric:               biometricProvider,
		Passkey:                 passkeyProvider,
		SIWE:                    siweProvider,
		LDAP:                    ldapProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	expiry := password.ProvideExpiry(authenticatorPasswordConfig, clockClock)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Expiry:          expiry,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeConfig := appConfig.TestMode
	testModeFeatureConfig := featureConfig.TestMode
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storageRedis := ratelimit.NewAppStorageRedis(handle)
	rateLimitsFeatureConfig := featureConfig.RateLimits
	ratelimitLimiter := &ratelimit.Limiter{
		Storage: storageRedis,
		AppID:   appID,
		Config:  rateLimitsFeatureConfig,
	}
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeConfig:        testModeConfig,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		RateLimiter:           ratelimitLimiter,
		FeatureConfig:         featureConfig,
		EnvConfig:             rateLimitsEnvironmentConfig,
	}
	rateLimits := service2.RateLimits{
		IP:            remoteIP,
		Config:        appConfig,
		FeatureConfig: featureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
		RateLimiter:   ratelimitLimiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service4 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs2.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs2.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	rolesgroupsStore := &rolesgroups.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	queries := &rolesgroups.Queries{
		Store: rolesgroupsStore,
	}
	userQueries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service4,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		RolesAndGroups:     queries,
	}
	httpClient := userexport.NewHTTPClient()
	userExportService := &userexport.UserExportService{
		AppDatabase:  appdbHandle,
		Config:       userProfileConfig,
		UserQueries:  userQueries,
		HTTPOrigin:   httpOrigin,
		HTTPClient:   httpClient,
		CloudStorage: userExportCloudStorage,
		Clock:        clockClock,
	}
	userExportCreateHandler := &transport.UserExportCreateHandler{
		AppID:                 appID,
		AdminAPIFeatureConfig: adminAPIFeatureConfig,
		Producer:              userExportProducer,
		UsageLimiter:          limiter,
		CloudStorage:          userExportCloudStorage,
		Service:               userExportService,
	}
	return userExportCreateHandler
}

func newUserExportGetHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	configConfig := appContext.Config
	appConfig := configConfig.AppConfig
	appID := appConfig.ID
	handle := appProvider.Redis
	clockClock := _wireSystemClockValue
	userExportProducer := redisqueue.NewUserExportProducer(handle, clockClock)
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	userExportObjectStoreConfig := environmentConfig.UserExportObjectStore
	userExportCloudStorage := userexport.NewCloudStorage(userExportObjectStoreConfig, clockClock)
	userExportGetHandler := &transport.UserExportGetHandler{
		AppID:        appID,
		UserExports:  userExportProducer,
		CloudStorage: userExportCloudStorage,
	}
	return userExportGetHandler
}
