package config

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *APIClientConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "client_name":
			z.ClientName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientName")
				return
			}
		case "client_id":
			z.ClientID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientID")
				return
			}
		case "session_transport":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "SessionTransport")
					return
				}
				z.SessionTransport = SessionTransportType(zb0002)
			}
		case "access_token_lifetime":
			z.AccessTokenLifetime, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AccessTokenLifetime")
				return
			}
		case "session_idle_timeout_enabled":
			z.SessionIdleTimeoutEnabled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "SessionIdleTimeoutEnabled")
				return
			}
		case "session_idle_timeout":
			z.SessionIdleTimeout, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SessionIdleTimeout")
				return
			}
		case "refresh_token_disabled":
			z.RefreshTokenDisabled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "RefreshTokenDisabled")
				return
			}
		case "refresh_token_lifetime":
			z.RefreshTokenLifetime, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RefreshTokenLifetime")
				return
			}
		case "same_site":
			{
				var zb0003 string
				zb0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "SameSite")
					return
				}
				z.SameSite = SessionCookieSameSite(zb0003)
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *APIClientConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 9
	// write "client_name"
	err = en.Append(0x89, 0xab, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientName)
	if err != nil {
		err = msgp.WrapError(err, "ClientName")
		return
	}
	// write "client_id"
	err = en.Append(0xa9, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientID)
	if err != nil {
		err = msgp.WrapError(err, "ClientID")
		return
	}
	// write "session_transport"
	err = en.Append(0xb1, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.SessionTransport))
	if err != nil {
		err = msgp.WrapError(err, "SessionTransport")
		return
	}
	// write "access_token_lifetime"
	err = en.Append(0xb5, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x6c, 0x69, 0x66, 0x65, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AccessTokenLifetime)
	if err != nil {
		err = msgp.WrapError(err, "AccessTokenLifetime")
		return
	}
	// write "session_idle_timeout_enabled"
	err = en.Append(0xbc, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x6c, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.SessionIdleTimeoutEnabled)
	if err != nil {
		err = msgp.WrapError(err, "SessionIdleTimeoutEnabled")
		return
	}
	// write "session_idle_timeout"
	err = en.Append(0xb4, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x6c, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SessionIdleTimeout)
	if err != nil {
		err = msgp.WrapError(err, "SessionIdleTimeout")
		return
	}
	// write "refresh_token_disabled"
	err = en.Append(0xb6, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.RefreshTokenDisabled)
	if err != nil {
		err = msgp.WrapError(err, "RefreshTokenDisabled")
		return
	}
	// write "refresh_token_lifetime"
	err = en.Append(0xb6, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x6c, 0x69, 0x66, 0x65, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.RefreshTokenLifetime)
	if err != nil {
		err = msgp.WrapError(err, "RefreshTokenLifetime")
		return
	}
	// write "same_site"
	err = en.Append(0xa9, 0x73, 0x61, 0x6d, 0x65, 0x5f, 0x73, 0x69, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.SameSite))
	if err != nil {
		err = msgp.WrapError(err, "SameSite")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *APIClientConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "client_name"
	o = append(o, 0x89, 0xab, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.ClientName)
	// string "client_id"
	o = append(o, 0xa9, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ClientID)
	// string "session_transport"
	o = append(o, 0xb1, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74)
	o = msgp.AppendString(o, string(z.SessionTransport))
	// string "access_token_lifetime"
	o = append(o, 0xb5, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x6c, 0x69, 0x66, 0x65, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt(o, z.AccessTokenLifetime)
	// string "session_idle_timeout_enabled"
	o = append(o, 0xbc, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x6c, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.SessionIdleTimeoutEnabled)
	// string "session_idle_timeout"
	o = append(o, 0xb4, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x6c, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74)
	o = msgp.AppendInt(o, z.SessionIdleTimeout)
	// string "refresh_token_disabled"
	o = append(o, 0xb6, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.RefreshTokenDisabled)
	// string "refresh_token_lifetime"
	o = append(o, 0xb6, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x6c, 0x69, 0x66, 0x65, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt(o, z.RefreshTokenLifetime)
	// string "same_site"
	o = append(o, 0xa9, 0x73, 0x61, 0x6d, 0x65, 0x5f, 0x73, 0x69, 0x74, 0x65)
	o = msgp.AppendString(o, string(z.SameSite))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *APIClientConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "client_name":
			z.ClientName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientName")
				return
			}
		case "client_id":
			z.ClientID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientID")
				return
			}
		case "session_transport":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SessionTransport")
					return
				}
				z.SessionTransport = SessionTransportType(zb0002)
			}
		case "access_token_lifetime":
			z.AccessTokenLifetime, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AccessTokenLifetime")
				return
			}
		case "session_idle_timeout_enabled":
			z.SessionIdleTimeoutEnabled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SessionIdleTimeoutEnabled")
				return
			}
		case "session_idle_timeout":
			z.SessionIdleTimeout, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SessionIdleTimeout")
				return
			}
		case "refresh_token_disabled":
			z.RefreshTokenDisabled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RefreshTokenDisabled")
				return
			}
		case "refresh_token_lifetime":
			z.RefreshTokenLifetime, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RefreshTokenLifetime")
				return
			}
		case "same_site":
			{
				var zb0003 string
				zb0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SameSite")
					return
				}
				z.SameSite = SessionCookieSameSite(zb0003)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *APIClientConfiguration) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.ClientName) + 10 + msgp.StringPrefixSize + len(z.ClientID) + 18 + msgp.StringPrefixSize + len(string(z.SessionTransport)) + 22 + msgp.IntSize + 29 + msgp.BoolSize + 21 + msgp.IntSize + 23 + msgp.BoolSize + 23 + msgp.IntSize + 10 + msgp.StringPrefixSize + len(string(z.SameSite))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *AppConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "api_version":
			z.APIVersion, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "APIVersion")
				return
			}
		case "display_app_name":
			z.DisplayAppName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DisplayAppName")
				return
			}
		case "clients":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Clients")
				return
			}
			if cap(z.Clients) >= int(zb0002) {
				z.Clients = (z.Clients)[:zb0002]
			} else {
				z.Clients = make([]APIClientConfiguration, zb0002)
			}
			for za0001 := range z.Clients {
				err = z.Clients[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Clients", za0001)
					return
				}
			}
		case "master_key":
			z.MasterKey, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "MasterKey")
				return
			}
		case "cors":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "CORS")
					return
				}
				z.CORS = nil
			} else {
				if z.CORS == nil {
					z.CORS = new(CORSConfiguration)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "CORS")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "CORS")
						return
					}
					switch msgp.UnsafeString(field) {
					case "origin":
						z.CORS.Origin, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "CORS", "Origin")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "CORS")
							return
						}
					}
				}
			}
		case "auth":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Auth")
					return
				}
				z.Auth = nil
			} else {
				if z.Auth == nil {
					z.Auth = new(AuthConfiguration)
				}
				err = z.Auth.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Auth")
					return
				}
			}
		case "mfa":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "MFA")
					return
				}
				z.MFA = nil
			} else {
				if z.MFA == nil {
					z.MFA = new(MFAConfiguration)
				}
				err = z.MFA.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "MFA")
					return
				}
			}
		case "user_audit":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "UserAudit")
					return
				}
				z.UserAudit = nil
			} else {
				if z.UserAudit == nil {
					z.UserAudit = new(UserAuditConfiguration)
				}
				var zb0004 uint32
				zb0004, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "UserAudit")
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "UserAudit")
						return
					}
					switch msgp.UnsafeString(field) {
					case "enabled":
						z.UserAudit.Enabled, err = dc.ReadBool()
						if err != nil {
							err = msgp.WrapError(err, "UserAudit", "Enabled")
							return
						}
					case "trail_handler_url":
						z.UserAudit.TrailHandlerURL, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "UserAudit", "TrailHandlerURL")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "UserAudit")
							return
						}
					}
				}
			}
		case "password_policy":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PasswordPolicy")
					return
				}
				z.PasswordPolicy = nil
			} else {
				if z.PasswordPolicy == nil {
					z.PasswordPolicy = new(PasswordPolicyConfiguration)
				}
				err = z.PasswordPolicy.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "PasswordPolicy")
					return
				}
			}
		case "forgot_password":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "ForgotPassword")
					return
				}
				z.ForgotPassword = nil
			} else {
				if z.ForgotPassword == nil {
					z.ForgotPassword = new(ForgotPasswordConfiguration)
				}
				err = z.ForgotPassword.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ForgotPassword")
					return
				}
			}
		case "welcome_email":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "WelcomeEmail")
					return
				}
				z.WelcomeEmail = nil
			} else {
				if z.WelcomeEmail == nil {
					z.WelcomeEmail = new(WelcomeEmailConfiguration)
				}
				err = z.WelcomeEmail.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "WelcomeEmail")
					return
				}
			}
		case "sso":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SSO")
					return
				}
				z.SSO = nil
			} else {
				if z.SSO == nil {
					z.SSO = new(SSOConfiguration)
				}
				var zb0005 uint32
				zb0005, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "SSO")
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "SSO")
						return
					}
					switch msgp.UnsafeString(field) {
					case "oauth":
						if dc.IsNil() {
							err = dc.ReadNil()
							if err != nil {
								err = msgp.WrapError(err, "SSO", "OAuth")
								return
							}
							z.SSO.OAuth = nil
						} else {
							if z.SSO.OAuth == nil {
								z.SSO.OAuth = new(OAuthConfiguration)
							}
							err = z.SSO.OAuth.DecodeMsg(dc)
							if err != nil {
								err = msgp.WrapError(err, "SSO", "OAuth")
								return
							}
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "SSO")
							return
						}
					}
				}
			}
		case "user_verification":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "UserVerification")
					return
				}
				z.UserVerification = nil
			} else {
				if z.UserVerification == nil {
					z.UserVerification = new(UserVerificationConfiguration)
				}
				err = z.UserVerification.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "UserVerification")
					return
				}
			}
		case "hook":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Hook")
					return
				}
				z.Hook = nil
			} else {
				if z.Hook == nil {
					z.Hook = new(HookAppConfiguration)
				}
				var zb0006 uint32
				zb0006, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Hook")
					return
				}
				for zb0006 > 0 {
					zb0006--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Hook")
						return
					}
					switch msgp.UnsafeString(field) {
					case "secret":
						z.Hook.Secret, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Hook", "Secret")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Hook")
							return
						}
					}
				}
			}
		case "smtp":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SMTP")
					return
				}
				z.SMTP = nil
			} else {
				if z.SMTP == nil {
					z.SMTP = new(SMTPConfiguration)
				}
				err = z.SMTP.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "SMTP")
					return
				}
			}
		case "twilio":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Twilio")
					return
				}
				z.Twilio = nil
			} else {
				if z.Twilio == nil {
					z.Twilio = new(TwilioConfiguration)
				}
				var zb0007 uint32
				zb0007, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Twilio")
					return
				}
				for zb0007 > 0 {
					zb0007--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Twilio")
						return
					}
					switch msgp.UnsafeString(field) {
					case "account_sid":
						z.Twilio.AccountSID, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Twilio", "AccountSID")
							return
						}
					case "auth_token":
						z.Twilio.AuthToken, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Twilio", "AuthToken")
							return
						}
					case "from":
						z.Twilio.From, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Twilio", "From")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Twilio")
							return
						}
					}
				}
			}
		case "nexmo":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Nexmo")
					return
				}
				z.Nexmo = nil
			} else {
				if z.Nexmo == nil {
					z.Nexmo = new(NexmoConfiguration)
				}
				var zb0008 uint32
				zb0008, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Nexmo")
					return
				}
				for zb0008 > 0 {
					zb0008--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Nexmo")
						return
					}
					switch msgp.UnsafeString(field) {
					case "api_key":
						z.Nexmo.APIKey, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Nexmo", "APIKey")
							return
						}
					case "api_secret":
						z.Nexmo.APISecret, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Nexmo", "APISecret")
							return
						}
					case "from":
						z.Nexmo.From, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Nexmo", "From")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Nexmo")
							return
						}
					}
				}
			}
		case "asset":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Asset")
					return
				}
				z.Asset = nil
			} else {
				if z.Asset == nil {
					z.Asset = new(AssetConfiguration)
				}
				var zb0009 uint32
				zb0009, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Asset")
					return
				}
				for zb0009 > 0 {
					zb0009--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Asset")
						return
					}
					switch msgp.UnsafeString(field) {
					case "secret":
						z.Asset.Secret, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Asset", "Secret")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Asset")
							return
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *AppConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 18
	// write "api_version"
	err = en.Append(0xde, 0x0, 0x12, 0xab, 0x61, 0x70, 0x69, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.APIVersion)
	if err != nil {
		err = msgp.WrapError(err, "APIVersion")
		return
	}
	// write "display_app_name"
	err = en.Append(0xb0, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x5f, 0x61, 0x70, 0x70, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.DisplayAppName)
	if err != nil {
		err = msgp.WrapError(err, "DisplayAppName")
		return
	}
	// write "clients"
	err = en.Append(0xa7, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Clients)))
	if err != nil {
		err = msgp.WrapError(err, "Clients")
		return
	}
	for za0001 := range z.Clients {
		err = z.Clients[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Clients", za0001)
			return
		}
	}
	// write "master_key"
	err = en.Append(0xaa, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x5f, 0x6b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.MasterKey)
	if err != nil {
		err = msgp.WrapError(err, "MasterKey")
		return
	}
	// write "cors"
	err = en.Append(0xa4, 0x63, 0x6f, 0x72, 0x73)
	if err != nil {
		return
	}
	if z.CORS == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 1
		// write "origin"
		err = en.Append(0x81, 0xa6, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.CORS.Origin)
		if err != nil {
			err = msgp.WrapError(err, "CORS", "Origin")
			return
		}
	}
	// write "auth"
	err = en.Append(0xa4, 0x61, 0x75, 0x74, 0x68)
	if err != nil {
		return
	}
	if z.Auth == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Auth.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Auth")
			return
		}
	}
	// write "mfa"
	err = en.Append(0xa3, 0x6d, 0x66, 0x61)
	if err != nil {
		return
	}
	if z.MFA == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.MFA.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "MFA")
			return
		}
	}
	// write "user_audit"
	err = en.Append(0xaa, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x61, 0x75, 0x64, 0x69, 0x74)
	if err != nil {
		return
	}
	if z.UserAudit == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "enabled"
		err = en.Append(0x82, 0xa7, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteBool(z.UserAudit.Enabled)
		if err != nil {
			err = msgp.WrapError(err, "UserAudit", "Enabled")
			return
		}
		// write "trail_handler_url"
		err = en.Append(0xb1, 0x74, 0x72, 0x61, 0x69, 0x6c, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x5f, 0x75, 0x72, 0x6c)
		if err != nil {
			return
		}
		err = en.WriteString(z.UserAudit.TrailHandlerURL)
		if err != nil {
			err = msgp.WrapError(err, "UserAudit", "TrailHandlerURL")
			return
		}
	}
	// write "password_policy"
	err = en.Append(0xaf, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79)
	if err != nil {
		return
	}
	if z.PasswordPolicy == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.PasswordPolicy.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "PasswordPolicy")
			return
		}
	}
	// write "forgot_password"
	err = en.Append(0xaf, 0x66, 0x6f, 0x72, 0x67, 0x6f, 0x74, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	if err != nil {
		return
	}
	if z.ForgotPassword == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.ForgotPassword.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "ForgotPassword")
			return
		}
	}
	// write "welcome_email"
	err = en.Append(0xad, 0x77, 0x65, 0x6c, 0x63, 0x6f, 0x6d, 0x65, 0x5f, 0x65, 0x6d, 0x61, 0x69, 0x6c)
	if err != nil {
		return
	}
	if z.WelcomeEmail == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.WelcomeEmail.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "WelcomeEmail")
			return
		}
	}
	// write "sso"
	err = en.Append(0xa3, 0x73, 0x73, 0x6f)
	if err != nil {
		return
	}
	if z.SSO == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 1
		// write "oauth"
		err = en.Append(0x81, 0xa5, 0x6f, 0x61, 0x75, 0x74, 0x68)
		if err != nil {
			return
		}
		if z.SSO.OAuth == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.SSO.OAuth.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "SSO", "OAuth")
				return
			}
		}
	}
	// write "user_verification"
	err = en.Append(0xb1, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	if z.UserVerification == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.UserVerification.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "UserVerification")
			return
		}
	}
	// write "hook"
	err = en.Append(0xa4, 0x68, 0x6f, 0x6f, 0x6b)
	if err != nil {
		return
	}
	if z.Hook == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 1
		// write "secret"
		err = en.Append(0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Hook.Secret)
		if err != nil {
			err = msgp.WrapError(err, "Hook", "Secret")
			return
		}
	}
	// write "smtp"
	err = en.Append(0xa4, 0x73, 0x6d, 0x74, 0x70)
	if err != nil {
		return
	}
	if z.SMTP == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.SMTP.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "SMTP")
			return
		}
	}
	// write "twilio"
	err = en.Append(0xa6, 0x74, 0x77, 0x69, 0x6c, 0x69, 0x6f)
	if err != nil {
		return
	}
	if z.Twilio == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 3
		// write "account_sid"
		err = en.Append(0x83, 0xab, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x73, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.Twilio.AccountSID)
		if err != nil {
			err = msgp.WrapError(err, "Twilio", "AccountSID")
			return
		}
		// write "auth_token"
		err = en.Append(0xaa, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Twilio.AuthToken)
		if err != nil {
			err = msgp.WrapError(err, "Twilio", "AuthToken")
			return
		}
		// write "from"
		err = en.Append(0xa4, 0x66, 0x72, 0x6f, 0x6d)
		if err != nil {
			return
		}
		err = en.WriteString(z.Twilio.From)
		if err != nil {
			err = msgp.WrapError(err, "Twilio", "From")
			return
		}
	}
	// write "nexmo"
	err = en.Append(0xa5, 0x6e, 0x65, 0x78, 0x6d, 0x6f)
	if err != nil {
		return
	}
	if z.Nexmo == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 3
		// write "api_key"
		err = en.Append(0x83, 0xa7, 0x61, 0x70, 0x69, 0x5f, 0x6b, 0x65, 0x79)
		if err != nil {
			return
		}
		err = en.WriteString(z.Nexmo.APIKey)
		if err != nil {
			err = msgp.WrapError(err, "Nexmo", "APIKey")
			return
		}
		// write "api_secret"
		err = en.Append(0xaa, 0x61, 0x70, 0x69, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Nexmo.APISecret)
		if err != nil {
			err = msgp.WrapError(err, "Nexmo", "APISecret")
			return
		}
		// write "from"
		err = en.Append(0xa4, 0x66, 0x72, 0x6f, 0x6d)
		if err != nil {
			return
		}
		err = en.WriteString(z.Nexmo.From)
		if err != nil {
			err = msgp.WrapError(err, "Nexmo", "From")
			return
		}
	}
	// write "asset"
	err = en.Append(0xa5, 0x61, 0x73, 0x73, 0x65, 0x74)
	if err != nil {
		return
	}
	if z.Asset == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 1
		// write "secret"
		err = en.Append(0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Asset.Secret)
		if err != nil {
			err = msgp.WrapError(err, "Asset", "Secret")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AppConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 18
	// string "api_version"
	o = append(o, 0xde, 0x0, 0x12, 0xab, 0x61, 0x70, 0x69, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.APIVersion)
	// string "display_app_name"
	o = append(o, 0xb0, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x5f, 0x61, 0x70, 0x70, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.DisplayAppName)
	// string "clients"
	o = append(o, 0xa7, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Clients)))
	for za0001 := range z.Clients {
		o, err = z.Clients[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Clients", za0001)
			return
		}
	}
	// string "master_key"
	o = append(o, 0xaa, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x5f, 0x6b, 0x65, 0x79)
	o = msgp.AppendString(o, z.MasterKey)
	// string "cors"
	o = append(o, 0xa4, 0x63, 0x6f, 0x72, 0x73)
	if z.CORS == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "origin"
		o = append(o, 0x81, 0xa6, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e)
		o = msgp.AppendString(o, z.CORS.Origin)
	}
	// string "auth"
	o = append(o, 0xa4, 0x61, 0x75, 0x74, 0x68)
	if z.Auth == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Auth.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Auth")
			return
		}
	}
	// string "mfa"
	o = append(o, 0xa3, 0x6d, 0x66, 0x61)
	if z.MFA == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.MFA.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "MFA")
			return
		}
	}
	// string "user_audit"
	o = append(o, 0xaa, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x61, 0x75, 0x64, 0x69, 0x74)
	if z.UserAudit == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "enabled"
		o = append(o, 0x82, 0xa7, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
		o = msgp.AppendBool(o, z.UserAudit.Enabled)
		// string "trail_handler_url"
		o = append(o, 0xb1, 0x74, 0x72, 0x61, 0x69, 0x6c, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x5f, 0x75, 0x72, 0x6c)
		o = msgp.AppendString(o, z.UserAudit.TrailHandlerURL)
	}
	// string "password_policy"
	o = append(o, 0xaf, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79)
	if z.PasswordPolicy == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.PasswordPolicy.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "PasswordPolicy")
			return
		}
	}
	// string "forgot_password"
	o = append(o, 0xaf, 0x66, 0x6f, 0x72, 0x67, 0x6f, 0x74, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	if z.ForgotPassword == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.ForgotPassword.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "ForgotPassword")
			return
		}
	}
	// string "welcome_email"
	o = append(o, 0xad, 0x77, 0x65, 0x6c, 0x63, 0x6f, 0x6d, 0x65, 0x5f, 0x65, 0x6d, 0x61, 0x69, 0x6c)
	if z.WelcomeEmail == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.WelcomeEmail.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "WelcomeEmail")
			return
		}
	}
	// string "sso"
	o = append(o, 0xa3, 0x73, 0x73, 0x6f)
	if z.SSO == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "oauth"
		o = append(o, 0x81, 0xa5, 0x6f, 0x61, 0x75, 0x74, 0x68)
		if z.SSO.OAuth == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.SSO.OAuth.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "SSO", "OAuth")
				return
			}
		}
	}
	// string "user_verification"
	o = append(o, 0xb1, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	if z.UserVerification == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.UserVerification.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "UserVerification")
			return
		}
	}
	// string "hook"
	o = append(o, 0xa4, 0x68, 0x6f, 0x6f, 0x6b)
	if z.Hook == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "secret"
		o = append(o, 0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
		o = msgp.AppendString(o, z.Hook.Secret)
	}
	// string "smtp"
	o = append(o, 0xa4, 0x73, 0x6d, 0x74, 0x70)
	if z.SMTP == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.SMTP.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "SMTP")
			return
		}
	}
	// string "twilio"
	o = append(o, 0xa6, 0x74, 0x77, 0x69, 0x6c, 0x69, 0x6f)
	if z.Twilio == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 3
		// string "account_sid"
		o = append(o, 0x83, 0xab, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x73, 0x69, 0x64)
		o = msgp.AppendString(o, z.Twilio.AccountSID)
		// string "auth_token"
		o = append(o, 0xaa, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
		o = msgp.AppendString(o, z.Twilio.AuthToken)
		// string "from"
		o = append(o, 0xa4, 0x66, 0x72, 0x6f, 0x6d)
		o = msgp.AppendString(o, z.Twilio.From)
	}
	// string "nexmo"
	o = append(o, 0xa5, 0x6e, 0x65, 0x78, 0x6d, 0x6f)
	if z.Nexmo == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 3
		// string "api_key"
		o = append(o, 0x83, 0xa7, 0x61, 0x70, 0x69, 0x5f, 0x6b, 0x65, 0x79)
		o = msgp.AppendString(o, z.Nexmo.APIKey)
		// string "api_secret"
		o = append(o, 0xaa, 0x61, 0x70, 0x69, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
		o = msgp.AppendString(o, z.Nexmo.APISecret)
		// string "from"
		o = append(o, 0xa4, 0x66, 0x72, 0x6f, 0x6d)
		o = msgp.AppendString(o, z.Nexmo.From)
	}
	// string "asset"
	o = append(o, 0xa5, 0x61, 0x73, 0x73, 0x65, 0x74)
	if z.Asset == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "secret"
		o = append(o, 0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
		o = msgp.AppendString(o, z.Asset.Secret)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AppConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "api_version":
			z.APIVersion, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "APIVersion")
				return
			}
		case "display_app_name":
			z.DisplayAppName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DisplayAppName")
				return
			}
		case "clients":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Clients")
				return
			}
			if cap(z.Clients) >= int(zb0002) {
				z.Clients = (z.Clients)[:zb0002]
			} else {
				z.Clients = make([]APIClientConfiguration, zb0002)
			}
			for za0001 := range z.Clients {
				bts, err = z.Clients[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Clients", za0001)
					return
				}
			}
		case "master_key":
			z.MasterKey, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MasterKey")
				return
			}
		case "cors":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.CORS = nil
			} else {
				if z.CORS == nil {
					z.CORS = new(CORSConfiguration)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CORS")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "CORS")
						return
					}
					switch msgp.UnsafeString(field) {
					case "origin":
						z.CORS.Origin, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "CORS", "Origin")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "CORS")
							return
						}
					}
				}
			}
		case "auth":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Auth = nil
			} else {
				if z.Auth == nil {
					z.Auth = new(AuthConfiguration)
				}
				bts, err = z.Auth.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Auth")
					return
				}
			}
		case "mfa":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.MFA = nil
			} else {
				if z.MFA == nil {
					z.MFA = new(MFAConfiguration)
				}
				bts, err = z.MFA.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "MFA")
					return
				}
			}
		case "user_audit":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.UserAudit = nil
			} else {
				if z.UserAudit == nil {
					z.UserAudit = new(UserAuditConfiguration)
				}
				var zb0004 uint32
				zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UserAudit")
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "UserAudit")
						return
					}
					switch msgp.UnsafeString(field) {
					case "enabled":
						z.UserAudit.Enabled, bts, err = msgp.ReadBoolBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "UserAudit", "Enabled")
							return
						}
					case "trail_handler_url":
						z.UserAudit.TrailHandlerURL, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "UserAudit", "TrailHandlerURL")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "UserAudit")
							return
						}
					}
				}
			}
		case "password_policy":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PasswordPolicy = nil
			} else {
				if z.PasswordPolicy == nil {
					z.PasswordPolicy = new(PasswordPolicyConfiguration)
				}
				bts, err = z.PasswordPolicy.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "PasswordPolicy")
					return
				}
			}
		case "forgot_password":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ForgotPassword = nil
			} else {
				if z.ForgotPassword == nil {
					z.ForgotPassword = new(ForgotPasswordConfiguration)
				}
				bts, err = z.ForgotPassword.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ForgotPassword")
					return
				}
			}
		case "welcome_email":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.WelcomeEmail = nil
			} else {
				if z.WelcomeEmail == nil {
					z.WelcomeEmail = new(WelcomeEmailConfiguration)
				}
				bts, err = z.WelcomeEmail.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "WelcomeEmail")
					return
				}
			}
		case "sso":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SSO = nil
			} else {
				if z.SSO == nil {
					z.SSO = new(SSOConfiguration)
				}
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SSO")
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "SSO")
						return
					}
					switch msgp.UnsafeString(field) {
					case "oauth":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.SSO.OAuth = nil
						} else {
							if z.SSO.OAuth == nil {
								z.SSO.OAuth = new(OAuthConfiguration)
							}
							bts, err = z.SSO.OAuth.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SSO", "OAuth")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "SSO")
							return
						}
					}
				}
			}
		case "user_verification":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.UserVerification = nil
			} else {
				if z.UserVerification == nil {
					z.UserVerification = new(UserVerificationConfiguration)
				}
				bts, err = z.UserVerification.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UserVerification")
					return
				}
			}
		case "hook":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Hook = nil
			} else {
				if z.Hook == nil {
					z.Hook = new(HookAppConfiguration)
				}
				var zb0006 uint32
				zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Hook")
					return
				}
				for zb0006 > 0 {
					zb0006--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Hook")
						return
					}
					switch msgp.UnsafeString(field) {
					case "secret":
						z.Hook.Secret, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Hook", "Secret")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Hook")
							return
						}
					}
				}
			}
		case "smtp":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SMTP = nil
			} else {
				if z.SMTP == nil {
					z.SMTP = new(SMTPConfiguration)
				}
				bts, err = z.SMTP.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SMTP")
					return
				}
			}
		case "twilio":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Twilio = nil
			} else {
				if z.Twilio == nil {
					z.Twilio = new(TwilioConfiguration)
				}
				var zb0007 uint32
				zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Twilio")
					return
				}
				for zb0007 > 0 {
					zb0007--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Twilio")
						return
					}
					switch msgp.UnsafeString(field) {
					case "account_sid":
						z.Twilio.AccountSID, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Twilio", "AccountSID")
							return
						}
					case "auth_token":
						z.Twilio.AuthToken, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Twilio", "AuthToken")
							return
						}
					case "from":
						z.Twilio.From, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Twilio", "From")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Twilio")
							return
						}
					}
				}
			}
		case "nexmo":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Nexmo = nil
			} else {
				if z.Nexmo == nil {
					z.Nexmo = new(NexmoConfiguration)
				}
				var zb0008 uint32
				zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Nexmo")
					return
				}
				for zb0008 > 0 {
					zb0008--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Nexmo")
						return
					}
					switch msgp.UnsafeString(field) {
					case "api_key":
						z.Nexmo.APIKey, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Nexmo", "APIKey")
							return
						}
					case "api_secret":
						z.Nexmo.APISecret, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Nexmo", "APISecret")
							return
						}
					case "from":
						z.Nexmo.From, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Nexmo", "From")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Nexmo")
							return
						}
					}
				}
			}
		case "asset":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Asset = nil
			} else {
				if z.Asset == nil {
					z.Asset = new(AssetConfiguration)
				}
				var zb0009 uint32
				zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Asset")
					return
				}
				for zb0009 > 0 {
					zb0009--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Asset")
						return
					}
					switch msgp.UnsafeString(field) {
					case "secret":
						z.Asset.Secret, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Asset", "Secret")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Asset")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AppConfiguration) Msgsize() (s int) {
	s = 3 + 12 + msgp.StringPrefixSize + len(z.APIVersion) + 17 + msgp.StringPrefixSize + len(z.DisplayAppName) + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Clients {
		s += z.Clients[za0001].Msgsize()
	}
	s += 11 + msgp.StringPrefixSize + len(z.MasterKey) + 5
	if z.CORS == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 7 + msgp.StringPrefixSize + len(z.CORS.Origin)
	}
	s += 5
	if z.Auth == nil {
		s += msgp.NilSize
	} else {
		s += z.Auth.Msgsize()
	}
	s += 4
	if z.MFA == nil {
		s += msgp.NilSize
	} else {
		s += z.MFA.Msgsize()
	}
	s += 11
	if z.UserAudit == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 8 + msgp.BoolSize + 18 + msgp.StringPrefixSize + len(z.UserAudit.TrailHandlerURL)
	}
	s += 16
	if z.PasswordPolicy == nil {
		s += msgp.NilSize
	} else {
		s += z.PasswordPolicy.Msgsize()
	}
	s += 16
	if z.ForgotPassword == nil {
		s += msgp.NilSize
	} else {
		s += z.ForgotPassword.Msgsize()
	}
	s += 14
	if z.WelcomeEmail == nil {
		s += msgp.NilSize
	} else {
		s += z.WelcomeEmail.Msgsize()
	}
	s += 4
	if z.SSO == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 6
		if z.SSO.OAuth == nil {
			s += msgp.NilSize
		} else {
			s += z.SSO.OAuth.Msgsize()
		}
	}
	s += 18
	if z.UserVerification == nil {
		s += msgp.NilSize
	} else {
		s += z.UserVerification.Msgsize()
	}
	s += 5
	if z.Hook == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 7 + msgp.StringPrefixSize + len(z.Hook.Secret)
	}
	s += 5
	if z.SMTP == nil {
		s += msgp.NilSize
	} else {
		s += z.SMTP.Msgsize()
	}
	s += 7
	if z.Twilio == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 12 + msgp.StringPrefixSize + len(z.Twilio.AccountSID) + 11 + msgp.StringPrefixSize + len(z.Twilio.AuthToken) + 5 + msgp.StringPrefixSize + len(z.Twilio.From)
	}
	s += 6
	if z.Nexmo == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 8 + msgp.StringPrefixSize + len(z.Nexmo.APIKey) + 11 + msgp.StringPrefixSize + len(z.Nexmo.APISecret) + 5 + msgp.StringPrefixSize + len(z.Nexmo.From)
	}
	s += 6
	if z.Asset == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 7 + msgp.StringPrefixSize + len(z.Asset.Secret)
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *AssetConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "secret":
			z.Secret, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Secret")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z AssetConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "secret"
	err = en.Append(0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Secret)
	if err != nil {
		err = msgp.WrapError(err, "Secret")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AssetConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "secret"
	o = append(o, 0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	o = msgp.AppendString(o, z.Secret)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AssetConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "secret":
			z.Secret, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Secret")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AssetConfiguration) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Secret)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *AuthConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "authentication_session":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AuthenticationSession")
					return
				}
				z.AuthenticationSession = nil
			} else {
				if z.AuthenticationSession == nil {
					z.AuthenticationSession = new(AuthenticationSessionConfiguration)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "AuthenticationSession")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "AuthenticationSession")
						return
					}
					switch msgp.UnsafeString(field) {
					case "secret":
						z.AuthenticationSession.Secret, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "AuthenticationSession", "Secret")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "AuthenticationSession")
							return
						}
					}
				}
			}
		case "login_id_types":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LoginIDTypes")
					return
				}
				z.LoginIDTypes = nil
			} else {
				if z.LoginIDTypes == nil {
					z.LoginIDTypes = new(LoginIDTypesConfiguration)
				}
				err = z.LoginIDTypes.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LoginIDTypes")
					return
				}
			}
		case "login_id_keys":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "LoginIDKeys")
				return
			}
			if cap(z.LoginIDKeys) >= int(zb0003) {
				z.LoginIDKeys = (z.LoginIDKeys)[:zb0003]
			} else {
				z.LoginIDKeys = make([]LoginIDKeyConfiguration, zb0003)
			}
			for za0001 := range z.LoginIDKeys {
				err = z.LoginIDKeys[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LoginIDKeys", za0001)
					return
				}
			}
		case "allowed_realms":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AllowedRealms")
				return
			}
			if cap(z.AllowedRealms) >= int(zb0004) {
				z.AllowedRealms = (z.AllowedRealms)[:zb0004]
			} else {
				z.AllowedRealms = make([]string, zb0004)
			}
			for za0002 := range z.AllowedRealms {
				z.AllowedRealms[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "AllowedRealms", za0002)
					return
				}
			}
		case "on_user_duplicate_allow_create":
			z.OnUserDuplicateAllowCreate, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "OnUserDuplicateAllowCreate")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *AuthConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "authentication_session"
	err = en.Append(0x85, 0xb6, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	if z.AuthenticationSession == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 1
		// write "secret"
		err = en.Append(0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.AuthenticationSession.Secret)
		if err != nil {
			err = msgp.WrapError(err, "AuthenticationSession", "Secret")
			return
		}
	}
	// write "login_id_types"
	err = en.Append(0xae, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x5f, 0x69, 0x64, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	if z.LoginIDTypes == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.LoginIDTypes.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "LoginIDTypes")
			return
		}
	}
	// write "login_id_keys"
	err = en.Append(0xad, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x5f, 0x69, 0x64, 0x5f, 0x6b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.LoginIDKeys)))
	if err != nil {
		err = msgp.WrapError(err, "LoginIDKeys")
		return
	}
	for za0001 := range z.LoginIDKeys {
		err = z.LoginIDKeys[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "LoginIDKeys", za0001)
			return
		}
	}
	// write "allowed_realms"
	err = en.Append(0xae, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x5f, 0x72, 0x65, 0x61, 0x6c, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AllowedRealms)))
	if err != nil {
		err = msgp.WrapError(err, "AllowedRealms")
		return
	}
	for za0002 := range z.AllowedRealms {
		err = en.WriteString(z.AllowedRealms[za0002])
		if err != nil {
			err = msgp.WrapError(err, "AllowedRealms", za0002)
			return
		}
	}
	// write "on_user_duplicate_allow_create"
	err = en.Append(0xbe, 0x6f, 0x6e, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x64, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x5f, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.OnUserDuplicateAllowCreate)
	if err != nil {
		err = msgp.WrapError(err, "OnUserDuplicateAllowCreate")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AuthConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "authentication_session"
	o = append(o, 0x85, 0xb6, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e)
	if z.AuthenticationSession == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "secret"
		o = append(o, 0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
		o = msgp.AppendString(o, z.AuthenticationSession.Secret)
	}
	// string "login_id_types"
	o = append(o, 0xae, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x5f, 0x69, 0x64, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x73)
	if z.LoginIDTypes == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.LoginIDTypes.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "LoginIDTypes")
			return
		}
	}
	// string "login_id_keys"
	o = append(o, 0xad, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x5f, 0x69, 0x64, 0x5f, 0x6b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.LoginIDKeys)))
	for za0001 := range z.LoginIDKeys {
		o, err = z.LoginIDKeys[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "LoginIDKeys", za0001)
			return
		}
	}
	// string "allowed_realms"
	o = append(o, 0xae, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x5f, 0x72, 0x65, 0x61, 0x6c, 0x6d, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AllowedRealms)))
	for za0002 := range z.AllowedRealms {
		o = msgp.AppendString(o, z.AllowedRealms[za0002])
	}
	// string "on_user_duplicate_allow_create"
	o = append(o, 0xbe, 0x6f, 0x6e, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x64, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x5f, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65)
	o = msgp.AppendBool(o, z.OnUserDuplicateAllowCreate)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AuthConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "authentication_session":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AuthenticationSession = nil
			} else {
				if z.AuthenticationSession == nil {
					z.AuthenticationSession = new(AuthenticationSessionConfiguration)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuthenticationSession")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "AuthenticationSession")
						return
					}
					switch msgp.UnsafeString(field) {
					case "secret":
						z.AuthenticationSession.Secret, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "AuthenticationSession", "Secret")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "AuthenticationSession")
							return
						}
					}
				}
			}
		case "login_id_types":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LoginIDTypes = nil
			} else {
				if z.LoginIDTypes == nil {
					z.LoginIDTypes = new(LoginIDTypesConfiguration)
				}
				bts, err = z.LoginIDTypes.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LoginIDTypes")
					return
				}
			}
		case "login_id_keys":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LoginIDKeys")
				return
			}
			if cap(z.LoginIDKeys) >= int(zb0003) {
				z.LoginIDKeys = (z.LoginIDKeys)[:zb0003]
			} else {
				z.LoginIDKeys = make([]LoginIDKeyConfiguration, zb0003)
			}
			for za0001 := range z.LoginIDKeys {
				bts, err = z.LoginIDKeys[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LoginIDKeys", za0001)
					return
				}
			}
		case "allowed_realms":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllowedRealms")
				return
			}
			if cap(z.AllowedRealms) >= int(zb0004) {
				z.AllowedRealms = (z.AllowedRealms)[:zb0004]
			} else {
				z.AllowedRealms = make([]string, zb0004)
			}
			for za0002 := range z.AllowedRealms {
				z.AllowedRealms[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AllowedRealms", za0002)
					return
				}
			}
		case "on_user_duplicate_allow_create":
			z.OnUserDuplicateAllowCreate, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OnUserDuplicateAllowCreate")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AuthConfiguration) Msgsize() (s int) {
	s = 1 + 23
	if z.AuthenticationSession == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 7 + msgp.StringPrefixSize + len(z.AuthenticationSession.Secret)
	}
	s += 15
	if z.LoginIDTypes == nil {
		s += msgp.NilSize
	} else {
		s += z.LoginIDTypes.Msgsize()
	}
	s += 14 + msgp.ArrayHeaderSize
	for za0001 := range z.LoginIDKeys {
		s += z.LoginIDKeys[za0001].Msgsize()
	}
	s += 15 + msgp.ArrayHeaderSize
	for za0002 := range z.AllowedRealms {
		s += msgp.StringPrefixSize + len(z.AllowedRealms[za0002])
	}
	s += 31 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *AuthenticationSessionConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "secret":
			z.Secret, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Secret")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z AuthenticationSessionConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "secret"
	err = en.Append(0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Secret)
	if err != nil {
		err = msgp.WrapError(err, "Secret")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AuthenticationSessionConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "secret"
	o = append(o, 0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	o = msgp.AppendString(o, z.Secret)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AuthenticationSessionConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "secret":
			z.Secret, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Secret")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AuthenticationSessionConfiguration) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Secret)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CORSConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "origin":
			z.Origin, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Origin")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z CORSConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "origin"
	err = en.Append(0x81, 0xa6, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Origin)
	if err != nil {
		err = msgp.WrapError(err, "Origin")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CORSConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "origin"
	o = append(o, 0x81, 0xa6, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e)
	o = msgp.AppendString(o, z.Origin)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CORSConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "origin":
			z.Origin, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Origin")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CORSConfiguration) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Origin)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DatabaseConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "database_url":
			z.DatabaseURL, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DatabaseURL")
				return
			}
		case "database_schema":
			z.DatabaseSchema, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DatabaseSchema")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DatabaseConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "database_url"
	err = en.Append(0x82, 0xac, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x75, 0x72, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.DatabaseURL)
	if err != nil {
		err = msgp.WrapError(err, "DatabaseURL")
		return
	}
	// write "database_schema"
	err = en.Append(0xaf, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61)
	if err != nil {
		return
	}
	err = en.WriteString(z.DatabaseSchema)
	if err != nil {
		err = msgp.WrapError(err, "DatabaseSchema")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DatabaseConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "database_url"
	o = append(o, 0x82, 0xac, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.DatabaseURL)
	// string "database_schema"
	o = append(o, 0xaf, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61)
	o = msgp.AppendString(o, z.DatabaseSchema)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DatabaseConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "database_url":
			z.DatabaseURL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DatabaseURL")
				return
			}
		case "database_schema":
			z.DatabaseSchema, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DatabaseSchema")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DatabaseConfiguration) Msgsize() (s int) {
	s = 1 + 13 + msgp.StringPrefixSize + len(z.DatabaseURL) + 16 + msgp.StringPrefixSize + len(z.DatabaseSchema)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DeploymentRoute) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "version":
			z.Version, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "path":
			z.Path, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "type":
			z.Type, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "type_config":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "TypeConfig")
				return
			}
			if z.TypeConfig == nil {
				z.TypeConfig = make(map[string]interface{}, zb0002)
			} else if len(z.TypeConfig) > 0 {
				for key := range z.TypeConfig {
					delete(z.TypeConfig, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 interface{}
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "TypeConfig")
					return
				}
				za0002, err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "TypeConfig", za0001)
					return
				}
				z.TypeConfig[za0001] = za0002
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DeploymentRoute) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "version"
	err = en.Append(0x84, 0xa7, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Version)
	if err != nil {
		err = msgp.WrapError(err, "Version")
		return
	}
	// write "path"
	err = en.Append(0xa4, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.Path)
	if err != nil {
		err = msgp.WrapError(err, "Path")
		return
	}
	// write "type"
	err = en.Append(0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "type_config"
	err = en.Append(0xab, 0x74, 0x79, 0x70, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.TypeConfig)))
	if err != nil {
		err = msgp.WrapError(err, "TypeConfig")
		return
	}
	for za0001, za0002 := range z.TypeConfig {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "TypeConfig")
			return
		}
		err = en.WriteIntf(za0002)
		if err != nil {
			err = msgp.WrapError(err, "TypeConfig", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DeploymentRoute) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "version"
	o = append(o, 0x84, 0xa7, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Version)
	// string "path"
	o = append(o, 0xa4, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.Path)
	// string "type"
	o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Type)
	// string "type_config"
	o = append(o, 0xab, 0x74, 0x79, 0x70, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67)
	o = msgp.AppendMapHeader(o, uint32(len(z.TypeConfig)))
	for za0001, za0002 := range z.TypeConfig {
		o = msgp.AppendString(o, za0001)
		o, err = msgp.AppendIntf(o, za0002)
		if err != nil {
			err = msgp.WrapError(err, "TypeConfig", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DeploymentRoute) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "version":
			z.Version, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "path":
			z.Path, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "type":
			z.Type, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "type_config":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TypeConfig")
				return
			}
			if z.TypeConfig == nil {
				z.TypeConfig = make(map[string]interface{}, zb0002)
			} else if len(z.TypeConfig) > 0 {
				for key := range z.TypeConfig {
					delete(z.TypeConfig, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 interface{}
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TypeConfig")
					return
				}
				za0002, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TypeConfig", za0001)
					return
				}
				z.TypeConfig[za0001] = za0002
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DeploymentRoute) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Version) + 5 + msgp.StringPrefixSize + len(z.Path) + 5 + msgp.StringPrefixSize + len(z.Type) + 12 + msgp.MapHeaderSize
	if z.TypeConfig != nil {
		for za0001, za0002 := range z.TypeConfig {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.GuessSize(za0002)
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ForgotPasswordConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "secure_match":
			z.SecureMatch, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "SecureMatch")
				return
			}
		case "sender":
			z.Sender, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		case "subject":
			z.Subject, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Subject")
				return
			}
		case "reply_to":
			z.ReplyTo, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ReplyTo")
				return
			}
		case "reset_url_lifetime":
			z.ResetURLLifetime, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ResetURLLifetime")
				return
			}
		case "success_redirect":
			z.SuccessRedirect, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SuccessRedirect")
				return
			}
		case "error_redirect":
			z.ErrorRedirect, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ErrorRedirect")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ForgotPasswordConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "secure_match"
	err = en.Append(0x87, 0xac, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68)
	if err != nil {
		return
	}
	err = en.WriteBool(z.SecureMatch)
	if err != nil {
		err = msgp.WrapError(err, "SecureMatch")
		return
	}
	// write "sender"
	err = en.Append(0xa6, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sender)
	if err != nil {
		err = msgp.WrapError(err, "Sender")
		return
	}
	// write "subject"
	err = en.Append(0xa7, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Subject)
	if err != nil {
		err = msgp.WrapError(err, "Subject")
		return
	}
	// write "reply_to"
	err = en.Append(0xa8, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x5f, 0x74, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteString(z.ReplyTo)
	if err != nil {
		err = msgp.WrapError(err, "ReplyTo")
		return
	}
	// write "reset_url_lifetime"
	err = en.Append(0xb2, 0x72, 0x65, 0x73, 0x65, 0x74, 0x5f, 0x75, 0x72, 0x6c, 0x5f, 0x6c, 0x69, 0x66, 0x65, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ResetURLLifetime)
	if err != nil {
		err = msgp.WrapError(err, "ResetURLLifetime")
		return
	}
	// write "success_redirect"
	err = en.Append(0xb0, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x72, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.SuccessRedirect)
	if err != nil {
		err = msgp.WrapError(err, "SuccessRedirect")
		return
	}
	// write "error_redirect"
	err = en.Append(0xae, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x72, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.ErrorRedirect)
	if err != nil {
		err = msgp.WrapError(err, "ErrorRedirect")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ForgotPasswordConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "secure_match"
	o = append(o, 0x87, 0xac, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68)
	o = msgp.AppendBool(o, z.SecureMatch)
	// string "sender"
	o = append(o, 0xa6, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72)
	o = msgp.AppendString(o, z.Sender)
	// string "subject"
	o = append(o, 0xa7, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Subject)
	// string "reply_to"
	o = append(o, 0xa8, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x5f, 0x74, 0x6f)
	o = msgp.AppendString(o, z.ReplyTo)
	// string "reset_url_lifetime"
	o = append(o, 0xb2, 0x72, 0x65, 0x73, 0x65, 0x74, 0x5f, 0x75, 0x72, 0x6c, 0x5f, 0x6c, 0x69, 0x66, 0x65, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt(o, z.ResetURLLifetime)
	// string "success_redirect"
	o = append(o, 0xb0, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x72, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.SuccessRedirect)
	// string "error_redirect"
	o = append(o, 0xae, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x72, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.ErrorRedirect)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ForgotPasswordConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "secure_match":
			z.SecureMatch, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SecureMatch")
				return
			}
		case "sender":
			z.Sender, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		case "subject":
			z.Subject, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Subject")
				return
			}
		case "reply_to":
			z.ReplyTo, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplyTo")
				return
			}
		case "reset_url_lifetime":
			z.ResetURLLifetime, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResetURLLifetime")
				return
			}
		case "success_redirect":
			z.SuccessRedirect, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SuccessRedirect")
				return
			}
		case "error_redirect":
			z.ErrorRedirect, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ErrorRedirect")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ForgotPasswordConfiguration) Msgsize() (s int) {
	s = 1 + 13 + msgp.BoolSize + 7 + msgp.StringPrefixSize + len(z.Sender) + 8 + msgp.StringPrefixSize + len(z.Subject) + 9 + msgp.StringPrefixSize + len(z.ReplyTo) + 19 + msgp.IntSize + 17 + msgp.StringPrefixSize + len(z.SuccessRedirect) + 15 + msgp.StringPrefixSize + len(z.ErrorRedirect)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Hook) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "event":
			z.Event, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Event")
				return
			}
		case "url":
			z.URL, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "URL")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Hook) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "event"
	err = en.Append(0x82, 0xa5, 0x65, 0x76, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Event)
	if err != nil {
		err = msgp.WrapError(err, "Event")
		return
	}
	// write "url"
	err = en.Append(0xa3, 0x75, 0x72, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.URL)
	if err != nil {
		err = msgp.WrapError(err, "URL")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Hook) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "event"
	o = append(o, 0x82, 0xa5, 0x65, 0x76, 0x65, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Event)
	// string "url"
	o = append(o, 0xa3, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.URL)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Hook) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "event":
			z.Event, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Event")
				return
			}
		case "url":
			z.URL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "URL")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Hook) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Event) + 4 + msgp.StringPrefixSize + len(z.URL)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HookAppConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "secret":
			z.Secret, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Secret")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HookAppConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "secret"
	err = en.Append(0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Secret)
	if err != nil {
		err = msgp.WrapError(err, "Secret")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HookAppConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "secret"
	o = append(o, 0x81, 0xa6, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	o = msgp.AppendString(o, z.Secret)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HookAppConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "secret":
			z.Secret, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Secret")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HookAppConfiguration) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Secret)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HookTenantConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "sync_hook_timeout_second":
			z.SyncHookTimeout, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SyncHookTimeout")
				return
			}
		case "sync_hook_total_timeout_second":
			z.SyncHookTotalTimeout, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SyncHookTotalTimeout")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HookTenantConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "sync_hook_timeout_second"
	err = en.Append(0x82, 0xb8, 0x73, 0x79, 0x6e, 0x63, 0x5f, 0x68, 0x6f, 0x6f, 0x6b, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SyncHookTimeout)
	if err != nil {
		err = msgp.WrapError(err, "SyncHookTimeout")
		return
	}
	// write "sync_hook_total_timeout_second"
	err = en.Append(0xbe, 0x73, 0x79, 0x6e, 0x63, 0x5f, 0x68, 0x6f, 0x6f, 0x6b, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SyncHookTotalTimeout)
	if err != nil {
		err = msgp.WrapError(err, "SyncHookTotalTimeout")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HookTenantConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "sync_hook_timeout_second"
	o = append(o, 0x82, 0xb8, 0x73, 0x79, 0x6e, 0x63, 0x5f, 0x68, 0x6f, 0x6f, 0x6b, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64)
	o = msgp.AppendInt(o, z.SyncHookTimeout)
	// string "sync_hook_total_timeout_second"
	o = append(o, 0xbe, 0x73, 0x79, 0x6e, 0x63, 0x5f, 0x68, 0x6f, 0x6f, 0x6b, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64)
	o = msgp.AppendInt(o, z.SyncHookTotalTimeout)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HookTenantConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "sync_hook_timeout_second":
			z.SyncHookTimeout, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SyncHookTimeout")
				return
			}
		case "sync_hook_total_timeout_second":
			z.SyncHookTotalTimeout, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SyncHookTotalTimeout")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HookTenantConfiguration) Msgsize() (s int) {
	s = 1 + 25 + msgp.IntSize + 31 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LoginIDKeyConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "key":
			z.Key, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		case "type":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = LoginIDKeyType(zb0002)
			}
		case "maximum":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
				z.Maximum = nil
			} else {
				if z.Maximum == nil {
					z.Maximum = new(int)
				}
				*z.Maximum, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *LoginIDKeyConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "key"
	err = en.Append(0x83, 0xa3, 0x6b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	// write "type"
	err = en.Append(0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Type))
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "maximum"
	err = en.Append(0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
	if err != nil {
		return
	}
	if z.Maximum == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.Maximum)
		if err != nil {
			err = msgp.WrapError(err, "Maximum")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *LoginIDKeyConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "key"
	o = append(o, 0x83, 0xa3, 0x6b, 0x65, 0x79)
	o = msgp.AppendString(o, z.Key)
	// string "type"
	o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "maximum"
	o = append(o, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
	if z.Maximum == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.Maximum)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LoginIDKeyConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "key":
			z.Key, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = LoginIDKeyType(zb0002)
			}
		case "maximum":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Maximum = nil
			} else {
				if z.Maximum == nil {
					z.Maximum = new(int)
				}
				*z.Maximum, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *LoginIDKeyConfiguration) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.Key) + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 8
	if z.Maximum == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LoginIDKeyType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = LoginIDKeyType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z LoginIDKeyType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z LoginIDKeyType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LoginIDKeyType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = LoginIDKeyType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z LoginIDKeyType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LoginIDTypeEmailConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "case_sensitive":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "CaseSensitive")
					return
				}
				z.CaseSensitive = nil
			} else {
				if z.CaseSensitive == nil {
					z.CaseSensitive = new(bool)
				}
				*z.CaseSensitive, err = dc.ReadBool()
				if err != nil {
					err = msgp.WrapError(err, "CaseSensitive")
					return
				}
			}
		case "block_plus_sign":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BlockPlusSign")
					return
				}
				z.BlockPlusSign = nil
			} else {
				if z.BlockPlusSign == nil {
					z.BlockPlusSign = new(bool)
				}
				*z.BlockPlusSign, err = dc.ReadBool()
				if err != nil {
					err = msgp.WrapError(err, "BlockPlusSign")
					return
				}
			}
		case "ignore_dot_sign":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "IgnoreDotSign")
					return
				}
				z.IgnoreDotSign = nil
			} else {
				if z.IgnoreDotSign == nil {
					z.IgnoreDotSign = new(bool)
				}
				*z.IgnoreDotSign, err = dc.ReadBool()
				if err != nil {
					err = msgp.WrapError(err, "IgnoreDotSign")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *LoginIDTypeEmailConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "case_sensitive"
	err = en.Append(0x83, 0xae, 0x63, 0x61, 0x73, 0x65, 0x5f, 0x73, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65)
	if err != nil {
		return
	}
	if z.CaseSensitive == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBool(*z.CaseSensitive)
		if err != nil {
			err = msgp.WrapError(err, "CaseSensitive")
			return
		}
	}
	// write "block_plus_sign"
	err = en.Append(0xaf, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x70, 0x6c, 0x75, 0x73, 0x5f, 0x73, 0x69, 0x67, 0x6e)
	if err != nil {
		return
	}
	if z.BlockPlusSign == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBool(*z.BlockPlusSign)
		if err != nil {
			err = msgp.WrapError(err, "BlockPlusSign")
			return
		}
	}
	// write "ignore_dot_sign"
	err = en.Append(0xaf, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x64, 0x6f, 0x74, 0x5f, 0x73, 0x69, 0x67, 0x6e)
	if err != nil {
		return
	}
	if z.IgnoreDotSign == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBool(*z.IgnoreDotSign)
		if err != nil {
			err = msgp.WrapError(err, "IgnoreDotSign")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *LoginIDTypeEmailConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "case_sensitive"
	o = append(o, 0x83, 0xae, 0x63, 0x61, 0x73, 0x65, 0x5f, 0x73, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65)
	if z.CaseSensitive == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.CaseSensitive)
	}
	// string "block_plus_sign"
	o = append(o, 0xaf, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x70, 0x6c, 0x75, 0x73, 0x5f, 0x73, 0x69, 0x67, 0x6e)
	if z.BlockPlusSign == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.BlockPlusSign)
	}
	// string "ignore_dot_sign"
	o = append(o, 0xaf, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x64, 0x6f, 0x74, 0x5f, 0x73, 0x69, 0x67, 0x6e)
	if z.IgnoreDotSign == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.IgnoreDotSign)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LoginIDTypeEmailConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "case_sensitive":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.CaseSensitive = nil
			} else {
				if z.CaseSensitive == nil {
					z.CaseSensitive = new(bool)
				}
				*z.CaseSensitive, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CaseSensitive")
					return
				}
			}
		case "block_plus_sign":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BlockPlusSign = nil
			} else {
				if z.BlockPlusSign == nil {
					z.BlockPlusSign = new(bool)
				}
				*z.BlockPlusSign, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BlockPlusSign")
					return
				}
			}
		case "ignore_dot_sign":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.IgnoreDotSign = nil
			} else {
				if z.IgnoreDotSign == nil {
					z.IgnoreDotSign = new(bool)
				}
				*z.IgnoreDotSign, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "IgnoreDotSign")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *LoginIDTypeEmailConfiguration) Msgsize() (s int) {
	s = 1 + 15
	if z.CaseSensitive == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 16
	if z.BlockPlusSign == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 16
	if z.IgnoreDotSign == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LoginIDTypeUsernameConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "block_reserved_usernames":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BlockReservedUsernames")
					return
				}
				z.BlockReservedUsernames = nil
			} else {
				if z.BlockReservedUsernames == nil {
					z.BlockReservedUsernames = new(bool)
				}
				*z.BlockReservedUsernames, err = dc.ReadBool()
				if err != nil {
					err = msgp.WrapError(err, "BlockReservedUsernames")
					return
				}
			}
		case "excluded_keywords":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ExcludedKeywords")
				return
			}
			if cap(z.ExcludedKeywords) >= int(zb0002) {
				z.ExcludedKeywords = (z.ExcludedKeywords)[:zb0002]
			} else {
				z.ExcludedKeywords = make([]string, zb0002)
			}
			for za0001 := range z.ExcludedKeywords {
				z.ExcludedKeywords[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ExcludedKeywords", za0001)
					return
				}
			}
		case "ascii_only":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "ASCIIOnly")
					return
				}
				z.ASCIIOnly = nil
			} else {
				if z.ASCIIOnly == nil {
					z.ASCIIOnly = new(bool)
				}
				*z.ASCIIOnly, err = dc.ReadBool()
				if err != nil {
					err = msgp.WrapError(err, "ASCIIOnly")
					return
				}
			}
		case "case_sensitive":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "CaseSensitive")
					return
				}
				z.CaseSensitive = nil
			} else {
				if z.CaseSensitive == nil {
					z.CaseSensitive = new(bool)
				}
				*z.CaseSensitive, err = dc.ReadBool()
				if err != nil {
					err = msgp.WrapError(err, "CaseSensitive")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *LoginIDTypeUsernameConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "block_reserved_usernames"
	err = en.Append(0x84, 0xb8, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x73)
	if err != nil {
		return
	}
	if z.BlockReservedUsernames == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBool(*z.BlockReservedUsernames)
		if err != nil {
			err = msgp.WrapError(err, "BlockReservedUsernames")
			return
		}
	}
	// write "excluded_keywords"
	err = en.Append(0xb1, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x5f, 0x6b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ExcludedKeywords)))
	if err != nil {
		err = msgp.WrapError(err, "ExcludedKeywords")
		return
	}
	for za0001 := range z.ExcludedKeywords {
		err = en.WriteString(z.ExcludedKeywords[za0001])
		if err != nil {
			err = msgp.WrapError(err, "ExcludedKeywords", za0001)
			return
		}
	}
	// write "ascii_only"
	err = en.Append(0xaa, 0x61, 0x73, 0x63, 0x69, 0x69, 0x5f, 0x6f, 0x6e, 0x6c, 0x79)
	if err != nil {
		return
	}
	if z.ASCIIOnly == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBool(*z.ASCIIOnly)
		if err != nil {
			err = msgp.WrapError(err, "ASCIIOnly")
			return
		}
	}
	// write "case_sensitive"
	err = en.Append(0xae, 0x63, 0x61, 0x73, 0x65, 0x5f, 0x73, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65)
	if err != nil {
		return
	}
	if z.CaseSensitive == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBool(*z.CaseSensitive)
		if err != nil {
			err = msgp.WrapError(err, "CaseSensitive")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *LoginIDTypeUsernameConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "block_reserved_usernames"
	o = append(o, 0x84, 0xb8, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x73)
	if z.BlockReservedUsernames == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.BlockReservedUsernames)
	}
	// string "excluded_keywords"
	o = append(o, 0xb1, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x5f, 0x6b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ExcludedKeywords)))
	for za0001 := range z.ExcludedKeywords {
		o = msgp.AppendString(o, z.ExcludedKeywords[za0001])
	}
	// string "ascii_only"
	o = append(o, 0xaa, 0x61, 0x73, 0x63, 0x69, 0x69, 0x5f, 0x6f, 0x6e, 0x6c, 0x79)
	if z.ASCIIOnly == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.ASCIIOnly)
	}
	// string "case_sensitive"
	o = append(o, 0xae, 0x63, 0x61, 0x73, 0x65, 0x5f, 0x73, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65)
	if z.CaseSensitive == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBool(o, *z.CaseSensitive)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LoginIDTypeUsernameConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "block_reserved_usernames":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BlockReservedUsernames = nil
			} else {
				if z.BlockReservedUsernames == nil {
					z.BlockReservedUsernames = new(bool)
				}
				*z.BlockReservedUsernames, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BlockReservedUsernames")
					return
				}
			}
		case "excluded_keywords":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExcludedKeywords")
				return
			}
			if cap(z.ExcludedKeywords) >= int(zb0002) {
				z.ExcludedKeywords = (z.ExcludedKeywords)[:zb0002]
			} else {
				z.ExcludedKeywords = make([]string, zb0002)
			}
			for za0001 := range z.ExcludedKeywords {
				z.ExcludedKeywords[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExcludedKeywords", za0001)
					return
				}
			}
		case "ascii_only":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ASCIIOnly = nil
			} else {
				if z.ASCIIOnly == nil {
					z.ASCIIOnly = new(bool)
				}
				*z.ASCIIOnly, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ASCIIOnly")
					return
				}
			}
		case "case_sensitive":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.CaseSensitive = nil
			} else {
				if z.CaseSensitive == nil {
					z.CaseSensitive = new(bool)
				}
				*z.CaseSensitive, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CaseSensitive")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *LoginIDTypeUsernameConfiguration) Msgsize() (s int) {
	s = 1 + 25
	if z.BlockReservedUsernames == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 18 + msgp.ArrayHeaderSize
	for za0001 := range z.ExcludedKeywords {
		s += msgp.StringPrefixSize + len(z.ExcludedKeywords[za0001])
	}
	s += 11
	if z.ASCIIOnly == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 15
	if z.CaseSensitive == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LoginIDTypesConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "email":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Email")
					return
				}
				z.Email = nil
			} else {
				if z.Email == nil {
					z.Email = new(LoginIDTypeEmailConfiguration)
				}
				err = z.Email.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Email")
					return
				}
			}
		case "username":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Username")
					return
				}
				z.Username = nil
			} else {
				if z.Username == nil {
					z.Username = new(LoginIDTypeUsernameConfiguration)
				}
				err = z.Username.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Username")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *LoginIDTypesConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "email"
	err = en.Append(0x82, 0xa5, 0x65, 0x6d, 0x61, 0x69, 0x6c)
	if err != nil {
		return
	}
	if z.Email == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Email.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Email")
			return
		}
	}
	// write "username"
	err = en.Append(0xa8, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	if z.Username == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Username.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Username")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *LoginIDTypesConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "email"
	o = append(o, 0x82, 0xa5, 0x65, 0x6d, 0x61, 0x69, 0x6c)
	if z.Email == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Email.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Email")
			return
		}
	}
	// string "username"
	o = append(o, 0xa8, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65)
	if z.Username == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Username.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Username")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LoginIDTypesConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "email":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Email = nil
			} else {
				if z.Email == nil {
					z.Email = new(LoginIDTypeEmailConfiguration)
				}
				bts, err = z.Email.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Email")
					return
				}
			}
		case "username":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Username = nil
			} else {
				if z.Username == nil {
					z.Username = new(LoginIDTypeUsernameConfiguration)
				}
				bts, err = z.Username.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Username")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *LoginIDTypesConfiguration) Msgsize() (s int) {
	s = 1 + 6
	if z.Email == nil {
		s += msgp.NilSize
	} else {
		s += z.Email.Msgsize()
	}
	s += 9
	if z.Username == nil {
		s += msgp.NilSize
	} else {
		s += z.Username.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MFABearerTokenConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "expire_in_days":
			z.ExpireInDays, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ExpireInDays")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MFABearerTokenConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "expire_in_days"
	err = en.Append(0x81, 0xae, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x5f, 0x69, 0x6e, 0x5f, 0x64, 0x61, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ExpireInDays)
	if err != nil {
		err = msgp.WrapError(err, "ExpireInDays")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MFABearerTokenConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "expire_in_days"
	o = append(o, 0x81, 0xae, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x5f, 0x69, 0x6e, 0x5f, 0x64, 0x61, 0x79, 0x73)
	o = msgp.AppendInt(o, z.ExpireInDays)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MFABearerTokenConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "expire_in_days":
			z.ExpireInDays, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExpireInDays")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MFABearerTokenConfiguration) Msgsize() (s int) {
	s = 1 + 15 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MFAConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "enabled":
			z.Enabled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Enabled")
				return
			}
		case "enforcement":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Enforcement")
					return
				}
				z.Enforcement = MFAEnforcement(zb0002)
			}
		case "maximum":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
				z.Maximum = nil
			} else {
				if z.Maximum == nil {
					z.Maximum = new(int)
				}
				*z.Maximum, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
			}
		case "totp":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TOTP")
					return
				}
				z.TOTP = nil
			} else {
				if z.TOTP == nil {
					z.TOTP = new(MFATOTPConfiguration)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "TOTP")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "TOTP")
						return
					}
					switch msgp.UnsafeString(field) {
					case "maximum":
						if dc.IsNil() {
							err = dc.ReadNil()
							if err != nil {
								err = msgp.WrapError(err, "TOTP", "Maximum")
								return
							}
							z.TOTP.Maximum = nil
						} else {
							if z.TOTP.Maximum == nil {
								z.TOTP.Maximum = new(int)
							}
							*z.TOTP.Maximum, err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "TOTP", "Maximum")
								return
							}
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "TOTP")
							return
						}
					}
				}
			}
		case "oob":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "OOB")
					return
				}
				z.OOB = nil
			} else {
				if z.OOB == nil {
					z.OOB = new(MFAOOBConfiguration)
				}
				err = z.OOB.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "OOB")
					return
				}
			}
		case "bearer_token":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BearerToken")
					return
				}
				z.BearerToken = nil
			} else {
				if z.BearerToken == nil {
					z.BearerToken = new(MFABearerTokenConfiguration)
				}
				var zb0004 uint32
				zb0004, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "BearerToken")
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "BearerToken")
						return
					}
					switch msgp.UnsafeString(field) {
					case "expire_in_days":
						z.BearerToken.ExpireInDays, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "BearerToken", "ExpireInDays")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "BearerToken")
							return
						}
					}
				}
			}
		case "recovery_code":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RecoveryCode")
					return
				}
				z.RecoveryCode = nil
			} else {
				if z.RecoveryCode == nil {
					z.RecoveryCode = new(MFARecoveryCodeConfiguration)
				}
				var zb0005 uint32
				zb0005, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "RecoveryCode")
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "RecoveryCode")
						return
					}
					switch msgp.UnsafeString(field) {
					case "count":
						z.RecoveryCode.Count, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "RecoveryCode", "Count")
							return
						}
					case "list_enabled":
						z.RecoveryCode.ListEnabled, err = dc.ReadBool()
						if err != nil {
							err = msgp.WrapError(err, "RecoveryCode", "ListEnabled")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "RecoveryCode")
							return
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MFAConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "enabled"
	err = en.Append(0x87, 0xa7, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Enabled)
	if err != nil {
		err = msgp.WrapError(err, "Enabled")
		return
	}
	// write "enforcement"
	err = en.Append(0xab, 0x65, 0x6e, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x6d, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Enforcement))
	if err != nil {
		err = msgp.WrapError(err, "Enforcement")
		return
	}
	// write "maximum"
	err = en.Append(0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
	if err != nil {
		return
	}
	if z.Maximum == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.Maximum)
		if err != nil {
			err = msgp.WrapError(err, "Maximum")
			return
		}
	}
	// write "totp"
	err = en.Append(0xa4, 0x74, 0x6f, 0x74, 0x70)
	if err != nil {
		return
	}
	if z.TOTP == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 1
		// write "maximum"
		err = en.Append(0x81, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
		if err != nil {
			return
		}
		if z.TOTP.Maximum == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.TOTP.Maximum)
			if err != nil {
				err = msgp.WrapError(err, "TOTP", "Maximum")
				return
			}
		}
	}
	// write "oob"
	err = en.Append(0xa3, 0x6f, 0x6f, 0x62)
	if err != nil {
		return
	}
	if z.OOB == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.OOB.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "OOB")
			return
		}
	}
	// write "bearer_token"
	err = en.Append(0xac, 0x62, 0x65, 0x61, 0x72, 0x65, 0x72, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	if err != nil {
		return
	}
	if z.BearerToken == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 1
		// write "expire_in_days"
		err = en.Append(0x81, 0xae, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x5f, 0x69, 0x6e, 0x5f, 0x64, 0x61, 0x79, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.BearerToken.ExpireInDays)
		if err != nil {
			err = msgp.WrapError(err, "BearerToken", "ExpireInDays")
			return
		}
	}
	// write "recovery_code"
	err = en.Append(0xad, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	if z.RecoveryCode == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "count"
		err = en.Append(0x82, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt(z.RecoveryCode.Count)
		if err != nil {
			err = msgp.WrapError(err, "RecoveryCode", "Count")
			return
		}
		// write "list_enabled"
		err = en.Append(0xac, 0x6c, 0x69, 0x73, 0x74, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteBool(z.RecoveryCode.ListEnabled)
		if err != nil {
			err = msgp.WrapError(err, "RecoveryCode", "ListEnabled")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MFAConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "enabled"
	o = append(o, 0x87, 0xa7, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Enabled)
	// string "enforcement"
	o = append(o, 0xab, 0x65, 0x6e, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x6d, 0x65, 0x6e, 0x74)
	o = msgp.AppendString(o, string(z.Enforcement))
	// string "maximum"
	o = append(o, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
	if z.Maximum == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.Maximum)
	}
	// string "totp"
	o = append(o, 0xa4, 0x74, 0x6f, 0x74, 0x70)
	if z.TOTP == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "maximum"
		o = append(o, 0x81, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
		if z.TOTP.Maximum == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.TOTP.Maximum)
		}
	}
	// string "oob"
	o = append(o, 0xa3, 0x6f, 0x6f, 0x62)
	if z.OOB == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.OOB.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "OOB")
			return
		}
	}
	// string "bearer_token"
	o = append(o, 0xac, 0x62, 0x65, 0x61, 0x72, 0x65, 0x72, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	if z.BearerToken == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "expire_in_days"
		o = append(o, 0x81, 0xae, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x5f, 0x69, 0x6e, 0x5f, 0x64, 0x61, 0x79, 0x73)
		o = msgp.AppendInt(o, z.BearerToken.ExpireInDays)
	}
	// string "recovery_code"
	o = append(o, 0xad, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65)
	if z.RecoveryCode == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "count"
		o = append(o, 0x82, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt(o, z.RecoveryCode.Count)
		// string "list_enabled"
		o = append(o, 0xac, 0x6c, 0x69, 0x73, 0x74, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
		o = msgp.AppendBool(o, z.RecoveryCode.ListEnabled)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MFAConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "enabled":
			z.Enabled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Enabled")
				return
			}
		case "enforcement":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Enforcement")
					return
				}
				z.Enforcement = MFAEnforcement(zb0002)
			}
		case "maximum":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Maximum = nil
			} else {
				if z.Maximum == nil {
					z.Maximum = new(int)
				}
				*z.Maximum, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
			}
		case "totp":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TOTP = nil
			} else {
				if z.TOTP == nil {
					z.TOTP = new(MFATOTPConfiguration)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TOTP")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "TOTP")
						return
					}
					switch msgp.UnsafeString(field) {
					case "maximum":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.TOTP.Maximum = nil
						} else {
							if z.TOTP.Maximum == nil {
								z.TOTP.Maximum = new(int)
							}
							*z.TOTP.Maximum, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "TOTP", "Maximum")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "TOTP")
							return
						}
					}
				}
			}
		case "oob":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.OOB = nil
			} else {
				if z.OOB == nil {
					z.OOB = new(MFAOOBConfiguration)
				}
				bts, err = z.OOB.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OOB")
					return
				}
			}
		case "bearer_token":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BearerToken = nil
			} else {
				if z.BearerToken == nil {
					z.BearerToken = new(MFABearerTokenConfiguration)
				}
				var zb0004 uint32
				zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BearerToken")
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "BearerToken")
						return
					}
					switch msgp.UnsafeString(field) {
					case "expire_in_days":
						z.BearerToken.ExpireInDays, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "BearerToken", "ExpireInDays")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "BearerToken")
							return
						}
					}
				}
			}
		case "recovery_code":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RecoveryCode = nil
			} else {
				if z.RecoveryCode == nil {
					z.RecoveryCode = new(MFARecoveryCodeConfiguration)
				}
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RecoveryCode")
					return
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "RecoveryCode")
						return
					}
					switch msgp.UnsafeString(field) {
					case "count":
						z.RecoveryCode.Count, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "RecoveryCode", "Count")
							return
						}
					case "list_enabled":
						z.RecoveryCode.ListEnabled, bts, err = msgp.ReadBoolBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "RecoveryCode", "ListEnabled")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "RecoveryCode")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MFAConfiguration) Msgsize() (s int) {
	s = 1 + 8 + msgp.BoolSize + 12 + msgp.StringPrefixSize + len(string(z.Enforcement)) + 8
	if z.Maximum == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 5
	if z.TOTP == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 8
		if z.TOTP.Maximum == nil {
			s += msgp.NilSize
		} else {
			s += msgp.IntSize
		}
	}
	s += 4
	if z.OOB == nil {
		s += msgp.NilSize
	} else {
		s += z.OOB.Msgsize()
	}
	s += 13
	if z.BearerToken == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 15 + msgp.IntSize
	}
	s += 14
	if z.RecoveryCode == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 6 + msgp.IntSize + 13 + msgp.BoolSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MFAEnforcement) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MFAEnforcement(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MFAEnforcement) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MFAEnforcement) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MFAEnforcement) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MFAEnforcement(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MFAEnforcement) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MFAOOBConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "sms":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SMS")
					return
				}
				z.SMS = nil
			} else {
				if z.SMS == nil {
					z.SMS = new(MFAOOBSMSConfiguration)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "SMS")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "SMS")
						return
					}
					switch msgp.UnsafeString(field) {
					case "maximum":
						if dc.IsNil() {
							err = dc.ReadNil()
							if err != nil {
								err = msgp.WrapError(err, "SMS", "Maximum")
								return
							}
							z.SMS.Maximum = nil
						} else {
							if z.SMS.Maximum == nil {
								z.SMS.Maximum = new(int)
							}
							*z.SMS.Maximum, err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "SMS", "Maximum")
								return
							}
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "SMS")
							return
						}
					}
				}
			}
		case "email":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Email")
					return
				}
				z.Email = nil
			} else {
				if z.Email == nil {
					z.Email = new(MFAOOBEmailConfiguration)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Email")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Email")
						return
					}
					switch msgp.UnsafeString(field) {
					case "maximum":
						if dc.IsNil() {
							err = dc.ReadNil()
							if err != nil {
								err = msgp.WrapError(err, "Email", "Maximum")
								return
							}
							z.Email.Maximum = nil
						} else {
							if z.Email.Maximum == nil {
								z.Email.Maximum = new(int)
							}
							*z.Email.Maximum, err = dc.ReadInt()
							if err != nil {
								err = msgp.WrapError(err, "Email", "Maximum")
								return
							}
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Email")
							return
						}
					}
				}
			}
		case "sender":
			z.Sender, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		case "subject":
			z.Subject, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Subject")
				return
			}
		case "reply_to":
			z.ReplyTo, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ReplyTo")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MFAOOBConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "sms"
	err = en.Append(0x85, 0xa3, 0x73, 0x6d, 0x73)
	if err != nil {
		return
	}
	if z.SMS == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 1
		// write "maximum"
		err = en.Append(0x81, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
		if err != nil {
			return
		}
		if z.SMS.Maximum == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.SMS.Maximum)
			if err != nil {
				err = msgp.WrapError(err, "SMS", "Maximum")
				return
			}
		}
	}
	// write "email"
	err = en.Append(0xa5, 0x65, 0x6d, 0x61, 0x69, 0x6c)
	if err != nil {
		return
	}
	if z.Email == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 1
		// write "maximum"
		err = en.Append(0x81, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
		if err != nil {
			return
		}
		if z.Email.Maximum == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.Email.Maximum)
			if err != nil {
				err = msgp.WrapError(err, "Email", "Maximum")
				return
			}
		}
	}
	// write "sender"
	err = en.Append(0xa6, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sender)
	if err != nil {
		err = msgp.WrapError(err, "Sender")
		return
	}
	// write "subject"
	err = en.Append(0xa7, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Subject)
	if err != nil {
		err = msgp.WrapError(err, "Subject")
		return
	}
	// write "reply_to"
	err = en.Append(0xa8, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x5f, 0x74, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteString(z.ReplyTo)
	if err != nil {
		err = msgp.WrapError(err, "ReplyTo")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MFAOOBConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "sms"
	o = append(o, 0x85, 0xa3, 0x73, 0x6d, 0x73)
	if z.SMS == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "maximum"
		o = append(o, 0x81, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
		if z.SMS.Maximum == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.SMS.Maximum)
		}
	}
	// string "email"
	o = append(o, 0xa5, 0x65, 0x6d, 0x61, 0x69, 0x6c)
	if z.Email == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 1
		// string "maximum"
		o = append(o, 0x81, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
		if z.Email.Maximum == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.Email.Maximum)
		}
	}
	// string "sender"
	o = append(o, 0xa6, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72)
	o = msgp.AppendString(o, z.Sender)
	// string "subject"
	o = append(o, 0xa7, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Subject)
	// string "reply_to"
	o = append(o, 0xa8, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x5f, 0x74, 0x6f)
	o = msgp.AppendString(o, z.ReplyTo)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MFAOOBConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "sms":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SMS = nil
			} else {
				if z.SMS == nil {
					z.SMS = new(MFAOOBSMSConfiguration)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SMS")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "SMS")
						return
					}
					switch msgp.UnsafeString(field) {
					case "maximum":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.SMS.Maximum = nil
						} else {
							if z.SMS.Maximum == nil {
								z.SMS.Maximum = new(int)
							}
							*z.SMS.Maximum, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "SMS", "Maximum")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "SMS")
							return
						}
					}
				}
			}
		case "email":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Email = nil
			} else {
				if z.Email == nil {
					z.Email = new(MFAOOBEmailConfiguration)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Email")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Email")
						return
					}
					switch msgp.UnsafeString(field) {
					case "maximum":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.Email.Maximum = nil
						} else {
							if z.Email.Maximum == nil {
								z.Email.Maximum = new(int)
							}
							*z.Email.Maximum, bts, err = msgp.ReadIntBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Email", "Maximum")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Email")
							return
						}
					}
				}
			}
		case "sender":
			z.Sender, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		case "subject":
			z.Subject, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Subject")
				return
			}
		case "reply_to":
			z.ReplyTo, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplyTo")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MFAOOBConfiguration) Msgsize() (s int) {
	s = 1 + 4
	if z.SMS == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 8
		if z.SMS.Maximum == nil {
			s += msgp.NilSize
		} else {
			s += msgp.IntSize
		}
	}
	s += 6
	if z.Email == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 8
		if z.Email.Maximum == nil {
			s += msgp.NilSize
		} else {
			s += msgp.IntSize
		}
	}
	s += 7 + msgp.StringPrefixSize + len(z.Sender) + 8 + msgp.StringPrefixSize + len(z.Subject) + 9 + msgp.StringPrefixSize + len(z.ReplyTo)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MFAOOBEmailConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "maximum":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
				z.Maximum = nil
			} else {
				if z.Maximum == nil {
					z.Maximum = new(int)
				}
				*z.Maximum, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MFAOOBEmailConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "maximum"
	err = en.Append(0x81, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
	if err != nil {
		return
	}
	if z.Maximum == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.Maximum)
		if err != nil {
			err = msgp.WrapError(err, "Maximum")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MFAOOBEmailConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "maximum"
	o = append(o, 0x81, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
	if z.Maximum == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.Maximum)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MFAOOBEmailConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "maximum":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Maximum = nil
			} else {
				if z.Maximum == nil {
					z.Maximum = new(int)
				}
				*z.Maximum, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MFAOOBEmailConfiguration) Msgsize() (s int) {
	s = 1 + 8
	if z.Maximum == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MFAOOBSMSConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "maximum":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
				z.Maximum = nil
			} else {
				if z.Maximum == nil {
					z.Maximum = new(int)
				}
				*z.Maximum, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MFAOOBSMSConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "maximum"
	err = en.Append(0x81, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
	if err != nil {
		return
	}
	if z.Maximum == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.Maximum)
		if err != nil {
			err = msgp.WrapError(err, "Maximum")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MFAOOBSMSConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "maximum"
	o = append(o, 0x81, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
	if z.Maximum == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.Maximum)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MFAOOBSMSConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "maximum":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Maximum = nil
			} else {
				if z.Maximum == nil {
					z.Maximum = new(int)
				}
				*z.Maximum, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MFAOOBSMSConfiguration) Msgsize() (s int) {
	s = 1 + 8
	if z.Maximum == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MFARecoveryCodeConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "count":
			z.Count, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "list_enabled":
			z.ListEnabled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ListEnabled")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MFARecoveryCodeConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "count"
	err = en.Append(0x82, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Count)
	if err != nil {
		err = msgp.WrapError(err, "Count")
		return
	}
	// write "list_enabled"
	err = en.Append(0xac, 0x6c, 0x69, 0x73, 0x74, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.ListEnabled)
	if err != nil {
		err = msgp.WrapError(err, "ListEnabled")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MFARecoveryCodeConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "count"
	o = append(o, 0x82, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.Count)
	// string "list_enabled"
	o = append(o, 0xac, 0x6c, 0x69, 0x73, 0x74, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.ListEnabled)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MFARecoveryCodeConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "count":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "list_enabled":
			z.ListEnabled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ListEnabled")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MFARecoveryCodeConfiguration) Msgsize() (s int) {
	s = 1 + 6 + msgp.IntSize + 13 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MFATOTPConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "maximum":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
				z.Maximum = nil
			} else {
				if z.Maximum == nil {
					z.Maximum = new(int)
				}
				*z.Maximum, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MFATOTPConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "maximum"
	err = en.Append(0x81, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
	if err != nil {
		return
	}
	if z.Maximum == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.Maximum)
		if err != nil {
			err = msgp.WrapError(err, "Maximum")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MFATOTPConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "maximum"
	o = append(o, 0x81, 0xa7, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
	if z.Maximum == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.Maximum)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MFATOTPConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "maximum":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Maximum = nil
			} else {
				if z.Maximum == nil {
					z.Maximum = new(int)
				}
				*z.Maximum, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Maximum")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MFATOTPConfiguration) Msgsize() (s int) {
	s = 1 + 8
	if z.Maximum == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *NexmoConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "api_key":
			z.APIKey, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "APIKey")
				return
			}
		case "api_secret":
			z.APISecret, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "APISecret")
				return
			}
		case "from":
			z.From, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "From")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z NexmoConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "api_key"
	err = en.Append(0x83, 0xa7, 0x61, 0x70, 0x69, 0x5f, 0x6b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.APIKey)
	if err != nil {
		err = msgp.WrapError(err, "APIKey")
		return
	}
	// write "api_secret"
	err = en.Append(0xaa, 0x61, 0x70, 0x69, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.APISecret)
	if err != nil {
		err = msgp.WrapError(err, "APISecret")
		return
	}
	// write "from"
	err = en.Append(0xa4, 0x66, 0x72, 0x6f, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.From)
	if err != nil {
		err = msgp.WrapError(err, "From")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z NexmoConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "api_key"
	o = append(o, 0x83, 0xa7, 0x61, 0x70, 0x69, 0x5f, 0x6b, 0x65, 0x79)
	o = msgp.AppendString(o, z.APIKey)
	// string "api_secret"
	o = append(o, 0xaa, 0x61, 0x70, 0x69, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	o = msgp.AppendString(o, z.APISecret)
	// string "from"
	o = append(o, 0xa4, 0x66, 0x72, 0x6f, 0x6d)
	o = msgp.AppendString(o, z.From)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *NexmoConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "api_key":
			z.APIKey, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "APIKey")
				return
			}
		case "api_secret":
			z.APISecret, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "APISecret")
				return
			}
		case "from":
			z.From, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "From")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z NexmoConfiguration) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.APIKey) + 11 + msgp.StringPrefixSize + len(z.APISecret) + 5 + msgp.StringPrefixSize + len(z.From)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OAuthConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "state_jwt_secret":
			z.StateJWTSecret, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "StateJWTSecret")
				return
			}
		case "allowed_callback_urls":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AllowedCallbackURLs")
				return
			}
			if cap(z.AllowedCallbackURLs) >= int(zb0002) {
				z.AllowedCallbackURLs = (z.AllowedCallbackURLs)[:zb0002]
			} else {
				z.AllowedCallbackURLs = make([]string, zb0002)
			}
			for za0001 := range z.AllowedCallbackURLs {
				z.AllowedCallbackURLs[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "AllowedCallbackURLs", za0001)
					return
				}
			}
		case "external_access_token_flow_enabled":
			z.ExternalAccessTokenFlowEnabled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ExternalAccessTokenFlowEnabled")
				return
			}
		case "on_user_duplicate_allow_merge":
			z.OnUserDuplicateAllowMerge, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "OnUserDuplicateAllowMerge")
				return
			}
		case "on_user_duplicate_allow_create":
			z.OnUserDuplicateAllowCreate, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "OnUserDuplicateAllowCreate")
				return
			}
		case "providers":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Providers")
				return
			}
			if cap(z.Providers) >= int(zb0003) {
				z.Providers = (z.Providers)[:zb0003]
			} else {
				z.Providers = make([]OAuthProviderConfiguration, zb0003)
			}
			for za0002 := range z.Providers {
				err = z.Providers[za0002].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Providers", za0002)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *OAuthConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "state_jwt_secret"
	err = en.Append(0x86, 0xb0, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x6a, 0x77, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.StateJWTSecret)
	if err != nil {
		err = msgp.WrapError(err, "StateJWTSecret")
		return
	}
	// write "allowed_callback_urls"
	err = en.Append(0xb5, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x5f, 0x63, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x5f, 0x75, 0x72, 0x6c, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AllowedCallbackURLs)))
	if err != nil {
		err = msgp.WrapError(err, "AllowedCallbackURLs")
		return
	}
	for za0001 := range z.AllowedCallbackURLs {
		err = en.WriteString(z.AllowedCallbackURLs[za0001])
		if err != nil {
			err = msgp.WrapError(err, "AllowedCallbackURLs", za0001)
			return
		}
	}
	// write "external_access_token_flow_enabled"
	err = en.Append(0xd9, 0x22, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.ExternalAccessTokenFlowEnabled)
	if err != nil {
		err = msgp.WrapError(err, "ExternalAccessTokenFlowEnabled")
		return
	}
	// write "on_user_duplicate_allow_merge"
	err = en.Append(0xbd, 0x6f, 0x6e, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x64, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x5f, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.OnUserDuplicateAllowMerge)
	if err != nil {
		err = msgp.WrapError(err, "OnUserDuplicateAllowMerge")
		return
	}
	// write "on_user_duplicate_allow_create"
	err = en.Append(0xbe, 0x6f, 0x6e, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x64, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x5f, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.OnUserDuplicateAllowCreate)
	if err != nil {
		err = msgp.WrapError(err, "OnUserDuplicateAllowCreate")
		return
	}
	// write "providers"
	err = en.Append(0xa9, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Providers)))
	if err != nil {
		err = msgp.WrapError(err, "Providers")
		return
	}
	for za0002 := range z.Providers {
		err = z.Providers[za0002].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Providers", za0002)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OAuthConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "state_jwt_secret"
	o = append(o, 0x86, 0xb0, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x6a, 0x77, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	o = msgp.AppendString(o, z.StateJWTSecret)
	// string "allowed_callback_urls"
	o = append(o, 0xb5, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x5f, 0x63, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x5f, 0x75, 0x72, 0x6c, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AllowedCallbackURLs)))
	for za0001 := range z.AllowedCallbackURLs {
		o = msgp.AppendString(o, z.AllowedCallbackURLs[za0001])
	}
	// string "external_access_token_flow_enabled"
	o = append(o, 0xd9, 0x22, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.ExternalAccessTokenFlowEnabled)
	// string "on_user_duplicate_allow_merge"
	o = append(o, 0xbd, 0x6f, 0x6e, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x64, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x5f, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65)
	o = msgp.AppendBool(o, z.OnUserDuplicateAllowMerge)
	// string "on_user_duplicate_allow_create"
	o = append(o, 0xbe, 0x6f, 0x6e, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x64, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x5f, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65)
	o = msgp.AppendBool(o, z.OnUserDuplicateAllowCreate)
	// string "providers"
	o = append(o, 0xa9, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Providers)))
	for za0002 := range z.Providers {
		o, err = z.Providers[za0002].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Providers", za0002)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OAuthConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "state_jwt_secret":
			z.StateJWTSecret, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StateJWTSecret")
				return
			}
		case "allowed_callback_urls":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllowedCallbackURLs")
				return
			}
			if cap(z.AllowedCallbackURLs) >= int(zb0002) {
				z.AllowedCallbackURLs = (z.AllowedCallbackURLs)[:zb0002]
			} else {
				z.AllowedCallbackURLs = make([]string, zb0002)
			}
			for za0001 := range z.AllowedCallbackURLs {
				z.AllowedCallbackURLs[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AllowedCallbackURLs", za0001)
					return
				}
			}
		case "external_access_token_flow_enabled":
			z.ExternalAccessTokenFlowEnabled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExternalAccessTokenFlowEnabled")
				return
			}
		case "on_user_duplicate_allow_merge":
			z.OnUserDuplicateAllowMerge, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OnUserDuplicateAllowMerge")
				return
			}
		case "on_user_duplicate_allow_create":
			z.OnUserDuplicateAllowCreate, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OnUserDuplicateAllowCreate")
				return
			}
		case "providers":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Providers")
				return
			}
			if cap(z.Providers) >= int(zb0003) {
				z.Providers = (z.Providers)[:zb0003]
			} else {
				z.Providers = make([]OAuthProviderConfiguration, zb0003)
			}
			for za0002 := range z.Providers {
				bts, err = z.Providers[za0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Providers", za0002)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OAuthConfiguration) Msgsize() (s int) {
	s = 1 + 17 + msgp.StringPrefixSize + len(z.StateJWTSecret) + 22 + msgp.ArrayHeaderSize
	for za0001 := range z.AllowedCallbackURLs {
		s += msgp.StringPrefixSize + len(z.AllowedCallbackURLs[za0001])
	}
	s += 36 + msgp.BoolSize + 30 + msgp.BoolSize + 31 + msgp.BoolSize + 10 + msgp.ArrayHeaderSize
	for za0002 := range z.Providers {
		s += z.Providers[za0002].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OAuthProviderConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "type":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = OAuthProviderType(zb0002)
			}
		case "client_id":
			z.ClientID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientID")
				return
			}
		case "client_secret":
			z.ClientSecret, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientSecret")
				return
			}
		case "scope":
			z.Scope, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Scope")
				return
			}
		case "tenant":
			z.Tenant, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Tenant")
				return
			}
		case "key_id":
			z.KeyID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "KeyID")
				return
			}
		case "team_id":
			z.TeamID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "TeamID")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *OAuthProviderConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "id"
	err = en.Append(0x88, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "type"
	err = en.Append(0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Type))
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "client_id"
	err = en.Append(0xa9, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientID)
	if err != nil {
		err = msgp.WrapError(err, "ClientID")
		return
	}
	// write "client_secret"
	err = en.Append(0xad, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientSecret)
	if err != nil {
		err = msgp.WrapError(err, "ClientSecret")
		return
	}
	// write "scope"
	err = en.Append(0xa5, 0x73, 0x63, 0x6f, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Scope)
	if err != nil {
		err = msgp.WrapError(err, "Scope")
		return
	}
	// write "tenant"
	err = en.Append(0xa6, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Tenant)
	if err != nil {
		err = msgp.WrapError(err, "Tenant")
		return
	}
	// write "key_id"
	err = en.Append(0xa6, 0x6b, 0x65, 0x79, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.KeyID)
	if err != nil {
		err = msgp.WrapError(err, "KeyID")
		return
	}
	// write "team_id"
	err = en.Append(0xa7, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.TeamID)
	if err != nil {
		err = msgp.WrapError(err, "TeamID")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OAuthProviderConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "id"
	o = append(o, 0x88, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "type"
	o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "client_id"
	o = append(o, 0xa9, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ClientID)
	// string "client_secret"
	o = append(o, 0xad, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74)
	o = msgp.AppendString(o, z.ClientSecret)
	// string "scope"
	o = append(o, 0xa5, 0x73, 0x63, 0x6f, 0x70, 0x65)
	o = msgp.AppendString(o, z.Scope)
	// string "tenant"
	o = append(o, 0xa6, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Tenant)
	// string "key_id"
	o = append(o, 0xa6, 0x6b, 0x65, 0x79, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.KeyID)
	// string "team_id"
	o = append(o, 0xa7, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.TeamID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OAuthProviderConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = OAuthProviderType(zb0002)
			}
		case "client_id":
			z.ClientID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientID")
				return
			}
		case "client_secret":
			z.ClientSecret, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientSecret")
				return
			}
		case "scope":
			z.Scope, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Scope")
				return
			}
		case "tenant":
			z.Tenant, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tenant")
				return
			}
		case "key_id":
			z.KeyID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "KeyID")
				return
			}
		case "team_id":
			z.TeamID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TeamID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OAuthProviderConfiguration) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 10 + msgp.StringPrefixSize + len(z.ClientID) + 14 + msgp.StringPrefixSize + len(z.ClientSecret) + 6 + msgp.StringPrefixSize + len(z.Scope) + 7 + msgp.StringPrefixSize + len(z.Tenant) + 7 + msgp.StringPrefixSize + len(z.KeyID) + 8 + msgp.StringPrefixSize + len(z.TeamID)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OAuthProviderType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = OAuthProviderType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z OAuthProviderType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z OAuthProviderType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OAuthProviderType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = OAuthProviderType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z OAuthProviderType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PasswordPolicyConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "min_length":
			z.MinLength, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MinLength")
				return
			}
		case "uppercase_required":
			z.UppercaseRequired, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "UppercaseRequired")
				return
			}
		case "lowercase_required":
			z.LowercaseRequired, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "LowercaseRequired")
				return
			}
		case "digit_required":
			z.DigitRequired, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "DigitRequired")
				return
			}
		case "symbol_required":
			z.SymbolRequired, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "SymbolRequired")
				return
			}
		case "minimum_guessable_level":
			z.MinimumGuessableLevel, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MinimumGuessableLevel")
				return
			}
		case "excluded_keywords":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ExcludedKeywords")
				return
			}
			if cap(z.ExcludedKeywords) >= int(zb0002) {
				z.ExcludedKeywords = (z.ExcludedKeywords)[:zb0002]
			} else {
				z.ExcludedKeywords = make([]string, zb0002)
			}
			for za0001 := range z.ExcludedKeywords {
				z.ExcludedKeywords[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ExcludedKeywords", za0001)
					return
				}
			}
		case "history_size":
			z.HistorySize, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HistorySize")
				return
			}
		case "history_days":
			z.HistoryDays, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HistoryDays")
				return
			}
		case "expiry_days":
			z.ExpiryDays, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ExpiryDays")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PasswordPolicyConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 10
	// write "min_length"
	err = en.Append(0x8a, 0xaa, 0x6d, 0x69, 0x6e, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MinLength)
	if err != nil {
		err = msgp.WrapError(err, "MinLength")
		return
	}
	// write "uppercase_required"
	err = en.Append(0xb2, 0x75, 0x70, 0x70, 0x65, 0x72, 0x63, 0x61, 0x73, 0x65, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.UppercaseRequired)
	if err != nil {
		err = msgp.WrapError(err, "UppercaseRequired")
		return
	}
	// write "lowercase_required"
	err = en.Append(0xb2, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x63, 0x61, 0x73, 0x65, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.LowercaseRequired)
	if err != nil {
		err = msgp.WrapError(err, "LowercaseRequired")
		return
	}
	// write "digit_required"
	err = en.Append(0xae, 0x64, 0x69, 0x67, 0x69, 0x74, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.DigitRequired)
	if err != nil {
		err = msgp.WrapError(err, "DigitRequired")
		return
	}
	// write "symbol_required"
	err = en.Append(0xaf, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.SymbolRequired)
	if err != nil {
		err = msgp.WrapError(err, "SymbolRequired")
		return
	}
	// write "minimum_guessable_level"
	err = en.Append(0xb7, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x5f, 0x67, 0x75, 0x65, 0x73, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x6c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MinimumGuessableLevel)
	if err != nil {
		err = msgp.WrapError(err, "MinimumGuessableLevel")
		return
	}
	// write "excluded_keywords"
	err = en.Append(0xb1, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x5f, 0x6b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ExcludedKeywords)))
	if err != nil {
		err = msgp.WrapError(err, "ExcludedKeywords")
		return
	}
	for za0001 := range z.ExcludedKeywords {
		err = en.WriteString(z.ExcludedKeywords[za0001])
		if err != nil {
			err = msgp.WrapError(err, "ExcludedKeywords", za0001)
			return
		}
	}
	// write "history_size"
	err = en.Append(0xac, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HistorySize)
	if err != nil {
		err = msgp.WrapError(err, "HistorySize")
		return
	}
	// write "history_days"
	err = en.Append(0xac, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x64, 0x61, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HistoryDays)
	if err != nil {
		err = msgp.WrapError(err, "HistoryDays")
		return
	}
	// write "expiry_days"
	err = en.Append(0xab, 0x65, 0x78, 0x70, 0x69, 0x72, 0x79, 0x5f, 0x64, 0x61, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ExpiryDays)
	if err != nil {
		err = msgp.WrapError(err, "ExpiryDays")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PasswordPolicyConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "min_length"
	o = append(o, 0x8a, 0xaa, 0x6d, 0x69, 0x6e, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68)
	o = msgp.AppendInt(o, z.MinLength)
	// string "uppercase_required"
	o = append(o, 0xb2, 0x75, 0x70, 0x70, 0x65, 0x72, 0x63, 0x61, 0x73, 0x65, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64)
	o = msgp.AppendBool(o, z.UppercaseRequired)
	// string "lowercase_required"
	o = append(o, 0xb2, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x63, 0x61, 0x73, 0x65, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64)
	o = msgp.AppendBool(o, z.LowercaseRequired)
	// string "digit_required"
	o = append(o, 0xae, 0x64, 0x69, 0x67, 0x69, 0x74, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64)
	o = msgp.AppendBool(o, z.DigitRequired)
	// string "symbol_required"
	o = append(o, 0xaf, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64)
	o = msgp.AppendBool(o, z.SymbolRequired)
	// string "minimum_guessable_level"
	o = append(o, 0xb7, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x5f, 0x67, 0x75, 0x65, 0x73, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x6c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.MinimumGuessableLevel)
	// string "excluded_keywords"
	o = append(o, 0xb1, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x5f, 0x6b, 0x65, 0x79, 0x77, 0x6f, 0x72, 0x64, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ExcludedKeywords)))
	for za0001 := range z.ExcludedKeywords {
		o = msgp.AppendString(o, z.ExcludedKeywords[za0001])
	}
	// string "history_size"
	o = append(o, 0xac, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.HistorySize)
	// string "history_days"
	o = append(o, 0xac, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x64, 0x61, 0x79, 0x73)
	o = msgp.AppendInt(o, z.HistoryDays)
	// string "expiry_days"
	o = append(o, 0xab, 0x65, 0x78, 0x70, 0x69, 0x72, 0x79, 0x5f, 0x64, 0x61, 0x79, 0x73)
	o = msgp.AppendInt(o, z.ExpiryDays)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PasswordPolicyConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "min_length":
			z.MinLength, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinLength")
				return
			}
		case "uppercase_required":
			z.UppercaseRequired, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UppercaseRequired")
				return
			}
		case "lowercase_required":
			z.LowercaseRequired, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LowercaseRequired")
				return
			}
		case "digit_required":
			z.DigitRequired, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DigitRequired")
				return
			}
		case "symbol_required":
			z.SymbolRequired, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SymbolRequired")
				return
			}
		case "minimum_guessable_level":
			z.MinimumGuessableLevel, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinimumGuessableLevel")
				return
			}
		case "excluded_keywords":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExcludedKeywords")
				return
			}
			if cap(z.ExcludedKeywords) >= int(zb0002) {
				z.ExcludedKeywords = (z.ExcludedKeywords)[:zb0002]
			} else {
				z.ExcludedKeywords = make([]string, zb0002)
			}
			for za0001 := range z.ExcludedKeywords {
				z.ExcludedKeywords[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExcludedKeywords", za0001)
					return
				}
			}
		case "history_size":
			z.HistorySize, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HistorySize")
				return
			}
		case "history_days":
			z.HistoryDays, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HistoryDays")
				return
			}
		case "expiry_days":
			z.ExpiryDays, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExpiryDays")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PasswordPolicyConfiguration) Msgsize() (s int) {
	s = 1 + 11 + msgp.IntSize + 19 + msgp.BoolSize + 19 + msgp.BoolSize + 15 + msgp.BoolSize + 16 + msgp.BoolSize + 24 + msgp.IntSize + 18 + msgp.ArrayHeaderSize
	for za0001 := range z.ExcludedKeywords {
		s += msgp.StringPrefixSize + len(z.ExcludedKeywords[za0001])
	}
	s += 13 + msgp.IntSize + 13 + msgp.IntSize + 12 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SMTPConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "host":
			z.Host, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Host")
				return
			}
		case "port":
			z.Port, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Port")
				return
			}
		case "mode":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Mode")
					return
				}
				z.Mode = SMTPMode(zb0002)
			}
		case "login":
			z.Login, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Login")
				return
			}
		case "password":
			z.Password, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Password")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SMTPConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "host"
	err = en.Append(0x85, 0xa4, 0x68, 0x6f, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Host)
	if err != nil {
		err = msgp.WrapError(err, "Host")
		return
	}
	// write "port"
	err = en.Append(0xa4, 0x70, 0x6f, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Port)
	if err != nil {
		err = msgp.WrapError(err, "Port")
		return
	}
	// write "mode"
	err = en.Append(0xa4, 0x6d, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Mode))
	if err != nil {
		err = msgp.WrapError(err, "Mode")
		return
	}
	// write "login"
	err = en.Append(0xa5, 0x6c, 0x6f, 0x67, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Login)
	if err != nil {
		err = msgp.WrapError(err, "Login")
		return
	}
	// write "password"
	err = en.Append(0xa8, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.Password)
	if err != nil {
		err = msgp.WrapError(err, "Password")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SMTPConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "host"
	o = append(o, 0x85, 0xa4, 0x68, 0x6f, 0x73, 0x74)
	o = msgp.AppendString(o, z.Host)
	// string "port"
	o = append(o, 0xa4, 0x70, 0x6f, 0x72, 0x74)
	o = msgp.AppendInt(o, z.Port)
	// string "mode"
	o = append(o, 0xa4, 0x6d, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, string(z.Mode))
	// string "login"
	o = append(o, 0xa5, 0x6c, 0x6f, 0x67, 0x69, 0x6e)
	o = msgp.AppendString(o, z.Login)
	// string "password"
	o = append(o, 0xa8, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64)
	o = msgp.AppendString(o, z.Password)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SMTPConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "host":
			z.Host, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Host")
				return
			}
		case "port":
			z.Port, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Port")
				return
			}
		case "mode":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Mode")
					return
				}
				z.Mode = SMTPMode(zb0002)
			}
		case "login":
			z.Login, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Login")
				return
			}
		case "password":
			z.Password, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Password")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SMTPConfiguration) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Host) + 5 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(string(z.Mode)) + 6 + msgp.StringPrefixSize + len(z.Login) + 9 + msgp.StringPrefixSize + len(z.Password)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SMTPMode) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = SMTPMode(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SMTPMode) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SMTPMode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SMTPMode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = SMTPMode(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SMTPMode) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SSOConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "oauth":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "OAuth")
					return
				}
				z.OAuth = nil
			} else {
				if z.OAuth == nil {
					z.OAuth = new(OAuthConfiguration)
				}
				err = z.OAuth.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "OAuth")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SSOConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "oauth"
	err = en.Append(0x81, 0xa5, 0x6f, 0x61, 0x75, 0x74, 0x68)
	if err != nil {
		return
	}
	if z.OAuth == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.OAuth.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "OAuth")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SSOConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "oauth"
	o = append(o, 0x81, 0xa5, 0x6f, 0x61, 0x75, 0x74, 0x68)
	if z.OAuth == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.OAuth.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "OAuth")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SSOConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "oauth":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.OAuth = nil
			} else {
				if z.OAuth == nil {
					z.OAuth = new(OAuthConfiguration)
				}
				bts, err = z.OAuth.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OAuth")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SSOConfiguration) Msgsize() (s int) {
	s = 1 + 6
	if z.OAuth == nil {
		s += msgp.NilSize
	} else {
		s += z.OAuth.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SessionCookieSameSite) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = SessionCookieSameSite(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SessionCookieSameSite) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SessionCookieSameSite) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SessionCookieSameSite) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = SessionCookieSameSite(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SessionCookieSameSite) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SessionTransportType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = SessionTransportType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SessionTransportType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SessionTransportType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SessionTransportType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = SessionTransportType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SessionTransportType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TemplateItem) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = TemplateItemType(zb0002)
			}
		case "language_tag":
			z.LanguageTag, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LanguageTag")
				return
			}
		case "key":
			z.Key, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		case "uri":
			z.URI, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "URI")
				return
			}
		case "digest":
			z.Digest, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Digest")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TemplateItem) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "type"
	err = en.Append(0x85, 0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Type))
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "language_tag"
	err = en.Append(0xac, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x5f, 0x74, 0x61, 0x67)
	if err != nil {
		return
	}
	err = en.WriteString(z.LanguageTag)
	if err != nil {
		err = msgp.WrapError(err, "LanguageTag")
		return
	}
	// write "key"
	err = en.Append(0xa3, 0x6b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	// write "uri"
	err = en.Append(0xa3, 0x75, 0x72, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.URI)
	if err != nil {
		err = msgp.WrapError(err, "URI")
		return
	}
	// write "digest"
	err = en.Append(0xa6, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Digest)
	if err != nil {
		err = msgp.WrapError(err, "Digest")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TemplateItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "type"
	o = append(o, 0x85, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "language_tag"
	o = append(o, 0xac, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x5f, 0x74, 0x61, 0x67)
	o = msgp.AppendString(o, z.LanguageTag)
	// string "key"
	o = append(o, 0xa3, 0x6b, 0x65, 0x79)
	o = msgp.AppendString(o, z.Key)
	// string "uri"
	o = append(o, 0xa3, 0x75, 0x72, 0x69)
	o = msgp.AppendString(o, z.URI)
	// string "digest"
	o = append(o, 0xa6, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74)
	o = msgp.AppendString(o, z.Digest)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TemplateItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = TemplateItemType(zb0002)
			}
		case "language_tag":
			z.LanguageTag, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LanguageTag")
				return
			}
		case "key":
			z.Key, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		case "uri":
			z.URI, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "URI")
				return
			}
		case "digest":
			z.Digest, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Digest")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TemplateItem) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 13 + msgp.StringPrefixSize + len(z.LanguageTag) + 4 + msgp.StringPrefixSize + len(z.Key) + 4 + msgp.StringPrefixSize + len(z.URI) + 7 + msgp.StringPrefixSize + len(z.Digest)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TemplateItemType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = TemplateItemType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z TemplateItemType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z TemplateItemType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TemplateItemType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = TemplateItemType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z TemplateItemType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TenantConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "api_version":
			z.APIVersion, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "APIVersion")
				return
			}
		case "app_id":
			z.AppID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AppID")
				return
			}
		case "app_name":
			z.AppName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AppName")
				return
			}
		case "hook":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Hook")
					return
				}
				z.Hook = nil
			} else {
				if z.Hook == nil {
					z.Hook = new(HookTenantConfiguration)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Hook")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Hook")
						return
					}
					switch msgp.UnsafeString(field) {
					case "sync_hook_timeout_second":
						z.Hook.SyncHookTimeout, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "Hook", "SyncHookTimeout")
							return
						}
					case "sync_hook_total_timeout_second":
						z.Hook.SyncHookTotalTimeout, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "Hook", "SyncHookTotalTimeout")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Hook")
							return
						}
					}
				}
			}
		case "database_config":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DatabaseConfig")
					return
				}
				z.DatabaseConfig = nil
			} else {
				if z.DatabaseConfig == nil {
					z.DatabaseConfig = new(DatabaseConfiguration)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "DatabaseConfig")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "DatabaseConfig")
						return
					}
					switch msgp.UnsafeString(field) {
					case "database_url":
						z.DatabaseConfig.DatabaseURL, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "DatabaseConfig", "DatabaseURL")
							return
						}
					case "database_schema":
						z.DatabaseConfig.DatabaseSchema, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "DatabaseConfig", "DatabaseSchema")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "DatabaseConfig")
							return
						}
					}
				}
			}
		case "app_config":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AppConfig")
					return
				}
				z.AppConfig = nil
			} else {
				if z.AppConfig == nil {
					z.AppConfig = new(AppConfiguration)
				}
				err = z.AppConfig.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "AppConfig")
					return
				}
			}
		case "template_items":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "TemplateItems")
				return
			}
			if cap(z.TemplateItems) >= int(zb0004) {
				z.TemplateItems = (z.TemplateItems)[:zb0004]
			} else {
				z.TemplateItems = make([]TemplateItem, zb0004)
			}
			for za0001 := range z.TemplateItems {
				err = z.TemplateItems[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "TemplateItems", za0001)
					return
				}
			}
		case "hooks":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Hooks")
				return
			}
			if cap(z.Hooks) >= int(zb0005) {
				z.Hooks = (z.Hooks)[:zb0005]
			} else {
				z.Hooks = make([]Hook, zb0005)
			}
			for za0002 := range z.Hooks {
				var zb0006 uint32
				zb0006, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Hooks", za0002)
					return
				}
				for zb0006 > 0 {
					zb0006--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Hooks", za0002)
						return
					}
					switch msgp.UnsafeString(field) {
					case "event":
						z.Hooks[za0002].Event, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Hooks", za0002, "Event")
							return
						}
					case "url":
						z.Hooks[za0002].URL, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Hooks", za0002, "URL")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Hooks", za0002)
							return
						}
					}
				}
			}
		case "deployment_routes":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "DeploymentRoutes")
				return
			}
			if cap(z.DeploymentRoutes) >= int(zb0007) {
				z.DeploymentRoutes = (z.DeploymentRoutes)[:zb0007]
			} else {
				z.DeploymentRoutes = make([]DeploymentRoute, zb0007)
			}
			for za0003 := range z.DeploymentRoutes {
				err = z.DeploymentRoutes[za0003].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "DeploymentRoutes", za0003)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TenantConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 9
	// write "api_version"
	err = en.Append(0x89, 0xab, 0x61, 0x70, 0x69, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.APIVersion)
	if err != nil {
		err = msgp.WrapError(err, "APIVersion")
		return
	}
	// write "app_id"
	err = en.Append(0xa6, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.AppID)
	if err != nil {
		err = msgp.WrapError(err, "AppID")
		return
	}
	// write "app_name"
	err = en.Append(0xa8, 0x61, 0x70, 0x70, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.AppName)
	if err != nil {
		err = msgp.WrapError(err, "AppName")
		return
	}
	// write "hook"
	err = en.Append(0xa4, 0x68, 0x6f, 0x6f, 0x6b)
	if err != nil {
		return
	}
	if z.Hook == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "sync_hook_timeout_second"
		err = en.Append(0x82, 0xb8, 0x73, 0x79, 0x6e, 0x63, 0x5f, 0x68, 0x6f, 0x6f, 0x6b, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Hook.SyncHookTimeout)
		if err != nil {
			err = msgp.WrapError(err, "Hook", "SyncHookTimeout")
			return
		}
		// write "sync_hook_total_timeout_second"
		err = en.Append(0xbe, 0x73, 0x79, 0x6e, 0x63, 0x5f, 0x68, 0x6f, 0x6f, 0x6b, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Hook.SyncHookTotalTimeout)
		if err != nil {
			err = msgp.WrapError(err, "Hook", "SyncHookTotalTimeout")
			return
		}
	}
	// write "database_config"
	err = en.Append(0xaf, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67)
	if err != nil {
		return
	}
	if z.DatabaseConfig == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "database_url"
		err = en.Append(0x82, 0xac, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x75, 0x72, 0x6c)
		if err != nil {
			return
		}
		err = en.WriteString(z.DatabaseConfig.DatabaseURL)
		if err != nil {
			err = msgp.WrapError(err, "DatabaseConfig", "DatabaseURL")
			return
		}
		// write "database_schema"
		err = en.Append(0xaf, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61)
		if err != nil {
			return
		}
		err = en.WriteString(z.DatabaseConfig.DatabaseSchema)
		if err != nil {
			err = msgp.WrapError(err, "DatabaseConfig", "DatabaseSchema")
			return
		}
	}
	// write "app_config"
	err = en.Append(0xaa, 0x61, 0x70, 0x70, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67)
	if err != nil {
		return
	}
	if z.AppConfig == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.AppConfig.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "AppConfig")
			return
		}
	}
	// write "template_items"
	err = en.Append(0xae, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.TemplateItems)))
	if err != nil {
		err = msgp.WrapError(err, "TemplateItems")
		return
	}
	for za0001 := range z.TemplateItems {
		err = z.TemplateItems[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "TemplateItems", za0001)
			return
		}
	}
	// write "hooks"
	err = en.Append(0xa5, 0x68, 0x6f, 0x6f, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Hooks)))
	if err != nil {
		err = msgp.WrapError(err, "Hooks")
		return
	}
	for za0002 := range z.Hooks {
		// map header, size 2
		// write "event"
		err = en.Append(0x82, 0xa5, 0x65, 0x76, 0x65, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Hooks[za0002].Event)
		if err != nil {
			err = msgp.WrapError(err, "Hooks", za0002, "Event")
			return
		}
		// write "url"
		err = en.Append(0xa3, 0x75, 0x72, 0x6c)
		if err != nil {
			return
		}
		err = en.WriteString(z.Hooks[za0002].URL)
		if err != nil {
			err = msgp.WrapError(err, "Hooks", za0002, "URL")
			return
		}
	}
	// write "deployment_routes"
	err = en.Append(0xb1, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.DeploymentRoutes)))
	if err != nil {
		err = msgp.WrapError(err, "DeploymentRoutes")
		return
	}
	for za0003 := range z.DeploymentRoutes {
		err = z.DeploymentRoutes[za0003].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "DeploymentRoutes", za0003)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TenantConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "api_version"
	o = append(o, 0x89, 0xab, 0x61, 0x70, 0x69, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.APIVersion)
	// string "app_id"
	o = append(o, 0xa6, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.AppID)
	// string "app_name"
	o = append(o, 0xa8, 0x61, 0x70, 0x70, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.AppName)
	// string "hook"
	o = append(o, 0xa4, 0x68, 0x6f, 0x6f, 0x6b)
	if z.Hook == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "sync_hook_timeout_second"
		o = append(o, 0x82, 0xb8, 0x73, 0x79, 0x6e, 0x63, 0x5f, 0x68, 0x6f, 0x6f, 0x6b, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64)
		o = msgp.AppendInt(o, z.Hook.SyncHookTimeout)
		// string "sync_hook_total_timeout_second"
		o = append(o, 0xbe, 0x73, 0x79, 0x6e, 0x63, 0x5f, 0x68, 0x6f, 0x6f, 0x6b, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64)
		o = msgp.AppendInt(o, z.Hook.SyncHookTotalTimeout)
	}
	// string "database_config"
	o = append(o, 0xaf, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67)
	if z.DatabaseConfig == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "database_url"
		o = append(o, 0x82, 0xac, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x75, 0x72, 0x6c)
		o = msgp.AppendString(o, z.DatabaseConfig.DatabaseURL)
		// string "database_schema"
		o = append(o, 0xaf, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61)
		o = msgp.AppendString(o, z.DatabaseConfig.DatabaseSchema)
	}
	// string "app_config"
	o = append(o, 0xaa, 0x61, 0x70, 0x70, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67)
	if z.AppConfig == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.AppConfig.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "AppConfig")
			return
		}
	}
	// string "template_items"
	o = append(o, 0xae, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.TemplateItems)))
	for za0001 := range z.TemplateItems {
		o, err = z.TemplateItems[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "TemplateItems", za0001)
			return
		}
	}
	// string "hooks"
	o = append(o, 0xa5, 0x68, 0x6f, 0x6f, 0x6b, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Hooks)))
	for za0002 := range z.Hooks {
		// map header, size 2
		// string "event"
		o = append(o, 0x82, 0xa5, 0x65, 0x76, 0x65, 0x6e, 0x74)
		o = msgp.AppendString(o, z.Hooks[za0002].Event)
		// string "url"
		o = append(o, 0xa3, 0x75, 0x72, 0x6c)
		o = msgp.AppendString(o, z.Hooks[za0002].URL)
	}
	// string "deployment_routes"
	o = append(o, 0xb1, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.DeploymentRoutes)))
	for za0003 := range z.DeploymentRoutes {
		o, err = z.DeploymentRoutes[za0003].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "DeploymentRoutes", za0003)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TenantConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "api_version":
			z.APIVersion, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "APIVersion")
				return
			}
		case "app_id":
			z.AppID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AppID")
				return
			}
		case "app_name":
			z.AppName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AppName")
				return
			}
		case "hook":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Hook = nil
			} else {
				if z.Hook == nil {
					z.Hook = new(HookTenantConfiguration)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Hook")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Hook")
						return
					}
					switch msgp.UnsafeString(field) {
					case "sync_hook_timeout_second":
						z.Hook.SyncHookTimeout, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Hook", "SyncHookTimeout")
							return
						}
					case "sync_hook_total_timeout_second":
						z.Hook.SyncHookTotalTimeout, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Hook", "SyncHookTotalTimeout")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Hook")
							return
						}
					}
				}
			}
		case "database_config":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DatabaseConfig = nil
			} else {
				if z.DatabaseConfig == nil {
					z.DatabaseConfig = new(DatabaseConfiguration)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DatabaseConfig")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "DatabaseConfig")
						return
					}
					switch msgp.UnsafeString(field) {
					case "database_url":
						z.DatabaseConfig.DatabaseURL, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "DatabaseConfig", "DatabaseURL")
							return
						}
					case "database_schema":
						z.DatabaseConfig.DatabaseSchema, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "DatabaseConfig", "DatabaseSchema")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "DatabaseConfig")
							return
						}
					}
				}
			}
		case "app_config":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AppConfig = nil
			} else {
				if z.AppConfig == nil {
					z.AppConfig = new(AppConfiguration)
				}
				bts, err = z.AppConfig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AppConfig")
					return
				}
			}
		case "template_items":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TemplateItems")
				return
			}
			if cap(z.TemplateItems) >= int(zb0004) {
				z.TemplateItems = (z.TemplateItems)[:zb0004]
			} else {
				z.TemplateItems = make([]TemplateItem, zb0004)
			}
			for za0001 := range z.TemplateItems {
				bts, err = z.TemplateItems[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TemplateItems", za0001)
					return
				}
			}
		case "hooks":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hooks")
				return
			}
			if cap(z.Hooks) >= int(zb0005) {
				z.Hooks = (z.Hooks)[:zb0005]
			} else {
				z.Hooks = make([]Hook, zb0005)
			}
			for za0002 := range z.Hooks {
				var zb0006 uint32
				zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Hooks", za0002)
					return
				}
				for zb0006 > 0 {
					zb0006--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Hooks", za0002)
						return
					}
					switch msgp.UnsafeString(field) {
					case "event":
						z.Hooks[za0002].Event, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Hooks", za0002, "Event")
							return
						}
					case "url":
						z.Hooks[za0002].URL, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Hooks", za0002, "URL")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Hooks", za0002)
							return
						}
					}
				}
			}
		case "deployment_routes":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeploymentRoutes")
				return
			}
			if cap(z.DeploymentRoutes) >= int(zb0007) {
				z.DeploymentRoutes = (z.DeploymentRoutes)[:zb0007]
			} else {
				z.DeploymentRoutes = make([]DeploymentRoute, zb0007)
			}
			for za0003 := range z.DeploymentRoutes {
				bts, err = z.DeploymentRoutes[za0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "DeploymentRoutes", za0003)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TenantConfiguration) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.APIVersion) + 7 + msgp.StringPrefixSize + len(z.AppID) + 9 + msgp.StringPrefixSize + len(z.AppName) + 5
	if z.Hook == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 25 + msgp.IntSize + 31 + msgp.IntSize
	}
	s += 16
	if z.DatabaseConfig == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 13 + msgp.StringPrefixSize + len(z.DatabaseConfig.DatabaseURL) + 16 + msgp.StringPrefixSize + len(z.DatabaseConfig.DatabaseSchema)
	}
	s += 11
	if z.AppConfig == nil {
		s += msgp.NilSize
	} else {
		s += z.AppConfig.Msgsize()
	}
	s += 15 + msgp.ArrayHeaderSize
	for za0001 := range z.TemplateItems {
		s += z.TemplateItems[za0001].Msgsize()
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Hooks {
		s += 1 + 6 + msgp.StringPrefixSize + len(z.Hooks[za0002].Event) + 4 + msgp.StringPrefixSize + len(z.Hooks[za0002].URL)
	}
	s += 18 + msgp.ArrayHeaderSize
	for za0003 := range z.DeploymentRoutes {
		s += z.DeploymentRoutes[za0003].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TwilioConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "account_sid":
			z.AccountSID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AccountSID")
				return
			}
		case "auth_token":
			z.AuthToken, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AuthToken")
				return
			}
		case "from":
			z.From, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "From")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z TwilioConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "account_sid"
	err = en.Append(0x83, 0xab, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x73, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.AccountSID)
	if err != nil {
		err = msgp.WrapError(err, "AccountSID")
		return
	}
	// write "auth_token"
	err = en.Append(0xaa, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.AuthToken)
	if err != nil {
		err = msgp.WrapError(err, "AuthToken")
		return
	}
	// write "from"
	err = en.Append(0xa4, 0x66, 0x72, 0x6f, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.From)
	if err != nil {
		err = msgp.WrapError(err, "From")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z TwilioConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "account_sid"
	o = append(o, 0x83, 0xab, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x73, 0x69, 0x64)
	o = msgp.AppendString(o, z.AccountSID)
	// string "auth_token"
	o = append(o, 0xaa, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.AuthToken)
	// string "from"
	o = append(o, 0xa4, 0x66, 0x72, 0x6f, 0x6d)
	o = msgp.AppendString(o, z.From)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TwilioConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "account_sid":
			z.AccountSID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AccountSID")
				return
			}
		case "auth_token":
			z.AuthToken, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AuthToken")
				return
			}
		case "from":
			z.From, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "From")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z TwilioConfiguration) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.AccountSID) + 11 + msgp.StringPrefixSize + len(z.AuthToken) + 5 + msgp.StringPrefixSize + len(z.From)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *UserAuditConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "enabled":
			z.Enabled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Enabled")
				return
			}
		case "trail_handler_url":
			z.TrailHandlerURL, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "TrailHandlerURL")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z UserAuditConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "enabled"
	err = en.Append(0x82, 0xa7, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Enabled)
	if err != nil {
		err = msgp.WrapError(err, "Enabled")
		return
	}
	// write "trail_handler_url"
	err = en.Append(0xb1, 0x74, 0x72, 0x61, 0x69, 0x6c, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x5f, 0x75, 0x72, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.TrailHandlerURL)
	if err != nil {
		err = msgp.WrapError(err, "TrailHandlerURL")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z UserAuditConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "enabled"
	o = append(o, 0x82, 0xa7, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Enabled)
	// string "trail_handler_url"
	o = append(o, 0xb1, 0x74, 0x72, 0x61, 0x69, 0x6c, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x5f, 0x75, 0x72, 0x6c)
	o = msgp.AppendString(o, z.TrailHandlerURL)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserAuditConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "enabled":
			z.Enabled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Enabled")
				return
			}
		case "trail_handler_url":
			z.TrailHandlerURL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TrailHandlerURL")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z UserAuditConfiguration) Msgsize() (s int) {
	s = 1 + 8 + msgp.BoolSize + 18 + msgp.StringPrefixSize + len(z.TrailHandlerURL)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *UserVerificationCodeFormat) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = UserVerificationCodeFormat(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z UserVerificationCodeFormat) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z UserVerificationCodeFormat) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserVerificationCodeFormat) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = UserVerificationCodeFormat(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z UserVerificationCodeFormat) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *UserVerificationConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "auto_send_on_signup":
			z.AutoSendOnSignup, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "AutoSendOnSignup")
				return
			}
		case "criteria":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Criteria")
					return
				}
				z.Criteria = UserVerificationCriteria(zb0002)
			}
		case "login_id_keys":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "LoginIDKeys")
				return
			}
			if cap(z.LoginIDKeys) >= int(zb0003) {
				z.LoginIDKeys = (z.LoginIDKeys)[:zb0003]
			} else {
				z.LoginIDKeys = make([]UserVerificationKeyConfiguration, zb0003)
			}
			for za0001 := range z.LoginIDKeys {
				err = z.LoginIDKeys[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LoginIDKeys", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *UserVerificationConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "auto_send_on_signup"
	err = en.Append(0x83, 0xb3, 0x61, 0x75, 0x74, 0x6f, 0x5f, 0x73, 0x65, 0x6e, 0x64, 0x5f, 0x6f, 0x6e, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x75, 0x70)
	if err != nil {
		return
	}
	err = en.WriteBool(z.AutoSendOnSignup)
	if err != nil {
		err = msgp.WrapError(err, "AutoSendOnSignup")
		return
	}
	// write "criteria"
	err = en.Append(0xa8, 0x63, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Criteria))
	if err != nil {
		err = msgp.WrapError(err, "Criteria")
		return
	}
	// write "login_id_keys"
	err = en.Append(0xad, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x5f, 0x69, 0x64, 0x5f, 0x6b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.LoginIDKeys)))
	if err != nil {
		err = msgp.WrapError(err, "LoginIDKeys")
		return
	}
	for za0001 := range z.LoginIDKeys {
		err = z.LoginIDKeys[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "LoginIDKeys", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *UserVerificationConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "auto_send_on_signup"
	o = append(o, 0x83, 0xb3, 0x61, 0x75, 0x74, 0x6f, 0x5f, 0x73, 0x65, 0x6e, 0x64, 0x5f, 0x6f, 0x6e, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x75, 0x70)
	o = msgp.AppendBool(o, z.AutoSendOnSignup)
	// string "criteria"
	o = append(o, 0xa8, 0x63, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61)
	o = msgp.AppendString(o, string(z.Criteria))
	// string "login_id_keys"
	o = append(o, 0xad, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x5f, 0x69, 0x64, 0x5f, 0x6b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.LoginIDKeys)))
	for za0001 := range z.LoginIDKeys {
		o, err = z.LoginIDKeys[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "LoginIDKeys", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserVerificationConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "auto_send_on_signup":
			z.AutoSendOnSignup, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AutoSendOnSignup")
				return
			}
		case "criteria":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Criteria")
					return
				}
				z.Criteria = UserVerificationCriteria(zb0002)
			}
		case "login_id_keys":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LoginIDKeys")
				return
			}
			if cap(z.LoginIDKeys) >= int(zb0003) {
				z.LoginIDKeys = (z.LoginIDKeys)[:zb0003]
			} else {
				z.LoginIDKeys = make([]UserVerificationKeyConfiguration, zb0003)
			}
			for za0001 := range z.LoginIDKeys {
				bts, err = z.LoginIDKeys[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LoginIDKeys", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *UserVerificationConfiguration) Msgsize() (s int) {
	s = 1 + 20 + msgp.BoolSize + 9 + msgp.StringPrefixSize + len(string(z.Criteria)) + 14 + msgp.ArrayHeaderSize
	for za0001 := range z.LoginIDKeys {
		s += z.LoginIDKeys[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *UserVerificationCriteria) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = UserVerificationCriteria(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z UserVerificationCriteria) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z UserVerificationCriteria) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserVerificationCriteria) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = UserVerificationCriteria(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z UserVerificationCriteria) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *UserVerificationKeyConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "key":
			z.Key, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		case "code_format":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "CodeFormat")
					return
				}
				z.CodeFormat = UserVerificationCodeFormat(zb0002)
			}
		case "expiry":
			z.Expiry, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Expiry")
				return
			}
		case "success_redirect":
			z.SuccessRedirect, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SuccessRedirect")
				return
			}
		case "error_redirect":
			z.ErrorRedirect, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ErrorRedirect")
				return
			}
		case "subject":
			z.Subject, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Subject")
				return
			}
		case "sender":
			z.Sender, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		case "reply_to":
			z.ReplyTo, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ReplyTo")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *UserVerificationKeyConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "key"
	err = en.Append(0x88, 0xa3, 0x6b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	// write "code_format"
	err = en.Append(0xab, 0x63, 0x6f, 0x64, 0x65, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.CodeFormat))
	if err != nil {
		err = msgp.WrapError(err, "CodeFormat")
		return
	}
	// write "expiry"
	err = en.Append(0xa6, 0x65, 0x78, 0x70, 0x69, 0x72, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Expiry)
	if err != nil {
		err = msgp.WrapError(err, "Expiry")
		return
	}
	// write "success_redirect"
	err = en.Append(0xb0, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x72, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.SuccessRedirect)
	if err != nil {
		err = msgp.WrapError(err, "SuccessRedirect")
		return
	}
	// write "error_redirect"
	err = en.Append(0xae, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x72, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.ErrorRedirect)
	if err != nil {
		err = msgp.WrapError(err, "ErrorRedirect")
		return
	}
	// write "subject"
	err = en.Append(0xa7, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Subject)
	if err != nil {
		err = msgp.WrapError(err, "Subject")
		return
	}
	// write "sender"
	err = en.Append(0xa6, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sender)
	if err != nil {
		err = msgp.WrapError(err, "Sender")
		return
	}
	// write "reply_to"
	err = en.Append(0xa8, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x5f, 0x74, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteString(z.ReplyTo)
	if err != nil {
		err = msgp.WrapError(err, "ReplyTo")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *UserVerificationKeyConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "key"
	o = append(o, 0x88, 0xa3, 0x6b, 0x65, 0x79)
	o = msgp.AppendString(o, z.Key)
	// string "code_format"
	o = append(o, 0xab, 0x63, 0x6f, 0x64, 0x65, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74)
	o = msgp.AppendString(o, string(z.CodeFormat))
	// string "expiry"
	o = append(o, 0xa6, 0x65, 0x78, 0x70, 0x69, 0x72, 0x79)
	o = msgp.AppendInt64(o, z.Expiry)
	// string "success_redirect"
	o = append(o, 0xb0, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x72, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.SuccessRedirect)
	// string "error_redirect"
	o = append(o, 0xae, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x72, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.ErrorRedirect)
	// string "subject"
	o = append(o, 0xa7, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Subject)
	// string "sender"
	o = append(o, 0xa6, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72)
	o = msgp.AppendString(o, z.Sender)
	// string "reply_to"
	o = append(o, 0xa8, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x5f, 0x74, 0x6f)
	o = msgp.AppendString(o, z.ReplyTo)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UserVerificationKeyConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "key":
			z.Key, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		case "code_format":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CodeFormat")
					return
				}
				z.CodeFormat = UserVerificationCodeFormat(zb0002)
			}
		case "expiry":
			z.Expiry, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Expiry")
				return
			}
		case "success_redirect":
			z.SuccessRedirect, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SuccessRedirect")
				return
			}
		case "error_redirect":
			z.ErrorRedirect, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ErrorRedirect")
				return
			}
		case "subject":
			z.Subject, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Subject")
				return
			}
		case "sender":
			z.Sender, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		case "reply_to":
			z.ReplyTo, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplyTo")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *UserVerificationKeyConfiguration) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.Key) + 12 + msgp.StringPrefixSize + len(string(z.CodeFormat)) + 7 + msgp.Int64Size + 17 + msgp.StringPrefixSize + len(z.SuccessRedirect) + 15 + msgp.StringPrefixSize + len(z.ErrorRedirect) + 8 + msgp.StringPrefixSize + len(z.Subject) + 7 + msgp.StringPrefixSize + len(z.Sender) + 9 + msgp.StringPrefixSize + len(z.ReplyTo)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *WelcomeEmailConfiguration) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "enabled":
			z.Enabled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Enabled")
				return
			}
		case "sender":
			z.Sender, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		case "subject":
			z.Subject, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Subject")
				return
			}
		case "reply_to":
			z.ReplyTo, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ReplyTo")
				return
			}
		case "destination":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Destination")
					return
				}
				z.Destination = WelcomeEmailDestination(zb0002)
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *WelcomeEmailConfiguration) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "enabled"
	err = en.Append(0x85, 0xa7, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Enabled)
	if err != nil {
		err = msgp.WrapError(err, "Enabled")
		return
	}
	// write "sender"
	err = en.Append(0xa6, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Sender)
	if err != nil {
		err = msgp.WrapError(err, "Sender")
		return
	}
	// write "subject"
	err = en.Append(0xa7, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Subject)
	if err != nil {
		err = msgp.WrapError(err, "Subject")
		return
	}
	// write "reply_to"
	err = en.Append(0xa8, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x5f, 0x74, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteString(z.ReplyTo)
	if err != nil {
		err = msgp.WrapError(err, "ReplyTo")
		return
	}
	// write "destination"
	err = en.Append(0xab, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Destination))
	if err != nil {
		err = msgp.WrapError(err, "Destination")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *WelcomeEmailConfiguration) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "enabled"
	o = append(o, 0x85, 0xa7, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Enabled)
	// string "sender"
	o = append(o, 0xa6, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72)
	o = msgp.AppendString(o, z.Sender)
	// string "subject"
	o = append(o, 0xa7, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Subject)
	// string "reply_to"
	o = append(o, 0xa8, 0x72, 0x65, 0x70, 0x6c, 0x79, 0x5f, 0x74, 0x6f)
	o = msgp.AppendString(o, z.ReplyTo)
	// string "destination"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, string(z.Destination))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WelcomeEmailConfiguration) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "enabled":
			z.Enabled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Enabled")
				return
			}
		case "sender":
			z.Sender, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		case "subject":
			z.Subject, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Subject")
				return
			}
		case "reply_to":
			z.ReplyTo, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplyTo")
				return
			}
		case "destination":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Destination")
					return
				}
				z.Destination = WelcomeEmailDestination(zb0002)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *WelcomeEmailConfiguration) Msgsize() (s int) {
	s = 1 + 8 + msgp.BoolSize + 7 + msgp.StringPrefixSize + len(z.Sender) + 8 + msgp.StringPrefixSize + len(z.Subject) + 9 + msgp.StringPrefixSize + len(z.ReplyTo) + 12 + msgp.StringPrefixSize + len(string(z.Destination))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *WelcomeEmailDestination) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = WelcomeEmailDestination(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z WelcomeEmailDestination) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WelcomeEmailDestination) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WelcomeEmailDestination) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = WelcomeEmailDestination(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WelcomeEmailDestination) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}
