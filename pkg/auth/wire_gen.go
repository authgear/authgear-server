// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package auth

import (
	"context"
	api2 "github.com/authgear/authgear-server/pkg/auth/api"
	"github.com/authgear/authgear-server/pkg/auth/handler/api"
	"github.com/authgear/authgear-server/pkg/auth/handler/oauth"
	siwe3 "github.com/authgear/authgear-server/pkg/auth/handler/siwe"
	"github.com/authgear/authgear-server/pkg/auth/handler/webapp"
	"github.com/authgear/authgear-server/pkg/auth/handler/webapp/viewmodels"
	webapp2 "github.com/authgear/authgear-server/pkg/auth/webapp"
	"github.com/authgear/authgear-server/pkg/lib/accountmigration"
	"github.com/authgear/authgear-server/pkg/lib/app2app"
	"github.com/authgear/authgear-server/pkg/lib/audit"
	"github.com/authgear/authgear-server/pkg/lib/authenticationflow"
	"github.com/authgear/authgear-server/pkg/lib/authn/authenticationinfo"
	"github.com/authgear/authgear-server/pkg/lib/authn/authenticator/oob"
	passkey3 "github.com/authgear/authgear-server/pkg/lib/authn/authenticator/passkey"
	"github.com/authgear/authgear-server/pkg/lib/authn/authenticator/password"
	service2 "github.com/authgear/authgear-server/pkg/lib/authn/authenticator/service"
	"github.com/authgear/authgear-server/pkg/lib/authn/authenticator/totp"
	"github.com/authgear/authgear-server/pkg/lib/authn/challenge"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/anonymous"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/biometric"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/loginid"
	oauth3 "github.com/authgear/authgear-server/pkg/lib/authn/identity/oauth"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/passkey"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/service"
	"github.com/authgear/authgear-server/pkg/lib/authn/identity/siwe"
	"github.com/authgear/authgear-server/pkg/lib/authn/mfa"
	"github.com/authgear/authgear-server/pkg/lib/authn/otp"
	"github.com/authgear/authgear-server/pkg/lib/authn/sso"
	stdattrs2 "github.com/authgear/authgear-server/pkg/lib/authn/stdattrs"
	"github.com/authgear/authgear-server/pkg/lib/authn/user"
	"github.com/authgear/authgear-server/pkg/lib/config/configsource"
	"github.com/authgear/authgear-server/pkg/lib/deps"
	"github.com/authgear/authgear-server/pkg/lib/elasticsearch"
	"github.com/authgear/authgear-server/pkg/lib/endpoints"
	"github.com/authgear/authgear-server/pkg/lib/event"
	"github.com/authgear/authgear-server/pkg/lib/facade"
	"github.com/authgear/authgear-server/pkg/lib/feature/captcha"
	"github.com/authgear/authgear-server/pkg/lib/feature/customattrs"
	"github.com/authgear/authgear-server/pkg/lib/feature/forgotpassword"
	passkey2 "github.com/authgear/authgear-server/pkg/lib/feature/passkey"
	siwe2 "github.com/authgear/authgear-server/pkg/lib/feature/siwe"
	"github.com/authgear/authgear-server/pkg/lib/feature/stdattrs"
	"github.com/authgear/authgear-server/pkg/lib/feature/verification"
	"github.com/authgear/authgear-server/pkg/lib/feature/web3"
	"github.com/authgear/authgear-server/pkg/lib/healthz"
	"github.com/authgear/authgear-server/pkg/lib/hook"
	captcha2 "github.com/authgear/authgear-server/pkg/lib/infra/captcha"
	"github.com/authgear/authgear-server/pkg/lib/infra/db/appdb"
	"github.com/authgear/authgear-server/pkg/lib/infra/db/auditdb"
	"github.com/authgear/authgear-server/pkg/lib/infra/db/globaldb"
	"github.com/authgear/authgear-server/pkg/lib/infra/middleware"
	"github.com/authgear/authgear-server/pkg/lib/infra/whatsapp"
	"github.com/authgear/authgear-server/pkg/lib/interaction"
	"github.com/authgear/authgear-server/pkg/lib/lockout"
	"github.com/authgear/authgear-server/pkg/lib/messaging"
	"github.com/authgear/authgear-server/pkg/lib/meter"
	"github.com/authgear/authgear-server/pkg/lib/nonce"
	oauth2 "github.com/authgear/authgear-server/pkg/lib/oauth"
	"github.com/authgear/authgear-server/pkg/lib/oauth/handler"
	"github.com/authgear/authgear-server/pkg/lib/oauth/oauthsession"
	"github.com/authgear/authgear-server/pkg/lib/oauth/oidc"
	handler2 "github.com/authgear/authgear-server/pkg/lib/oauth/oidc/handler"
	"github.com/authgear/authgear-server/pkg/lib/oauth/pq"
	"github.com/authgear/authgear-server/pkg/lib/oauth/redis"
	"github.com/authgear/authgear-server/pkg/lib/oauthclient"
	"github.com/authgear/authgear-server/pkg/lib/presign"
	"github.com/authgear/authgear-server/pkg/lib/ratelimit"
	"github.com/authgear/authgear-server/pkg/lib/session"
	"github.com/authgear/authgear-server/pkg/lib/session/access"
	"github.com/authgear/authgear-server/pkg/lib/session/idpsession"
	"github.com/authgear/authgear-server/pkg/lib/sessionlisting"
	"github.com/authgear/authgear-server/pkg/lib/tester"
	"github.com/authgear/authgear-server/pkg/lib/translation"
	"github.com/authgear/authgear-server/pkg/lib/usage"
	"github.com/authgear/authgear-server/pkg/lib/web"
	"github.com/authgear/authgear-server/pkg/lib/workflow"
	"github.com/authgear/authgear-server/pkg/util/clock"
	"github.com/authgear/authgear-server/pkg/util/httproute"
	"github.com/authgear/authgear-server/pkg/util/httputil"
	"github.com/authgear/authgear-server/pkg/util/intl"
	"github.com/authgear/authgear-server/pkg/util/rand"
	"github.com/authgear/authgear-server/pkg/util/template"
	"net/http"
)

// Injectors from wire_handler.go:

func newHealthzHandler(p *deps.RootProvider, w http.ResponseWriter, r *http.Request, ctx context.Context) http.Handler {
	pool := p.DatabasePool
	environmentConfig := p.EnvironmentConfig
	globalDatabaseCredentialsEnvironmentConfig := &environmentConfig.GlobalDatabase
	databaseEnvironmentConfig := &environmentConfig.DatabaseConfig
	factory := p.LoggerFactory
	handle := globaldb.NewHandle(ctx, pool, globalDatabaseCredentialsEnvironmentConfig, databaseEnvironmentConfig, factory)
	sqlExecutor := globaldb.NewSQLExecutor(ctx, handle)
	handlerLogger := healthz.NewHandlerLogger(factory)
	handler := &healthz.Handler{
		Context:        ctx,
		GlobalDatabase: handle,
		GlobalExecutor: sqlExecutor,
		Logger:         handlerLogger,
	}
	return handler
}

func newWebAppGeneratedStaticAssetsHandler(p *deps.RootProvider, w http.ResponseWriter, r *http.Request, ctx context.Context) http.Handler {
	globalEmbeddedResourceManager := p.EmbeddedResources
	generatedStaticAssetsHandler := &webapp.GeneratedStaticAssetsHandler{
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	return generatedStaticAssetsHandler
}

func newOAuthAuthorizeHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	authorizeHandlerLogger := oauth.NewAuthorizeHandlerLogger(factory)
	handle := appProvider.AppDatabase
	request := p.Request
	contextContext := deps.ProvideRequestContext(request)
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	oAuthConfig := appConfig.OAuth
	httpConfig := appConfig.HTTP
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	authorizationHandlerLogger := handler.NewAuthorizationHandlerLogger(factory)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	uiurlBuilder := &oidc.UIURLBuilder{
		Endpoints: endpointsEndpoints,
	}
	clock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	appredisHandle := appProvider.Redis
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	rand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clock,
		Random:          rand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	authorizationService := &oauth2.AuthorizationService{
		AppID:               appID,
		Store:               authorizationStore,
		Clock:               clock,
		OAuthSessionManager: sessionManager,
	}
	scopesValidator := _wireScopesValidatorValue
	oauthOfflineGrantService := &oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	appSessionTokenService := &oauth2.AppSessionTokenService{
		AppSessions:         redisStore,
		AppSessionTokens:    redisStore,
		OfflineGrants:       redisStore,
		OfflineGrantService: oauthOfflineGrantService,
		Cookies:             cookieManager,
		Clock:               clock,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	oauthsessionStoreRedis := &oauthsession.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	tokenGenerator := _wireTokenGeneratorValue
	codeGrantService := handler.CodeGrantService{
		AppID:         appID,
		CodeGenerator: tokenGenerator,
		Clock:         clock,
		CodeGrants:    redisStore,
	}
	authorizationHandler := &handler.AuthorizationHandler{
		Context:                   contextContext,
		AppID:                     appID,
		Config:                    oAuthConfig,
		HTTPConfig:                httpConfig,
		HTTPOrigin:                httpOrigin,
		Logger:                    authorizationHandlerLogger,
		UIURLBuilder:              uiurlBuilder,
		UIInfoResolver:            uiInfoResolver,
		Authorizations:            authorizationService,
		ValidateScopes:            scopesValidator,
		AppSessionTokenService:    appSessionTokenService,
		AuthenticationInfoService: authenticationinfoStoreRedis,
		Clock:                     clock,
		Cookies:                   cookieManager,
		OAuthSessionService:       oauthsessionStoreRedis,
		CodeGrantService:          codeGrantService,
		ClientResolver:            oauthclientResolver,
	}
	authorizeHandler := &oauth.AuthorizeHandler{
		Logger:       authorizeHandlerLogger,
		Database:     handle,
		AuthzHandler: authorizationHandler,
	}
	return authorizeHandler
}

var (
	_wireSystemClockValue     = clock.NewSystemClock()
	_wireRandValue            = idpsession.Rand(rand.SecureRand)
	_wireScopesValidatorValue = handler.ScopesValidator(oidc.ValidateScopes)
	_wireTokenGeneratorValue  = handler.TokenGenerator(oauth2.GenerateToken)
)

func newOAuthConsentHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	consentHandlerLogger := oauth.NewConsentHandlerLogger(factory)
	handle := appProvider.AppDatabase
	request := p.Request
	contextContext := deps.ProvideRequestContext(request)
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	oAuthConfig := appConfig.OAuth
	httpConfig := appConfig.HTTP
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	authorizationHandlerLogger := handler.NewAuthorizationHandlerLogger(factory)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	uiurlBuilder := &oidc.UIURLBuilder{
		Endpoints: endpointsEndpoints,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	appredisHandle := appProvider.Redis
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	authorizationService := &oauth2.AuthorizationService{
		AppID:               appID,
		Store:               authorizationStore,
		Clock:               clockClock,
		OAuthSessionManager: sessionManager,
	}
	scopesValidator := _wireScopesValidatorValue
	oauthOfflineGrantService := &oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	appSessionTokenService := &oauth2.AppSessionTokenService{
		AppSessions:         redisStore,
		AppSessionTokens:    redisStore,
		OfflineGrants:       redisStore,
		OfflineGrantService: oauthOfflineGrantService,
		Cookies:             cookieManager,
		Clock:               clockClock,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	oauthsessionStoreRedis := &oauthsession.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	tokenGenerator := _wireTokenGeneratorValue
	codeGrantService := handler.CodeGrantService{
		AppID:         appID,
		CodeGenerator: tokenGenerator,
		Clock:         clockClock,
		CodeGrants:    redisStore,
	}
	authorizationHandler := &handler.AuthorizationHandler{
		Context:                   contextContext,
		AppID:                     appID,
		Config:                    oAuthConfig,
		HTTPConfig:                httpConfig,
		HTTPOrigin:                httpOrigin,
		Logger:                    authorizationHandlerLogger,
		UIURLBuilder:              uiurlBuilder,
		UIInfoResolver:            uiInfoResolver,
		Authorizations:            authorizationService,
		ValidateScopes:            scopesValidator,
		AppSessionTokenService:    appSessionTokenService,
		AuthenticationInfoService: authenticationinfoStoreRedis,
		Clock:                     clockClock,
		Cookies:                   cookieManager,
		OAuthSessionService:       oauthsessionStoreRedis,
		CodeGrantService:          codeGrantService,
		ClientResolver:            oauthclientResolver,
	}
	uiConfig := appConfig.UI
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	errorCookieDef := webapp2.NewErrorCookieDef()
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	consentHandler := &oauth.ConsentHandler{
		Logger:        consentHandlerLogger,
		Database:      handle,
		Handler:       authorizationHandler,
		BaseViewModel: baseViewModeler,
		Renderer:      responseRenderer,
		Identities:    serviceService,
	}
	return consentHandler
}

func newOAuthTokenHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	tokenHandlerLogger := oauth.NewTokenHandlerLogger(factory)
	handle := appProvider.AppDatabase
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	oAuthConfig := appConfig.OAuth
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	featureConfig := config.FeatureConfig
	oAuthFeatureConfig := featureConfig.OAuth
	identityFeatureConfig := featureConfig.Identity
	secretConfig := config.SecretConfig
	oAuthClientCredentials := deps.ProvideOAuthClientCredentials(secretConfig)
	handlerTokenHandlerLogger := handler.NewTokenHandlerLogger(factory)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	clockClock := _wireSystemClockValue
	appredisHandle := appProvider.Redis
	logger := redis.NewLogger(factory)
	store := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      logger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	storeRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	provider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           storeRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	resolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    provider,
		ClientResolver: resolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   store,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	authorizationService := &oauth2.AuthorizationService{
		AppID:               appID,
		Store:               authorizationStore,
		Clock:               clockClock,
		OAuthSessionManager: sessionManager,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	userStore := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: userStore,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	loginidProvider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	templateResolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: templateResolver,
	}
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	siweStoreRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           siweStoreRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               loginidProvider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         userStore,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   userStore,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              userStore,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: userStore,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         userStore,
		Events:            eventService,
	}
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     storeRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             resolver,
		OfflineGrants:                   store,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        provider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef,
		MFADeviceTokenCookie:            mfaCookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	accessTokenEncoding := &oauth2.AccessTokenEncoding{
		Secrets:    oAuthKeyMaterials,
		Clock:      clockClock,
		UserClaims: idTokenIssuer,
		BaseURL:    endpointsEndpoints,
		Events:     eventService,
	}
	tokenGenerator := _wireTokenGeneratorValue
	tokenService := handler.TokenService{
		RemoteIP:            remoteIP,
		UserAgentString:     userAgentString,
		AppID:               appID,
		Config:              oAuthConfig,
		Authorizations:      authorizationStore,
		OfflineGrants:       store,
		AccessGrants:        store,
		OfflineGrantService: offlineGrantService,
		AccessEvents:        eventProvider,
		AccessTokenIssuer:   accessTokenEncoding,
		GenerateToken:       tokenGenerator,
		Clock:               clockClock,
		Users:               queries,
	}
	app2appProvider := &app2app.Provider{
		Clock: clockClock,
	}
	codeGrantService := handler.CodeGrantService{
		AppID:         appID,
		CodeGenerator: tokenGenerator,
		Clock:         clockClock,
		CodeGrants:    store,
	}
	tokenHandler := &handler.TokenHandler{
		AppID:                  appID,
		Config:                 oAuthConfig,
		HTTPOrigin:             httpOrigin,
		OAuthFeatureConfig:     oAuthFeatureConfig,
		IdentityFeatureConfig:  identityFeatureConfig,
		OAuthClientCredentials: oAuthClientCredentials,
		Logger:                 handlerTokenHandlerLogger,
		Authorizations:         authorizationService,
		CodeGrants:             store,
		OfflineGrants:          store,
		AppSessionTokens:       store,
		OfflineGrantService:    offlineGrantService,
		Graphs:                 interactionService,
		IDTokenIssuer:          idTokenIssuer,
		Clock:                  clockClock,
		TokenService:           tokenService,
		Events:                 eventService,
		SessionManager:         manager2,
		App2App:                app2appProvider,
		Challenges:             challengeProvider,
		CodeGrantService:       codeGrantService,
		ClientResolver:         resolver,
	}
	oauthTokenHandler := &oauth.TokenHandler{
		Logger:       tokenHandlerLogger,
		Database:     handle,
		TokenHandler: tokenHandler,
	}
	return oauthTokenHandler
}

func newOAuthRevokeHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	revokeHandlerLogger := oauth.NewRevokeHandlerLogger(factory)
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	clockClock := _wireSystemClockValue
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	storeRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	manager := &idpsession.Manager{
		Store:     storeRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	contextContext := deps.ProvideRequestContext(request)
	logger := redis.NewLogger(factory)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      logger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	userAgentString := deps.ProvideUserAgentString(request)
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	provider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           storeRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	resolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    provider,
		ClientResolver: resolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   store,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	eventLogger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	userStore := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: userStore,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	resourceManager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: resourceManager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	loginidProvider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	templateResolver := &template.Resolver{
		Resources:             resourceManager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: templateResolver,
	}
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         resourceManager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	siweStoreRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           siweStoreRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               loginidProvider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         userStore,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   userStore,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              userStore,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: resourceManager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	manager2 := &session.Manager{
		IDPSessions:         manager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	revokeHandler := &handler.RevokeHandler{
		SessionManager: manager2,
		OfflineGrants:  store,
		AccessGrants:   store,
	}
	oauthRevokeHandler := &oauth.RevokeHandler{
		Logger:        revokeHandlerLogger,
		Database:      handle,
		RevokeHandler: revokeHandler,
	}
	return oauthRevokeHandler
}

func newOAuthMetadataHandler(p *deps.RequestProvider) http.Handler {
	request := p.Request
	appProvider := p.AppProvider
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	metadataProvider := &oauth2.MetadataProvider{
		Endpoints: endpointsEndpoints,
	}
	oidcMetadataProvider := &oidc.MetadataProvider{
		Endpoints: endpointsEndpoints,
	}
	v := ProvideOAuthMetadataProviders(metadataProvider, oidcMetadataProvider)
	metadataHandler := &oauth.MetadataHandler{
		Providers: v,
	}
	return metadataHandler
}

func newOAuthJWKSHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	jwksHandlerLogger := oauth.NewJWKSHandlerLogger(factory)
	appContext := appProvider.AppContext
	config := appContext.Config
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	appConfig := config.AppConfig
	appID := appConfig.ID
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	handle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	clockClock := _wireSystemClockValue
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	appredisHandle := appProvider.Redis
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	jwksHandler := &oauth.JWKSHandler{
		Logger: jwksHandlerLogger,
		JWKS:   idTokenIssuer,
	}
	return jwksHandler
}

func newOAuthUserInfoHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	userInfoHandlerLogger := oauth.NewUserInfoHandlerLogger(factory)
	handle := appProvider.AppDatabase
	appContext := appProvider.AppContext
	config := appContext.Config
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	appConfig := config.AppConfig
	appID := appConfig.ID
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	clockClock := _wireSystemClockValue
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	appredisHandle := appProvider.Redis
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	oAuthConfig := appConfig.OAuth
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	userInfoHandler := &oauth.UserInfoHandler{
		Logger:              userInfoHandlerLogger,
		Database:            handle,
		UserInfoProvider:    idTokenIssuer,
		OAuth:               oAuthConfig,
		OAuthClientResolver: oauthclientResolver,
	}
	return userInfoHandler
}

func newOAuthEndSessionHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	endSessionHandlerLogger := oauth.NewEndSessionHandlerLogger(factory)
	handle := appProvider.AppDatabase
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	oAuthConfig := appConfig.OAuth
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	appredisHandle := appProvider.Redis
	appID := appConfig.ID
	clockClock := _wireSystemClockValue
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	storeRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	manager := &idpsession.Manager{
		Store:     storeRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	contextContext := deps.ProvideRequestContext(request)
	logger := redis.NewLogger(factory)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      logger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	userAgentString := deps.ProvideUserAgentString(request)
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	provider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           storeRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	resolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    provider,
		ClientResolver: resolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   store,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	eventLogger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	userStore := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: userStore,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	resourceManager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: resourceManager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	loginidProvider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	templateResolver := &template.Resolver{
		Resources:             resourceManager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: templateResolver,
	}
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         resourceManager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	siweStoreRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           siweStoreRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               loginidProvider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         userStore,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   userStore,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              userStore,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: resourceManager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	manager2 := &session.Manager{
		IDPSessions:         manager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	endSessionHandler := &handler2.EndSessionHandler{
		Config:           oAuthConfig,
		Endpoints:        endpointsEndpoints,
		URLs:             endpointsEndpoints,
		SessionManager:   manager2,
		SessionCookieDef: cookieDef,
		Cookies:          cookieManager,
	}
	oauthEndSessionHandler := &oauth.EndSessionHandler{
		Logger:            endSessionHandlerLogger,
		Database:          handle,
		EndSessionHandler: endSessionHandler,
	}
	return oauthEndSessionHandler
}

func newOAuthChallengeHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	clockClock := _wireSystemClockValue
	provider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	factory := appProvider.LoggerFactory
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	challengeHandler := &oauth.ChallengeHandler{
		Database:   handle,
		Challenges: provider,
		JSON:       jsonResponseWriter,
	}
	return challengeHandler
}

func newOAuthAppSessionTokenHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	handle := appProvider.AppDatabase
	factory := appProvider.LoggerFactory
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	oAuthConfig := appConfig.OAuth
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	featureConfig := config.FeatureConfig
	oAuthFeatureConfig := featureConfig.OAuth
	identityFeatureConfig := featureConfig.Identity
	secretConfig := config.SecretConfig
	oAuthClientCredentials := deps.ProvideOAuthClientCredentials(secretConfig)
	tokenHandlerLogger := handler.NewTokenHandlerLogger(factory)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	clockClock := _wireSystemClockValue
	appredisHandle := appProvider.Redis
	logger := redis.NewLogger(factory)
	store := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      logger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	storeRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	provider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           storeRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	resolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    provider,
		ClientResolver: resolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   store,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	authorizationService := &oauth2.AuthorizationService{
		AppID:               appID,
		Store:               authorizationStore,
		Clock:               clockClock,
		OAuthSessionManager: sessionManager,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	userStore := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: userStore,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	loginidProvider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	templateResolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: templateResolver,
	}
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	siweStoreRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           siweStoreRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               loginidProvider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         userStore,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   userStore,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              userStore,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: userStore,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         userStore,
		Events:            eventService,
	}
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     storeRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             resolver,
		OfflineGrants:                   store,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        provider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef,
		MFADeviceTokenCookie:            mfaCookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	accessTokenEncoding := &oauth2.AccessTokenEncoding{
		Secrets:    oAuthKeyMaterials,
		Clock:      clockClock,
		UserClaims: idTokenIssuer,
		BaseURL:    endpointsEndpoints,
		Events:     eventService,
	}
	tokenGenerator := _wireTokenGeneratorValue
	tokenService := handler.TokenService{
		RemoteIP:            remoteIP,
		UserAgentString:     userAgentString,
		AppID:               appID,
		Config:              oAuthConfig,
		Authorizations:      authorizationStore,
		OfflineGrants:       store,
		AccessGrants:        store,
		OfflineGrantService: offlineGrantService,
		AccessEvents:        eventProvider,
		AccessTokenIssuer:   accessTokenEncoding,
		GenerateToken:       tokenGenerator,
		Clock:               clockClock,
		Users:               queries,
	}
	app2appProvider := &app2app.Provider{
		Clock: clockClock,
	}
	codeGrantService := handler.CodeGrantService{
		AppID:         appID,
		CodeGenerator: tokenGenerator,
		Clock:         clockClock,
		CodeGrants:    store,
	}
	tokenHandler := &handler.TokenHandler{
		AppID:                  appID,
		Config:                 oAuthConfig,
		HTTPOrigin:             httpOrigin,
		OAuthFeatureConfig:     oAuthFeatureConfig,
		IdentityFeatureConfig:  identityFeatureConfig,
		OAuthClientCredentials: oAuthClientCredentials,
		Logger:                 tokenHandlerLogger,
		Authorizations:         authorizationService,
		CodeGrants:             store,
		OfflineGrants:          store,
		AppSessionTokens:       store,
		OfflineGrantService:    offlineGrantService,
		Graphs:                 interactionService,
		IDTokenIssuer:          idTokenIssuer,
		Clock:                  clockClock,
		TokenService:           tokenService,
		Events:                 eventService,
		SessionManager:         manager2,
		App2App:                app2appProvider,
		Challenges:             challengeProvider,
		CodeGrantService:       codeGrantService,
		ClientResolver:         resolver,
	}
	appSessionTokenHandler := &oauth.AppSessionTokenHandler{
		Database:         handle,
		JSON:             jsonResponseWriter,
		AppSessionTokens: tokenHandler,
	}
	return appSessionTokenHandler
}

func newOAuthProxyRedirectHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	oAuthConfig := appConfig.OAuth
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	proxyRedirectHandler := &handler.ProxyRedirectHandler{
		OAuthConfig: oAuthConfig,
		HTTPOrigin:  httpOrigin,
	}
	oauthProxyRedirectHandler := &oauth.ProxyRedirectHandler{
		ProxyRedirectHandler: proxyRedirectHandler,
	}
	return oauthProxyRedirectHandler
}

func newSIWENonceHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	nonceHandlerLogger := siwe3.NewNonceHandlerLogger(factory)
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	web3Config := appConfig.Web3
	authenticationConfig := appConfig.Authentication
	clockClock := _wireSystemClockValue
	contextContext := deps.ProvideRequestContext(request)
	handle := appProvider.Redis
	appID := appConfig.ID
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	featureConfig := config.FeatureConfig
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	nonceHandler := &siwe3.NonceHandler{
		Logger: nonceHandlerLogger,
		SIWE:   siweService,
		JSON:   jsonResponseWriter,
	}
	return nonceHandler
}

func newAPIAnonymousUserSignupHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	anonymousUserSignupAPIHandlerLogger := api.NewAnonymousUserSignupAPIHandlerLogger(factory)
	handle := appProvider.AppDatabase
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	oAuthConfig := appConfig.OAuth
	anonymousUserHandlerLogger := handler.NewAnonymousUserHandlerLogger(factory)
	logger := interaction.NewLogger(factory)
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	clockClock := _wireSystemClockValue
	featureConfig := config.FeatureConfig
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	resolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	appredisHandle := appProvider.Redis
	redisLogger := redis.NewLogger(factory)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	store := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	eventLogger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	userStore := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: userStore,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	templateResolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: templateResolver,
	}
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         userStore,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   userStore,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              userStore,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: userStore,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         userStore,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: resolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   store,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             resolver,
		OfflineGrants:                   store,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef,
		MFADeviceTokenCookie:            mfaCookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  logger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	authorizationService := &oauth2.AuthorizationService{
		AppID:               appID,
		Store:               authorizationStore,
		Clock:               clockClock,
		OAuthSessionManager: sessionManager,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	accessTokenEncoding := &oauth2.AccessTokenEncoding{
		Secrets:    oAuthKeyMaterials,
		Clock:      clockClock,
		UserClaims: idTokenIssuer,
		BaseURL:    endpointsEndpoints,
		Events:     eventService,
	}
	tokenGenerator := _wireTokenGeneratorValue
	tokenService := handler.TokenService{
		RemoteIP:            remoteIP,
		UserAgentString:     userAgentString,
		AppID:               appID,
		Config:              oAuthConfig,
		Authorizations:      authorizationStore,
		OfflineGrants:       store,
		AccessGrants:        store,
		OfflineGrantService: offlineGrantService,
		AccessEvents:        eventProvider,
		AccessTokenIssuer:   accessTokenEncoding,
		GenerateToken:       tokenGenerator,
		Clock:               clockClock,
		Users:               queries,
	}
	anonymousUserHandler := &handler.AnonymousUserHandler{
		AppID:               appID,
		OAuthConfig:         oAuthConfig,
		Logger:              anonymousUserHandlerLogger,
		Graphs:              interactionService,
		Authorizations:      authorizationService,
		Clock:               clockClock,
		TokenService:        tokenService,
		UserProvider:        queries,
		AnonymousIdentities: anonymousProvider,
		PromotionCodes:      anonymousStoreRedis,
		OAuthClientResolver: resolver,
	}
	anonymousUserSignupAPIHandler := &api.AnonymousUserSignupAPIHandler{
		Logger:               anonymousUserSignupAPIHandlerLogger,
		Database:             handle,
		JSON:                 jsonResponseWriter,
		AnonymousUserHandler: anonymousUserHandler,
	}
	return anonymousUserSignupAPIHandler
}

func newAPIAnonymousUserPromotionCodeHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	anonymousUserPromotionCodeAPIHandlerLogger := api.NewAnonymousUserPromotionCodeAPILogger(factory)
	handle := appProvider.AppDatabase
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	oAuthConfig := appConfig.OAuth
	anonymousUserHandlerLogger := handler.NewAnonymousUserHandlerLogger(factory)
	logger := interaction.NewLogger(factory)
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	clockClock := _wireSystemClockValue
	featureConfig := config.FeatureConfig
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	resolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	appredisHandle := appProvider.Redis
	redisLogger := redis.NewLogger(factory)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	store := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	eventLogger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	userStore := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: userStore,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	templateResolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: templateResolver,
	}
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         userStore,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   userStore,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              userStore,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: userStore,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         userStore,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: resolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   store,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             resolver,
		OfflineGrants:                   store,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef,
		MFADeviceTokenCookie:            mfaCookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  logger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	authorizationService := &oauth2.AuthorizationService{
		AppID:               appID,
		Store:               authorizationStore,
		Clock:               clockClock,
		OAuthSessionManager: sessionManager,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	accessTokenEncoding := &oauth2.AccessTokenEncoding{
		Secrets:    oAuthKeyMaterials,
		Clock:      clockClock,
		UserClaims: idTokenIssuer,
		BaseURL:    endpointsEndpoints,
		Events:     eventService,
	}
	tokenGenerator := _wireTokenGeneratorValue
	tokenService := handler.TokenService{
		RemoteIP:            remoteIP,
		UserAgentString:     userAgentString,
		AppID:               appID,
		Config:              oAuthConfig,
		Authorizations:      authorizationStore,
		OfflineGrants:       store,
		AccessGrants:        store,
		OfflineGrantService: offlineGrantService,
		AccessEvents:        eventProvider,
		AccessTokenIssuer:   accessTokenEncoding,
		GenerateToken:       tokenGenerator,
		Clock:               clockClock,
		Users:               queries,
	}
	anonymousUserHandler := &handler.AnonymousUserHandler{
		AppID:               appID,
		OAuthConfig:         oAuthConfig,
		Logger:              anonymousUserHandlerLogger,
		Graphs:              interactionService,
		Authorizations:      authorizationService,
		Clock:               clockClock,
		TokenService:        tokenService,
		UserProvider:        queries,
		AnonymousIdentities: anonymousProvider,
		PromotionCodes:      anonymousStoreRedis,
		OAuthClientResolver: resolver,
	}
	anonymousUserPromotionCodeAPIHandler := &api.AnonymousUserPromotionCodeAPIHandler{
		Logger:         anonymousUserPromotionCodeAPIHandlerLogger,
		Database:       handle,
		JSON:           jsonResponseWriter,
		PromotionCodes: anonymousUserHandler,
	}
	return anonymousUserPromotionCodeAPIHandler
}

func newAPIPresignImagesUploadHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	appContext := appProvider.AppContext
	manager := appContext.Resources
	config := appContext.Config
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	responseWriter := &webapp.ResponseWriter{
		JSONResponseWriter: jsonResponseWriter,
		Renderer:           responseRenderer,
	}
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	appConfig := config.AppConfig
	appID := appConfig.ID
	logger := ratelimit.NewLogger(factory)
	handle := appProvider.Redis
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	featureConfig := config.FeatureConfig
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	secretConfig := config.SecretConfig
	imagesKeyMaterials := deps.ProvideImagesKeyMaterials(secretConfig)
	clockClock := _wireSystemClockValue
	provider := &presign.Provider{
		Secret: imagesKeyMaterials,
		Clock:  clockClock,
		Host:   httpHost,
	}
	presignImagesUploadHandlerLogger := api.NewPresignImagesUploadHandlerLogger(factory)
	presignImagesUploadHandler := &api.PresignImagesUploadHandler{
		Turbo:           responseWriter,
		HTTPProto:       httpProto,
		HTTPHost:        httpHost,
		AppID:           appID,
		RateLimiter:     limiter,
		PresignProvider: provider,
		Logger:          presignImagesUploadHandlerLogger,
	}
	return presignImagesUploadHandler
}

func newWebAppOAuthEntrypointHandler(p *deps.RequestProvider) http.Handler {
	oAuthEntrypointHandler := &webapp.OAuthEntrypointHandler{}
	return oAuthEntrypointHandler
}

func newWebAppRootHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	authenticationConfig := appConfig.Authentication
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	rootHandler := &webapp.RootHandler{
		AuthenticationConfig: authenticationConfig,
		Cookies:              cookieManager,
		SignedUpCookie:       signedUpCookieDef,
	}
	return rootHandler
}

func newWebAppLoginHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	authenticationViewModeler := &viewmodels.AuthenticationViewModeler{
		Authentication: authenticationConfig,
		LoginID:        loginIDConfig,
	}
	formPrefiller := &webapp.FormPrefiller{
		LoginID: loginIDConfig,
		UI:      uiConfig,
	}
	analyticredisHandle := appProvider.AnalyticRedis
	meterStoreRedisLogger := meter.NewStoreRedisLogger(factory)
	writeStoreRedis := &meter.WriteStoreRedis{
		Context: contextContext,
		Redis:   analyticredisHandle,
		AppID:   appID,
		Clock:   clockClock,
		Logger:  meterStoreRedisLogger,
	}
	meterService := &meter.Service{
		Counter: writeStoreRedis,
	}
	tutorialCookie := &httputil.TutorialCookie{
		Cookies: cookieManager,
	}
	loginHandler := &webapp.LoginHandler{
		ControllerFactory:       controllerFactory,
		BaseViewModel:           baseViewModeler,
		AuthenticationViewModel: authenticationViewModeler,
		FormPrefiller:           formPrefiller,
		Renderer:                responseRenderer,
		MeterService:            meterService,
		TutorialCookie:          tutorialCookie,
		ErrorCookie:             errorCookie,
	}
	return loginHandler
}

func newWebAppSignupHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	authenticationViewModeler := &viewmodels.AuthenticationViewModeler{
		Authentication: authenticationConfig,
		LoginID:        loginIDConfig,
	}
	formPrefiller := &webapp.FormPrefiller{
		LoginID: loginIDConfig,
		UI:      uiConfig,
	}
	analyticredisHandle := appProvider.AnalyticRedis
	meterStoreRedisLogger := meter.NewStoreRedisLogger(factory)
	writeStoreRedis := &meter.WriteStoreRedis{
		Context: contextContext,
		Redis:   analyticredisHandle,
		AppID:   appID,
		Clock:   clockClock,
		Logger:  meterStoreRedisLogger,
	}
	meterService := &meter.Service{
		Counter: writeStoreRedis,
	}
	tutorialCookie := &httputil.TutorialCookie{
		Cookies: cookieManager,
	}
	signupHandler := &webapp.SignupHandler{
		ControllerFactory:       controllerFactory,
		BaseViewModel:           baseViewModeler,
		AuthenticationViewModel: authenticationViewModeler,
		FormPrefiller:           formPrefiller,
		Renderer:                responseRenderer,
		MeterService:            meterService,
		TutorialCookie:          tutorialCookie,
	}
	return signupHandler
}

func newWebAppPromoteHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	authenticationViewModeler := &viewmodels.AuthenticationViewModeler{
		Authentication: authenticationConfig,
		LoginID:        loginIDConfig,
	}
	formPrefiller := &webapp.FormPrefiller{
		LoginID: loginIDConfig,
		UI:      uiConfig,
	}
	anonymousUserPromotionService := &webapp2.AnonymousUserPromotionService{
		Anonymous: anonymousProvider,
		Clock:     clockClock,
	}
	promoteHandler := &webapp.PromoteHandler{
		ControllerFactory:             controllerFactory,
		BaseViewModel:                 baseViewModeler,
		AuthenticationViewModel:       authenticationViewModeler,
		FormPrefiller:                 formPrefiller,
		Renderer:                      responseRenderer,
		AnonymousUserPromotionService: anonymousUserPromotionService,
	}
	return promoteHandler
}

func newWebAppSelectAccountHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	selectAccountHandler := &webapp.SelectAccountHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		Renderer:                  responseRenderer,
		AuthenticationConfig:      authenticationConfig,
		SignedUpCookie:            signedUpCookieDef,
		Users:                     queries,
		Identities:                serviceService,
		AuthenticationInfoService: authenticationinfoStoreRedis,
		UIInfoResolver:            uiInfoResolver,
		Cookies:                   cookieManager,
		OAuthConfig:               oAuthConfig,
		UIConfig:                  uiConfig,
		OAuthClientResolver:       oauthclientResolver,
	}
	return selectAccountHandler
}

func newWebAppSSOCallbackHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	authflowControllerLogger := webapp.NewAuthflowControllerLogger(factory)
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	errorCookieDef := webapp2.NewErrorCookieDef()
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	clockClock := _wireSystemClockValue
	appID := appConfig.ID
	handle := appProvider.Redis
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: handle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	contextContext := deps.ProvideRequestContext(request)
	featureConfig := config.FeatureConfig
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	appdbHandle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	logger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	workflowVerificationFacade := facade.WorkflowVerificationFacade{
		Verification: verificationService,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	accountMigrationConfig := appConfig.AccountMigration
	accountMigrationHookConfig := accountMigrationConfig.Hook
	hookDenoClient := accountmigration.NewHookDenoClient(denoEndpoint, hookLogger, accountMigrationHookConfig)
	denoMiddlewareLogger := accountmigration.NewDenoMiddlewareLogger(factory)
	accountMigrationDenoHook := &accountmigration.AccountMigrationDenoHook{
		DenoHook: denoHook,
		Client:   hookDenoClient,
		Logger:   denoMiddlewareLogger,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := accountmigration.NewHookHTTPClient(accountMigrationHookConfig)
	webhookMiddlewareLogger := accountmigration.NewWebhookMiddlewareLogger(factory)
	accountMigrationWebHook := &accountmigration.AccountMigrationWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
		Logger:  webhookMiddlewareLogger,
	}
	accountmigrationService := &accountmigration.Service{
		Config:   accountMigrationHookConfig,
		DenoHook: accountMigrationDenoHook,
		WebHook:  accountMigrationWebHook,
	}
	captchaConfig := appConfig.Captcha
	providerLogger := captcha.NewProviderLogger(factory)
	captchaCloudflareCredentials := deps.ProvideCaptchaCloudflareCredentials(secretConfig)
	cloudflareClient := captcha2.NewCloudflareClient(captchaCloudflareCredentials)
	captchaProvider := &captcha.Provider{
		RemoteIP:         remoteIP,
		Config:           captchaConfig,
		Logger:           providerLogger,
		CloudflareClient: cloudflareClient,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	requestOptionsService := &passkey2.RequestOptionsService{
		ConfigService:   configService,
		IdentityService: serviceService,
		Store:           store2,
	}
	creationOptionsService := &passkey2.CreationOptionsService{
		ConfigService:   configService,
		UserService:     queries,
		IdentityService: serviceService,
		Store:           store2,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	authenticationflowStoreImpl := &authenticationflow.StoreImpl{
		Redis:   handle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := authenticationflow.NewEventStore(appID, handle, authenticationflowStoreImpl)
	dependencies := &authenticationflow.Dependencies{
		Config:                        appConfig,
		FeatureConfig:                 featureConfig,
		Clock:                         clockClock,
		RemoteIP:                      remoteIP,
		HTTPOrigin:                    httpOrigin,
		HTTPRequest:                   request,
		Users:                         userProvider,
		Identities:                    identityFacade,
		Authenticators:                authenticatorFacade,
		MFA:                           mfaFacade,
		StdAttrsService:               stdattrsService,
		CustomAttrsService:            customattrsService,
		OTPCodes:                      otpService,
		OTPSender:                     messageSender,
		Verification:                  workflowVerificationFacade,
		ForgotPassword:                forgotpasswordService,
		ResetPassword:                 forgotpasswordService,
		AccountMigrations:             accountmigrationService,
		Captcha:                       captchaProvider,
		OAuthProviderFactory:          oAuthProviderFactory,
		PasskeyRequestOptionsService:  requestOptionsService,
		PasskeyCreationOptionsService: creationOptionsService,
		PasskeyService:                passkeyService,
		IDPSessions:                   idpsessionProvider,
		Sessions:                      manager2,
		AuthenticationInfos:           authenticationinfoStoreRedis,
		SessionCookie:                 cookieDef,
		MFADeviceTokenCookie:          mfaCookieDef,
		Cookies:                       cookieManager,
		Events:                        eventService,
		RateLimiter:                   limiter,
		FlowEvents:                    eventStoreImpl,
		OfflineGrants:                 redisStore,
	}
	authenticationflowServiceLogger := authenticationflow.NewServiceLogger(factory)
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	authenticationflowService := &authenticationflow.Service{
		ContextDoNotUseDirectly: contextContext,
		Deps:                    dependencies,
		Logger:                  authenticationflowServiceLogger,
		Store:                   authenticationflowStoreImpl,
		Database:                appdbHandle,
		UIInfoResolver:          uiInfoResolver,
	}
	oauthsessionStoreRedis := &oauthsession.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	uiConfig := appConfig.UI
	authflowController := &webapp.AuthflowController{
		Logger:                  authflowControllerLogger,
		TesterEndpointsProvider: endpointsEndpoints,
		ErrorCookie:             errorCookie,
		TrustProxy:              trustProxy,
		Clock:                   clockClock,
		Cookies:                 cookieManager,
		Sessions:                sessionStoreRedis,
		SessionCookie:           sessionCookieDef,
		Authflows:               authenticationflowService,
		OAuthSessions:           oauthsessionStoreRedis,
		UIInfoResolver:          uiInfoResolver,
		UIConfig:                uiConfig,
		OAuthClientResolver:     oauthclientResolver,
	}
	webappServiceLogger := webapp2.NewServiceLogger(factory)
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	interactionLogger := interaction.NewLogger(factory)
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef,
		MFADeviceTokenCookie:            mfaCookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: handle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               webappServiceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: mfaCookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, handle)
	controllerDeps := webapp.ControllerDeps{
		Database:                appdbHandle,
		RedisHandle:             handle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	ssoCallbackHandler := &webapp.SSOCallbackHandler{
		AuthflowController: authflowController,
		ControllerFactory:  controllerFactory,
	}
	return ssoCallbackHandler
}

func newWechatAuthHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	wechatAuthHandler := &webapp.WechatAuthHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		IdentityConfig:    identityConfig,
	}
	return wechatAuthHandler
}

func newWechatCallbackHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	wechatCallbackHandler := &webapp.WechatCallbackHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		JSON:              jsonResponseWriter,
	}
	return wechatCallbackHandler
}

func newWebAppEnterLoginIDHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	authenticationViewModeler := &viewmodels.AuthenticationViewModeler{
		Authentication: authenticationConfig,
		LoginID:        loginIDConfig,
	}
	enterLoginIDHandler := &webapp.EnterLoginIDHandler{
		ControllerFactory:       controllerFactory,
		BaseViewModel:           baseViewModeler,
		AuthenticationViewModel: authenticationViewModeler,
		Renderer:                responseRenderer,
		Identities:              serviceService,
	}
	return enterLoginIDHandler
}

func newWebAppEnterPasswordHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	enterPasswordHandler := &webapp.EnterPasswordHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
	}
	return enterPasswordHandler
}

func newWebConfirmTerminateOtherSessionsHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	confirmTerminateOtherSessionsHandler := &webapp.ConfirmTerminateOtherSessionsHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
	}
	return confirmTerminateOtherSessionsHandler
}

func newWebAppUsePasskeyHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	usePasskeyHandler := &webapp.UsePasskeyHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
	}
	return usePasskeyHandler
}

func newWebAppCreatePasswordHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	createPasswordHandler := &webapp.CreatePasswordHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
		PasswordPolicy:            passwordChecker,
	}
	return createPasswordHandler
}

func newWebAppCreatePasskeyHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	createPasskeyHandler := &webapp.CreatePasskeyHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
	}
	return createPasskeyHandler
}

func newWebAppPromptCreatePasskeyHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	promptCreatePasskeyHandler := &webapp.PromptCreatePasskeyHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
	}
	return promptCreatePasskeyHandler
}

func newWebAppSetupTOTPHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	setupTOTPHandler := &webapp.SetupTOTPHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
		Clock:                     clockClock,
		Endpoints:                 endpointsEndpoints,
	}
	return setupTOTPHandler
}

func newWebAppEnterTOTPHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	enterTOTPHandler := &webapp.EnterTOTPHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
	}
	return enterTOTPHandler
}

func newWebAppSetupOOBOTPHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	setupOOBOTPHandler := &webapp.SetupOOBOTPHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
	}
	return setupOOBOTPHandler
}

func newWebAppEnterOOBOTPHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	enterOOBOTPHandler := &webapp.EnterOOBOTPHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
		FlashMessage:              flashMessage,
		OTPCodeService:            otpService,
		Clock:                     clockClock,
		Config:                    appConfig,
	}
	return enterOOBOTPHandler
}

func newWebAppSetupWhatsappOTPHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	setupWhatsappOTPHandler := &webapp.SetupWhatsappOTPHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
	}
	return setupWhatsappOTPHandler
}

func newWebAppWhatsappOTPHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	clockClock := _wireSystemClockValue
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	whatsappOTPHandler := &webapp.WhatsappOTPHandler{
		Config:                    appConfig,
		Clock:                     clockClock,
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
		OTPCodeService:            otpService,
		FlashMessage:              flashMessage,
	}
	return whatsappOTPHandler
}

func newWebAppSetupLoginLinkOTPHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	setupLoginLinkOTPHandler := &webapp.SetupLoginLinkOTPHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
	}
	return setupLoginLinkOTPHandler
}

func newWebAppLoginLinkOTPHandler(p *deps.RequestProvider) http.Handler {
	clockClock := _wireSystemClockValue
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	featureConfig := config.FeatureConfig
	testModeFeatureConfig := featureConfig.TestMode
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	handle := appProvider.Redis
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	factory := appProvider.LoggerFactory
	logger := otp.NewLogger(factory)
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                logger,
		RateLimiter:           limiter,
	}
	appdbHandle := appProvider.AppDatabase
	serviceLogger := webapp2.NewServiceLogger(factory)
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: handle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: handle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, handle)
	controllerDeps := webapp.ControllerDeps{
		Database:                appdbHandle,
		RedisHandle:             handle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	loginLinkOTPHandler := &webapp.LoginLinkOTPHandler{
		Clock:                     clockClock,
		LoginLinkOTPCodeService:   otpService,
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
		FlashMessage:              flashMessage,
		Config:                    appConfig,
	}
	return loginLinkOTPHandler
}

func newWebAppVerifyLoginLinkOTPHandler(p *deps.RequestProvider) http.Handler {
	clockClock := _wireSystemClockValue
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	featureConfig := config.FeatureConfig
	testModeFeatureConfig := featureConfig.TestMode
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	handle := appProvider.Redis
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	factory := appProvider.LoggerFactory
	logger := otp.NewLogger(factory)
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                logger,
		RateLimiter:           limiter,
	}
	globalSessionServiceFactory := &webapp.GlobalSessionServiceFactory{
		Clock:       clockClock,
		RedisHandle: handle,
	}
	appdbHandle := appProvider.AppDatabase
	serviceLogger := webapp2.NewServiceLogger(factory)
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: handle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: handle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, handle)
	controllerDeps := webapp.ControllerDeps{
		Database:                appdbHandle,
		RedisHandle:             handle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	authenticationViewModeler := &viewmodels.AuthenticationViewModeler{
		Authentication: authenticationConfig,
		LoginID:        loginIDConfig,
	}
	workflowStoreImpl := &workflow.StoreImpl{
		Redis:   handle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := workflow.NewEventStore(appID, handle, workflowStoreImpl)
	authenticationflowStoreImpl := &authenticationflow.StoreImpl{
		Redis:   handle,
		AppID:   appID,
		Context: contextContext,
	}
	authenticationflowEventStoreImpl := authenticationflow.NewEventStore(appID, handle, authenticationflowStoreImpl)
	verifyLoginLinkOTPHandler := &webapp.VerifyLoginLinkOTPHandler{
		LoginLinkOTPCodeService:     otpService,
		GlobalSessionServiceFactory: globalSessionServiceFactory,
		ControllerFactory:           controllerFactory,
		BaseViewModel:               baseViewModeler,
		AuthenticationViewModel:     authenticationViewModeler,
		Renderer:                    responseRenderer,
		WorkflowEvents:              eventStoreImpl,
		AuthenticationFlowEvents:    authenticationflowEventStoreImpl,
		Config:                      appConfig,
	}
	return verifyLoginLinkOTPHandler
}

func newWebAppEnterRecoveryCodeHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	enterRecoveryCodeHandler := &webapp.EnterRecoveryCodeHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
	}
	return enterRecoveryCodeHandler
}

func newWebAppSetupRecoveryCodeHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	setupRecoveryCodeHandler := &webapp.SetupRecoveryCodeHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
	}
	return setupRecoveryCodeHandler
}

func newWebAppVerifyIdentityHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	verifyIdentityHandler := &webapp.VerifyIdentityHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		FlashMessage:      flashMessage,
		OTPCodeService:    otpService,
		Clock:             clockClock,
		Config:            appConfig,
	}
	return verifyIdentityHandler
}

func newWebAppVerifyIdentitySuccessHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	verifyIdentitySuccessHandler := &webapp.VerifyIdentitySuccessHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
	}
	return verifyIdentitySuccessHandler
}

func newWebAppForgotPasswordHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	authenticationViewModeler := &viewmodels.AuthenticationViewModeler{
		Authentication: authenticationConfig,
		LoginID:        loginIDConfig,
	}
	formPrefiller := &webapp.FormPrefiller{
		LoginID: loginIDConfig,
		UI:      uiConfig,
	}
	forgotPasswordHandler := &webapp.ForgotPasswordHandler{
		ControllerFactory:       controllerFactory,
		BaseViewModel:           baseViewModeler,
		AuthenticationViewModel: authenticationViewModeler,
		FormPrefiller:           formPrefiller,
		Renderer:                responseRenderer,
	}
	return forgotPasswordHandler
}

func newWebAppForgotPasswordSuccessHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	forgotPasswordSuccessHandler := &webapp.ForgotPasswordSuccessHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
	}
	return forgotPasswordSuccessHandler
}

func newWebAppResetPasswordHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	resetPasswordHandler := &webapp.ResetPasswordHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		PasswordPolicy:    passwordChecker,
		ResetPassword:     forgotpasswordService,
	}
	return resetPasswordHandler
}

func newWebAppResetPasswordSuccessHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	resetPasswordSuccessHandler := &webapp.ResetPasswordSuccessHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
	}
	return resetPasswordSuccessHandler
}

func newWebAppSettingsHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	authenticationViewModeler := &viewmodels.AuthenticationViewModeler{
		Authentication: authenticationConfig,
		LoginID:        loginIDConfig,
	}
	biometricConfig := identityConfig.Biometric
	settingsViewModeler := &viewmodels.SettingsViewModeler{
		Authenticators: service3,
		MFA:            mfaService,
		Authentication: authenticationConfig,
		Biometric:      biometricConfig,
	}
	facadeIdentityFacade := &facade.IdentityFacade{
		Coordinator: coordinator,
	}
	settingsProfileViewModeler := &viewmodels.SettingsProfileViewModeler{
		Localization:      localizationConfig,
		UserProfileConfig: userProfileConfig,
		Users:             queries,
		Identities:        facadeIdentityFacade,
		Clock:             clockClock,
	}
	tutorialCookie := &httputil.TutorialCookie{
		Cookies: cookieManager,
	}
	settingsHandler := &webapp.SettingsHandler{
		ControllerFactory:        controllerFactory,
		BaseViewModel:            baseViewModeler,
		AuthenticationViewModel:  authenticationViewModeler,
		SettingsViewModel:        settingsViewModeler,
		SettingsProfileViewModel: settingsProfileViewModeler,
		Renderer:                 responseRenderer,
		Identities:               serviceService,
		Verification:             verificationService,
		AccountDeletion:          accountDeletionConfig,
		AccountAnonymization:     accountAnonymizationConfig,
		TutorialCookie:           tutorialCookie,
	}
	return settingsHandler
}

func newWebAppSettingsProfileHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	facadeIdentityFacade := &facade.IdentityFacade{
		Coordinator: coordinator,
	}
	settingsProfileViewModeler := &viewmodels.SettingsProfileViewModeler{
		Localization:      localizationConfig,
		UserProfileConfig: userProfileConfig,
		Users:             queries,
		Identities:        facadeIdentityFacade,
		Clock:             clockClock,
	}
	settingsProfileHandler := &webapp.SettingsProfileHandler{
		ControllerFactory:        controllerFactory,
		BaseViewModel:            baseViewModeler,
		SettingsProfileViewModel: settingsProfileViewModeler,
		Renderer:                 responseRenderer,
	}
	return settingsProfileHandler
}

func newWebAppSettingsProfileEditHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	facadeIdentityFacade := &facade.IdentityFacade{
		Coordinator: coordinator,
	}
	settingsProfileViewModeler := &viewmodels.SettingsProfileViewModeler{
		Localization:      localizationConfig,
		UserProfileConfig: userProfileConfig,
		Users:             queries,
		Identities:        facadeIdentityFacade,
		Clock:             clockClock,
	}
	userFacade := &facade.UserFacade{
		UserProvider: userProvider,
		Coordinator:  coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	settingsProfileEditHandler := &webapp.SettingsProfileEditHandler{
		ControllerFactory:        controllerFactory,
		BaseViewModel:            baseViewModeler,
		SettingsProfileViewModel: settingsProfileViewModeler,
		Renderer:                 responseRenderer,
		Users:                    userFacade,
		StdAttrs:                 stdattrsService,
		CustomAttrs:              customattrsService,
		ErrorCookie:              errorCookie,
	}
	return settingsProfileEditHandler
}

func newWebAppSettingsIdentityHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	authenticationViewModeler := &viewmodels.AuthenticationViewModeler{
		Authentication: authenticationConfig,
		LoginID:        loginIDConfig,
	}
	settingsIdentityHandler := &webapp.SettingsIdentityHandler{
		ControllerFactory:       controllerFactory,
		BaseViewModel:           baseViewModeler,
		AuthenticationViewModel: authenticationViewModeler,
		Renderer:                responseRenderer,
		Identities:              serviceService,
		Verification:            verificationService,
		AccountDeletion:         accountDeletionConfig,
	}
	return settingsIdentityHandler
}

func newWebAppSettingsBiometricHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	settingsBiometricHandler := &webapp.SettingsBiometricHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		Identities:        serviceService,
	}
	return settingsBiometricHandler
}

func newWebAppSettingsMFAHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	biometricConfig := identityConfig.Biometric
	settingsViewModeler := &viewmodels.SettingsViewModeler{
		Authenticators: service3,
		MFA:            mfaService,
		Authentication: authenticationConfig,
		Biometric:      biometricConfig,
	}
	settingsMFAHandler := &webapp.SettingsMFAHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		SettingsViewModel: settingsViewModeler,
		Renderer:          responseRenderer,
		MFA:               mfaService,
	}
	return settingsMFAHandler
}

func newWebAppSettingsTOTPHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	settingsTOTPHandler := &webapp.SettingsTOTPHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		Authenticators:    service3,
	}
	return settingsTOTPHandler
}

func newWebAppSettingsPasskeyHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	settingsPasskeyHandler := &webapp.SettingsPasskeyHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		Identities:        serviceService,
	}
	return settingsPasskeyHandler
}

func newWebAppSettingsOOBOTPHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	settingsOOBOTPHandler := &webapp.SettingsOOBOTPHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		Authenticators:    service3,
	}
	return settingsOOBOTPHandler
}

func newWebAppSettingsRecoveryCodeHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	settingsRecoveryCodeHandler := &webapp.SettingsRecoveryCodeHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		Authentication:    authenticationConfig,
		MFA:               mfaService,
	}
	return settingsRecoveryCodeHandler
}

func newWebAppSettingsSessionsHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	authorizationService := &oauth2.AuthorizationService{
		AppID:               appID,
		Store:               authorizationStore,
		Clock:               clockClock,
		OAuthSessionManager: sessionManager,
	}
	oauthOfflineGrantService := &oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionListingService := &sessionlisting.SessionListingService{
		OAuthConfig:   oAuthConfig,
		IDPSessions:   idpsessionProvider,
		OfflineGrants: oauthOfflineGrantService,
	}
	settingsSessionsHandler := &webapp.SettingsSessionsHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		Sessions:          manager2,
		Authorizations:    authorizationService,
		OAuthConfig:       oAuthConfig,
		SessionListing:    sessionListingService,
	}
	return settingsSessionsHandler
}

func newWebAppForceChangePasswordHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	forceChangePasswordHandler := &webapp.ForceChangePasswordHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		PasswordPolicy:    passwordChecker,
	}
	return forceChangePasswordHandler
}

func newWebAppSettingsChangePasswordHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	settingsChangePasswordHandler := &webapp.SettingsChangePasswordHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		PasswordPolicy:    passwordChecker,
	}
	return settingsChangePasswordHandler
}

func newWebAppForceChangeSecondaryPasswordHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	forceChangeSecondaryPasswordHandler := &webapp.ForceChangeSecondaryPasswordHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		PasswordPolicy:    passwordChecker,
	}
	return forceChangeSecondaryPasswordHandler
}

func newWebAppSettingsChangeSecondaryPasswordHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	settingsChangeSecondaryPasswordHandler := &webapp.SettingsChangeSecondaryPasswordHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		PasswordPolicy:    passwordChecker,
	}
	return settingsChangeSecondaryPasswordHandler
}

func newWebAppSettingsDeleteAccountHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	userFacade := &facade.UserFacade{
		UserProvider: userProvider,
		Coordinator:  coordinator,
	}
	settingsDeleteAccountHandler := &webapp.SettingsDeleteAccountHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		AccountDeletion:   accountDeletionConfig,
		Clock:             clockClock,
		Users:             userFacade,
		Cookies:           cookieManager,
	}
	return settingsDeleteAccountHandler
}

func newWebAppSettingsDeleteAccountSuccessHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	settingsDeleteAccountSuccessHandler := &webapp.SettingsDeleteAccountSuccessHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
		AccountDeletion:   accountDeletionConfig,
		Clock:             clockClock,
	}
	return settingsDeleteAccountSuccessHandler
}

func newWebAppAccountStatusHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	accountStatusHandler := &webapp.AccountStatusHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
	}
	return accountStatusHandler
}

func newWebAppLogoutHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	logoutHandler := &webapp.LogoutHandler{
		ControllerFactory:   controllerFactory,
		Database:            handle,
		TrustProxy:          trustProxy,
		OAuth:               oAuthConfig,
		UIConfig:            uiConfig,
		SessionManager:      manager2,
		BaseViewModel:       baseViewModeler,
		Renderer:            responseRenderer,
		OAuthClientResolver: oauthclientResolver,
	}
	return logoutHandler
}

func newWebAppAppStaticAssetsHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	manager := appContext.Resources
	appStaticAssetsHandler := &webapp.AppStaticAssetsHandler{
		Resources: manager,
	}
	return appStaticAssetsHandler
}

func newWebAppReturnHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	returnHandler := &webapp.ReturnHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
	}
	return returnHandler
}

func newWebAppErrorHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	errorHandler := &webapp.ErrorHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
	}
	return errorHandler
}

func newWebAppNotFoundHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	notFoundHandler := &webapp.NotFoundHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
	}
	return notFoundHandler
}

func newWebAppWebsocketHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	factory := appProvider.LoggerFactory
	handle := appProvider.Redis
	publisher := webapp.NewPublisher(appID, handle)
	websocketHandler := &webapp.WebsocketHandler{
		AppID:         appID,
		LoggerFactory: factory,
		RedisHandle:   handle,
		Publisher:     publisher,
	}
	return websocketHandler
}

func newWebAppPasskeyCreationOptionsHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	handle := appProvider.Redis
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: handle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	appdbHandle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: handle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	creationOptionsService := &passkey2.CreationOptionsService{
		ConfigService:   configService,
		UserService:     queries,
		IdentityService: serviceService,
		Store:           store2,
	}
	passkeyCreationOptionsHandler := &webapp.PasskeyCreationOptionsHandler{
		Page:     webappService2,
		Database: appdbHandle,
		JSON:     jsonResponseWriter,
		Passkey:  creationOptionsService,
	}
	return passkeyCreationOptionsHandler
}

func newWebAppPasskeyRequestOptionsHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	handle := appProvider.Redis
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: handle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	appdbHandle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: handle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	requestOptionsService := &passkey2.RequestOptionsService{
		ConfigService:   configService,
		IdentityService: serviceService,
		Store:           store2,
	}
	passkeyRequestOptionsHandler := &webapp.PasskeyRequestOptionsHandler{
		Page:     webappService2,
		Database: appdbHandle,
		JSON:     jsonResponseWriter,
		Passkey:  requestOptionsService,
	}
	return passkeyRequestOptionsHandler
}

func newWebAppConnectWeb3AccountHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	authenticationViewModeler := &viewmodels.AuthenticationViewModeler{
		Authentication: authenticationConfig,
		LoginID:        loginIDConfig,
	}
	alternativeStepsViewModeler := &viewmodels.AlternativeStepsViewModeler{
		AuthenticationConfig: authenticationConfig,
	}
	connectWeb3AccountHandler := &webapp.ConnectWeb3AccountHandler{
		ControllerFactory:         controllerFactory,
		BaseViewModel:             baseViewModeler,
		AuthenticationViewModel:   authenticationViewModeler,
		AlternativeStepsViewModel: alternativeStepsViewModeler,
		Renderer:                  responseRenderer,
		AuthenticationConfig:      authenticationConfig,
	}
	return connectWeb3AccountHandler
}

func newWebAppMissingWeb3WalletHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	missingWeb3WalletHandler := &webapp.MissingWeb3WalletHandler{
		ControllerFactory:    controllerFactory,
		BaseViewModel:        baseViewModeler,
		Renderer:             responseRenderer,
		AuthenticationConfig: authenticationConfig,
	}
	return missingWeb3WalletHandler
}

func newWebAppFeatureDisabledHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	featureDisabledHandler := &webapp.FeatureDisabledHandler{
		ControllerFactory: controllerFactory,
		BaseViewModel:     baseViewModeler,
		Renderer:          responseRenderer,
	}
	return featureDisabledHandler
}

func newWebAppTesterHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	factory := appProvider.LoggerFactory
	handle := appProvider.AppDatabase
	appredisHandle := appProvider.Redis
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	publisher := webapp.NewPublisher(appID, appredisHandle)
	controllerDeps := webapp.ControllerDeps{
		Database:                handle,
		RedisHandle:             appredisHandle,
		AppID:                   appID,
		Page:                    webappService2,
		BaseViewModel:           baseViewModeler,
		Renderer:                responseRenderer,
		Publisher:               publisher,
		Clock:                   clockClock,
		UIConfig:                uiConfig,
		ErrorCookie:             errorCookie,
		TesterEndpointsProvider: endpointsEndpoints,
		TrustProxy:              trustProxy,
	}
	controllerFactory := webapp.ControllerFactory{
		LoggerFactory:  factory,
		ControllerDeps: controllerDeps,
	}
	globalredisHandle := appProvider.GlobalRedis
	testerStore := &tester.TesterStore{
		Context: contextContext,
		Redis:   globalredisHandle,
	}
	oAuthFeatureConfig := featureConfig.OAuth
	oAuthClientCredentials := deps.ProvideOAuthClientCredentials(secretConfig)
	tokenHandlerLogger := handler.NewTokenHandlerLogger(factory)
	authorizationService := &oauth2.AuthorizationService{
		AppID:               appID,
		Store:               authorizationStore,
		Clock:               clockClock,
		OAuthSessionManager: sessionManager,
	}
	accessTokenEncoding := &oauth2.AccessTokenEncoding{
		Secrets:    oAuthKeyMaterials,
		Clock:      clockClock,
		UserClaims: idTokenIssuer,
		BaseURL:    endpointsEndpoints,
		Events:     eventService,
	}
	tokenGenerator := _wireTokenGeneratorValue
	tokenService := handler.TokenService{
		RemoteIP:            remoteIP,
		UserAgentString:     userAgentString,
		AppID:               appID,
		Config:              oAuthConfig,
		Authorizations:      authorizationStore,
		OfflineGrants:       redisStore,
		AccessGrants:        redisStore,
		OfflineGrantService: offlineGrantService,
		AccessEvents:        eventProvider,
		AccessTokenIssuer:   accessTokenEncoding,
		GenerateToken:       tokenGenerator,
		Clock:               clockClock,
		Users:               queries,
	}
	app2appProvider := &app2app.Provider{
		Clock: clockClock,
	}
	codeGrantService := handler.CodeGrantService{
		AppID:         appID,
		CodeGenerator: tokenGenerator,
		Clock:         clockClock,
		CodeGrants:    redisStore,
	}
	tokenHandler := &handler.TokenHandler{
		AppID:                  appID,
		Config:                 oAuthConfig,
		HTTPOrigin:             httpOrigin,
		OAuthFeatureConfig:     oAuthFeatureConfig,
		IdentityFeatureConfig:  identityFeatureConfig,
		OAuthClientCredentials: oAuthClientCredentials,
		Logger:                 tokenHandlerLogger,
		Authorizations:         authorizationService,
		CodeGrants:             redisStore,
		OfflineGrants:          redisStore,
		AppSessionTokens:       redisStore,
		OfflineGrantService:    offlineGrantService,
		Graphs:                 interactionService,
		IDTokenIssuer:          idTokenIssuer,
		Clock:                  clockClock,
		TokenService:           tokenService,
		Events:                 eventService,
		SessionManager:         manager2,
		App2App:                app2appProvider,
		Challenges:             challengeProvider,
		CodeGrantService:       codeGrantService,
		ClientResolver:         oauthclientResolver,
	}
	oauthOfflineGrantService := &oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	appSessionTokenService := &oauth2.AppSessionTokenService{
		AppSessions:         redisStore,
		AppSessionTokens:    redisStore,
		OfflineGrants:       redisStore,
		OfflineGrantService: oauthOfflineGrantService,
		Cookies:             cookieManager,
		Clock:               clockClock,
	}
	testerHandler := &webapp.TesterHandler{
		AppID:                   appID,
		ControllerFactory:       controllerFactory,
		OauthEndpointsProvider:  endpointsEndpoints,
		TesterEndpointsProvider: endpointsEndpoints,
		TesterService:           testerStore,
		TesterTokenIssuer:       tokenHandler,
		OAuthClientResolver:     oauthclientResolver,
		AppSessionTokenService:  appSessionTokenService,
		CookieManager:           cookieManager,
		Renderer:                responseRenderer,
		BaseViewModel:           baseViewModeler,
		UserInfoProvider:        idTokenIssuer,
		OfflineGrants:           redisStore,
	}
	return testerHandler
}

func newAPIWorkflowNewHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	contextContext := deps.ProvideRequestContext(request)
	featureConfig := config.FeatureConfig
	clockClock := _wireSystemClockValue
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	appID := appConfig.ID
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	handle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	logger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	appredisHandle := appProvider.Redis
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	workflowVerificationFacade := facade.WorkflowVerificationFacade{
		Verification: verificationService,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	accountMigrationConfig := appConfig.AccountMigration
	accountMigrationHookConfig := accountMigrationConfig.Hook
	hookDenoClient := accountmigration.NewHookDenoClient(denoEndpoint, hookLogger, accountMigrationHookConfig)
	denoMiddlewareLogger := accountmigration.NewDenoMiddlewareLogger(factory)
	accountMigrationDenoHook := &accountmigration.AccountMigrationDenoHook{
		DenoHook: denoHook,
		Client:   hookDenoClient,
		Logger:   denoMiddlewareLogger,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := accountmigration.NewHookHTTPClient(accountMigrationHookConfig)
	webhookMiddlewareLogger := accountmigration.NewWebhookMiddlewareLogger(factory)
	accountMigrationWebHook := &accountmigration.AccountMigrationWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
		Logger:  webhookMiddlewareLogger,
	}
	accountmigrationService := &accountmigration.Service{
		Config:   accountMigrationHookConfig,
		DenoHook: accountMigrationDenoHook,
		WebHook:  accountMigrationWebHook,
	}
	captchaConfig := appConfig.Captcha
	providerLogger := captcha.NewProviderLogger(factory)
	captchaCloudflareCredentials := deps.ProvideCaptchaCloudflareCredentials(secretConfig)
	cloudflareClient := captcha2.NewCloudflareClient(captchaCloudflareCredentials)
	captchaProvider := &captcha.Provider{
		RemoteIP:         remoteIP,
		Config:           captchaConfig,
		Logger:           providerLogger,
		CloudflareClient: cloudflareClient,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	workflowStoreImpl := &workflow.StoreImpl{
		Redis:   appredisHandle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := workflow.NewEventStore(appID, appredisHandle, workflowStoreImpl)
	dependencies := &workflow.Dependencies{
		Config:               appConfig,
		FeatureConfig:        featureConfig,
		Clock:                clockClock,
		RemoteIP:             remoteIP,
		HTTPRequest:          request,
		Users:                userProvider,
		Identities:           identityFacade,
		Authenticators:       authenticatorFacade,
		MFA:                  mfaFacade,
		StdAttrsService:      stdattrsService,
		CustomAttrsService:   customattrsService,
		OTPCodes:             otpService,
		OTPSender:            messageSender,
		Verification:         workflowVerificationFacade,
		ForgotPassword:       forgotpasswordService,
		ResetPassword:        forgotpasswordService,
		AccountMigrations:    accountmigrationService,
		Captcha:              captchaProvider,
		IDPSessions:          idpsessionProvider,
		Sessions:             manager2,
		AuthenticationInfos:  authenticationinfoStoreRedis,
		SessionCookie:        cookieDef,
		MFADeviceTokenCookie: mfaCookieDef,
		Cookies:              cookieManager,
		Events:               eventService,
		RateLimiter:          limiter,
		WorkflowEvents:       eventStoreImpl,
		OfflineGrants:        redisStore,
	}
	workflowServiceLogger := workflow.NewServiceLogger(factory)
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	workflowService := &workflow.Service{
		ContextDoNotUseDirectly: contextContext,
		Deps:                    dependencies,
		Logger:                  workflowServiceLogger,
		Store:                   workflowStoreImpl,
		Database:                handle,
		UIInfoResolver:          uiInfoResolver,
	}
	oauthsessionStoreRedis := &oauthsession.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	workflowNewHandler := &api.WorkflowNewHandler{
		JSON:           jsonResponseWriter,
		Cookies:        cookieManager,
		Workflows:      workflowService,
		OAuthSessions:  oauthsessionStoreRedis,
		UIInfoResolver: uiInfoResolver,
	}
	return workflowNewHandler
}

func newAPIWorkflowGetHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	request := p.Request
	contextContext := deps.ProvideRequestContext(request)
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	featureConfig := config.FeatureConfig
	clockClock := _wireSystemClockValue
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	appID := appConfig.ID
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	handle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	logger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	appredisHandle := appProvider.Redis
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	workflowVerificationFacade := facade.WorkflowVerificationFacade{
		Verification: verificationService,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	accountMigrationConfig := appConfig.AccountMigration
	accountMigrationHookConfig := accountMigrationConfig.Hook
	hookDenoClient := accountmigration.NewHookDenoClient(denoEndpoint, hookLogger, accountMigrationHookConfig)
	denoMiddlewareLogger := accountmigration.NewDenoMiddlewareLogger(factory)
	accountMigrationDenoHook := &accountmigration.AccountMigrationDenoHook{
		DenoHook: denoHook,
		Client:   hookDenoClient,
		Logger:   denoMiddlewareLogger,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := accountmigration.NewHookHTTPClient(accountMigrationHookConfig)
	webhookMiddlewareLogger := accountmigration.NewWebhookMiddlewareLogger(factory)
	accountMigrationWebHook := &accountmigration.AccountMigrationWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
		Logger:  webhookMiddlewareLogger,
	}
	accountmigrationService := &accountmigration.Service{
		Config:   accountMigrationHookConfig,
		DenoHook: accountMigrationDenoHook,
		WebHook:  accountMigrationWebHook,
	}
	captchaConfig := appConfig.Captcha
	providerLogger := captcha.NewProviderLogger(factory)
	captchaCloudflareCredentials := deps.ProvideCaptchaCloudflareCredentials(secretConfig)
	cloudflareClient := captcha2.NewCloudflareClient(captchaCloudflareCredentials)
	captchaProvider := &captcha.Provider{
		RemoteIP:         remoteIP,
		Config:           captchaConfig,
		Logger:           providerLogger,
		CloudflareClient: cloudflareClient,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	workflowStoreImpl := &workflow.StoreImpl{
		Redis:   appredisHandle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := workflow.NewEventStore(appID, appredisHandle, workflowStoreImpl)
	dependencies := &workflow.Dependencies{
		Config:               appConfig,
		FeatureConfig:        featureConfig,
		Clock:                clockClock,
		RemoteIP:             remoteIP,
		HTTPRequest:          request,
		Users:                userProvider,
		Identities:           identityFacade,
		Authenticators:       authenticatorFacade,
		MFA:                  mfaFacade,
		StdAttrsService:      stdattrsService,
		CustomAttrsService:   customattrsService,
		OTPCodes:             otpService,
		OTPSender:            messageSender,
		Verification:         workflowVerificationFacade,
		ForgotPassword:       forgotpasswordService,
		ResetPassword:        forgotpasswordService,
		AccountMigrations:    accountmigrationService,
		Captcha:              captchaProvider,
		IDPSessions:          idpsessionProvider,
		Sessions:             manager2,
		AuthenticationInfos:  authenticationinfoStoreRedis,
		SessionCookie:        cookieDef,
		MFADeviceTokenCookie: mfaCookieDef,
		Cookies:              cookieManager,
		Events:               eventService,
		RateLimiter:          limiter,
		WorkflowEvents:       eventStoreImpl,
		OfflineGrants:        redisStore,
	}
	workflowServiceLogger := workflow.NewServiceLogger(factory)
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	workflowService := &workflow.Service{
		ContextDoNotUseDirectly: contextContext,
		Deps:                    dependencies,
		Logger:                  workflowServiceLogger,
		Store:                   workflowStoreImpl,
		Database:                handle,
		UIInfoResolver:          uiInfoResolver,
	}
	workflowGetHandler := &api.WorkflowGetHandler{
		JSON:      jsonResponseWriter,
		Workflows: workflowService,
		Cookies:   cookieManager,
	}
	return workflowGetHandler
}

func newAPIWorkflowInputHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	request := p.Request
	contextContext := deps.ProvideRequestContext(request)
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	featureConfig := config.FeatureConfig
	clockClock := _wireSystemClockValue
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	appID := appConfig.ID
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	handle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	logger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	appredisHandle := appProvider.Redis
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	workflowVerificationFacade := facade.WorkflowVerificationFacade{
		Verification: verificationService,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	accountMigrationConfig := appConfig.AccountMigration
	accountMigrationHookConfig := accountMigrationConfig.Hook
	hookDenoClient := accountmigration.NewHookDenoClient(denoEndpoint, hookLogger, accountMigrationHookConfig)
	denoMiddlewareLogger := accountmigration.NewDenoMiddlewareLogger(factory)
	accountMigrationDenoHook := &accountmigration.AccountMigrationDenoHook{
		DenoHook: denoHook,
		Client:   hookDenoClient,
		Logger:   denoMiddlewareLogger,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := accountmigration.NewHookHTTPClient(accountMigrationHookConfig)
	webhookMiddlewareLogger := accountmigration.NewWebhookMiddlewareLogger(factory)
	accountMigrationWebHook := &accountmigration.AccountMigrationWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
		Logger:  webhookMiddlewareLogger,
	}
	accountmigrationService := &accountmigration.Service{
		Config:   accountMigrationHookConfig,
		DenoHook: accountMigrationDenoHook,
		WebHook:  accountMigrationWebHook,
	}
	captchaConfig := appConfig.Captcha
	providerLogger := captcha.NewProviderLogger(factory)
	captchaCloudflareCredentials := deps.ProvideCaptchaCloudflareCredentials(secretConfig)
	cloudflareClient := captcha2.NewCloudflareClient(captchaCloudflareCredentials)
	captchaProvider := &captcha.Provider{
		RemoteIP:         remoteIP,
		Config:           captchaConfig,
		Logger:           providerLogger,
		CloudflareClient: cloudflareClient,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	workflowStoreImpl := &workflow.StoreImpl{
		Redis:   appredisHandle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := workflow.NewEventStore(appID, appredisHandle, workflowStoreImpl)
	dependencies := &workflow.Dependencies{
		Config:               appConfig,
		FeatureConfig:        featureConfig,
		Clock:                clockClock,
		RemoteIP:             remoteIP,
		HTTPRequest:          request,
		Users:                userProvider,
		Identities:           identityFacade,
		Authenticators:       authenticatorFacade,
		MFA:                  mfaFacade,
		StdAttrsService:      stdattrsService,
		CustomAttrsService:   customattrsService,
		OTPCodes:             otpService,
		OTPSender:            messageSender,
		Verification:         workflowVerificationFacade,
		ForgotPassword:       forgotpasswordService,
		ResetPassword:        forgotpasswordService,
		AccountMigrations:    accountmigrationService,
		Captcha:              captchaProvider,
		IDPSessions:          idpsessionProvider,
		Sessions:             manager2,
		AuthenticationInfos:  authenticationinfoStoreRedis,
		SessionCookie:        cookieDef,
		MFADeviceTokenCookie: mfaCookieDef,
		Cookies:              cookieManager,
		Events:               eventService,
		RateLimiter:          limiter,
		WorkflowEvents:       eventStoreImpl,
		OfflineGrants:        redisStore,
	}
	workflowServiceLogger := workflow.NewServiceLogger(factory)
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	workflowService := &workflow.Service{
		ContextDoNotUseDirectly: contextContext,
		Deps:                    dependencies,
		Logger:                  workflowServiceLogger,
		Store:                   workflowStoreImpl,
		Database:                handle,
		UIInfoResolver:          uiInfoResolver,
	}
	workflowInputHandler := &api.WorkflowInputHandler{
		JSON:      jsonResponseWriter,
		Workflows: workflowService,
		Cookies:   cookieManager,
	}
	return workflowInputHandler
}

func newAPIWorkflowWebsocketHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	handle := appProvider.Redis
	request := p.Request
	contextContext := deps.ProvideRequestContext(request)
	storeImpl := &workflow.StoreImpl{
		Redis:   handle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := workflow.NewEventStore(appID, handle, storeImpl)
	factory := appProvider.LoggerFactory
	httpConfig := appConfig.HTTP
	oAuthConfig := appConfig.OAuth
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	corsAllowedOrigins := environmentConfig.CORSAllowedOrigins
	corsMatcher := &middleware.CORSMatcher{
		Config:             httpConfig,
		OAuthConfig:        oAuthConfig,
		CORSAllowedOrigins: corsAllowedOrigins,
	}
	workflowWebsocketHandler := &api.WorkflowWebsocketHandler{
		Events:        eventStoreImpl,
		LoggerFactory: factory,
		RedisHandle:   handle,
		OriginMatcher: corsMatcher,
	}
	return workflowWebsocketHandler
}

func newAPIWorkflowV2Handler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	contextContext := deps.ProvideRequestContext(request)
	featureConfig := config.FeatureConfig
	clockClock := _wireSystemClockValue
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	appID := appConfig.ID
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	handle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	logger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	appredisHandle := appProvider.Redis
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  appredisHandle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	workflowVerificationFacade := facade.WorkflowVerificationFacade{
		Verification: verificationService,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	accountMigrationConfig := appConfig.AccountMigration
	accountMigrationHookConfig := accountMigrationConfig.Hook
	hookDenoClient := accountmigration.NewHookDenoClient(denoEndpoint, hookLogger, accountMigrationHookConfig)
	denoMiddlewareLogger := accountmigration.NewDenoMiddlewareLogger(factory)
	accountMigrationDenoHook := &accountmigration.AccountMigrationDenoHook{
		DenoHook: denoHook,
		Client:   hookDenoClient,
		Logger:   denoMiddlewareLogger,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := accountmigration.NewHookHTTPClient(accountMigrationHookConfig)
	webhookMiddlewareLogger := accountmigration.NewWebhookMiddlewareLogger(factory)
	accountMigrationWebHook := &accountmigration.AccountMigrationWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
		Logger:  webhookMiddlewareLogger,
	}
	accountmigrationService := &accountmigration.Service{
		Config:   accountMigrationHookConfig,
		DenoHook: accountMigrationDenoHook,
		WebHook:  accountMigrationWebHook,
	}
	captchaConfig := appConfig.Captcha
	providerLogger := captcha.NewProviderLogger(factory)
	captchaCloudflareCredentials := deps.ProvideCaptchaCloudflareCredentials(secretConfig)
	cloudflareClient := captcha2.NewCloudflareClient(captchaCloudflareCredentials)
	captchaProvider := &captcha.Provider{
		RemoteIP:         remoteIP,
		Config:           captchaConfig,
		Logger:           providerLogger,
		CloudflareClient: cloudflareClient,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	workflowStoreImpl := &workflow.StoreImpl{
		Redis:   appredisHandle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := workflow.NewEventStore(appID, appredisHandle, workflowStoreImpl)
	dependencies := &workflow.Dependencies{
		Config:               appConfig,
		FeatureConfig:        featureConfig,
		Clock:                clockClock,
		RemoteIP:             remoteIP,
		HTTPRequest:          request,
		Users:                userProvider,
		Identities:           identityFacade,
		Authenticators:       authenticatorFacade,
		MFA:                  mfaFacade,
		StdAttrsService:      stdattrsService,
		CustomAttrsService:   customattrsService,
		OTPCodes:             otpService,
		OTPSender:            messageSender,
		Verification:         workflowVerificationFacade,
		ForgotPassword:       forgotpasswordService,
		ResetPassword:        forgotpasswordService,
		AccountMigrations:    accountmigrationService,
		Captcha:              captchaProvider,
		IDPSessions:          idpsessionProvider,
		Sessions:             manager2,
		AuthenticationInfos:  authenticationinfoStoreRedis,
		SessionCookie:        cookieDef,
		MFADeviceTokenCookie: mfaCookieDef,
		Cookies:              cookieManager,
		Events:               eventService,
		RateLimiter:          limiter,
		WorkflowEvents:       eventStoreImpl,
		OfflineGrants:        redisStore,
	}
	workflowServiceLogger := workflow.NewServiceLogger(factory)
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	workflowService := &workflow.Service{
		ContextDoNotUseDirectly: contextContext,
		Deps:                    dependencies,
		Logger:                  workflowServiceLogger,
		Store:                   workflowStoreImpl,
		Database:                handle,
		UIInfoResolver:          uiInfoResolver,
	}
	oauthsessionStoreRedis := &oauthsession.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	workflowV2Handler := &api.WorkflowV2Handler{
		JSON:           jsonResponseWriter,
		Cookies:        cookieManager,
		Workflows:      workflowService,
		OAuthSessions:  oauthsessionStoreRedis,
		UIInfoResolver: uiInfoResolver,
	}
	return workflowV2Handler
}

func newAPIAuthenticationFlowV1CreateHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.Redis
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	contextContext := deps.ProvideRequestContext(request)
	featureConfig := config.FeatureConfig
	clockClock := _wireSystemClockValue
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	appID := appConfig.ID
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	appdbHandle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	logger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	workflowVerificationFacade := facade.WorkflowVerificationFacade{
		Verification: verificationService,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	accountMigrationConfig := appConfig.AccountMigration
	accountMigrationHookConfig := accountMigrationConfig.Hook
	hookDenoClient := accountmigration.NewHookDenoClient(denoEndpoint, hookLogger, accountMigrationHookConfig)
	denoMiddlewareLogger := accountmigration.NewDenoMiddlewareLogger(factory)
	accountMigrationDenoHook := &accountmigration.AccountMigrationDenoHook{
		DenoHook: denoHook,
		Client:   hookDenoClient,
		Logger:   denoMiddlewareLogger,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := accountmigration.NewHookHTTPClient(accountMigrationHookConfig)
	webhookMiddlewareLogger := accountmigration.NewWebhookMiddlewareLogger(factory)
	accountMigrationWebHook := &accountmigration.AccountMigrationWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
		Logger:  webhookMiddlewareLogger,
	}
	accountmigrationService := &accountmigration.Service{
		Config:   accountMigrationHookConfig,
		DenoHook: accountMigrationDenoHook,
		WebHook:  accountMigrationWebHook,
	}
	captchaConfig := appConfig.Captcha
	providerLogger := captcha.NewProviderLogger(factory)
	captchaCloudflareCredentials := deps.ProvideCaptchaCloudflareCredentials(secretConfig)
	cloudflareClient := captcha2.NewCloudflareClient(captchaCloudflareCredentials)
	captchaProvider := &captcha.Provider{
		RemoteIP:         remoteIP,
		Config:           captchaConfig,
		Logger:           providerLogger,
		CloudflareClient: cloudflareClient,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	requestOptionsService := &passkey2.RequestOptionsService{
		ConfigService:   configService,
		IdentityService: serviceService,
		Store:           store2,
	}
	creationOptionsService := &passkey2.CreationOptionsService{
		ConfigService:   configService,
		UserService:     queries,
		IdentityService: serviceService,
		Store:           store2,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	authenticationflowStoreImpl := &authenticationflow.StoreImpl{
		Redis:   handle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := authenticationflow.NewEventStore(appID, handle, authenticationflowStoreImpl)
	dependencies := &authenticationflow.Dependencies{
		Config:                        appConfig,
		FeatureConfig:                 featureConfig,
		Clock:                         clockClock,
		RemoteIP:                      remoteIP,
		HTTPOrigin:                    httpOrigin,
		HTTPRequest:                   request,
		Users:                         userProvider,
		Identities:                    identityFacade,
		Authenticators:                authenticatorFacade,
		MFA:                           mfaFacade,
		StdAttrsService:               stdattrsService,
		CustomAttrsService:            customattrsService,
		OTPCodes:                      otpService,
		OTPSender:                     messageSender,
		Verification:                  workflowVerificationFacade,
		ForgotPassword:                forgotpasswordService,
		ResetPassword:                 forgotpasswordService,
		AccountMigrations:             accountmigrationService,
		Captcha:                       captchaProvider,
		OAuthProviderFactory:          oAuthProviderFactory,
		PasskeyRequestOptionsService:  requestOptionsService,
		PasskeyCreationOptionsService: creationOptionsService,
		PasskeyService:                passkeyService,
		IDPSessions:                   idpsessionProvider,
		Sessions:                      manager2,
		AuthenticationInfos:           authenticationinfoStoreRedis,
		SessionCookie:                 cookieDef,
		MFADeviceTokenCookie:          mfaCookieDef,
		Cookies:                       cookieManager,
		Events:                        eventService,
		RateLimiter:                   limiter,
		FlowEvents:                    eventStoreImpl,
		OfflineGrants:                 redisStore,
	}
	authenticationflowServiceLogger := authenticationflow.NewServiceLogger(factory)
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	authenticationflowService := &authenticationflow.Service{
		ContextDoNotUseDirectly: contextContext,
		Deps:                    dependencies,
		Logger:                  authenticationflowServiceLogger,
		Store:                   authenticationflowStoreImpl,
		Database:                appdbHandle,
		UIInfoResolver:          uiInfoResolver,
	}
	oauthsessionStoreRedis := &oauthsession.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	authenticationFlowV1CreateHandler := &api.AuthenticationFlowV1CreateHandler{
		LoggerFactory:  factory,
		RedisHandle:    handle,
		JSON:           jsonResponseWriter,
		Cookies:        cookieManager,
		Workflows:      authenticationflowService,
		OAuthSessions:  oauthsessionStoreRedis,
		UIInfoResolver: uiInfoResolver,
	}
	return authenticationFlowV1CreateHandler
}

func newAPIAuthenticationFlowV1InputHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.Redis
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	contextContext := deps.ProvideRequestContext(request)
	featureConfig := config.FeatureConfig
	clockClock := _wireSystemClockValue
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	appID := appConfig.ID
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	appdbHandle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	logger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	workflowVerificationFacade := facade.WorkflowVerificationFacade{
		Verification: verificationService,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	accountMigrationConfig := appConfig.AccountMigration
	accountMigrationHookConfig := accountMigrationConfig.Hook
	hookDenoClient := accountmigration.NewHookDenoClient(denoEndpoint, hookLogger, accountMigrationHookConfig)
	denoMiddlewareLogger := accountmigration.NewDenoMiddlewareLogger(factory)
	accountMigrationDenoHook := &accountmigration.AccountMigrationDenoHook{
		DenoHook: denoHook,
		Client:   hookDenoClient,
		Logger:   denoMiddlewareLogger,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := accountmigration.NewHookHTTPClient(accountMigrationHookConfig)
	webhookMiddlewareLogger := accountmigration.NewWebhookMiddlewareLogger(factory)
	accountMigrationWebHook := &accountmigration.AccountMigrationWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
		Logger:  webhookMiddlewareLogger,
	}
	accountmigrationService := &accountmigration.Service{
		Config:   accountMigrationHookConfig,
		DenoHook: accountMigrationDenoHook,
		WebHook:  accountMigrationWebHook,
	}
	captchaConfig := appConfig.Captcha
	providerLogger := captcha.NewProviderLogger(factory)
	captchaCloudflareCredentials := deps.ProvideCaptchaCloudflareCredentials(secretConfig)
	cloudflareClient := captcha2.NewCloudflareClient(captchaCloudflareCredentials)
	captchaProvider := &captcha.Provider{
		RemoteIP:         remoteIP,
		Config:           captchaConfig,
		Logger:           providerLogger,
		CloudflareClient: cloudflareClient,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	requestOptionsService := &passkey2.RequestOptionsService{
		ConfigService:   configService,
		IdentityService: serviceService,
		Store:           store2,
	}
	creationOptionsService := &passkey2.CreationOptionsService{
		ConfigService:   configService,
		UserService:     queries,
		IdentityService: serviceService,
		Store:           store2,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	authenticationflowStoreImpl := &authenticationflow.StoreImpl{
		Redis:   handle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := authenticationflow.NewEventStore(appID, handle, authenticationflowStoreImpl)
	dependencies := &authenticationflow.Dependencies{
		Config:                        appConfig,
		FeatureConfig:                 featureConfig,
		Clock:                         clockClock,
		RemoteIP:                      remoteIP,
		HTTPOrigin:                    httpOrigin,
		HTTPRequest:                   request,
		Users:                         userProvider,
		Identities:                    identityFacade,
		Authenticators:                authenticatorFacade,
		MFA:                           mfaFacade,
		StdAttrsService:               stdattrsService,
		CustomAttrsService:            customattrsService,
		OTPCodes:                      otpService,
		OTPSender:                     messageSender,
		Verification:                  workflowVerificationFacade,
		ForgotPassword:                forgotpasswordService,
		ResetPassword:                 forgotpasswordService,
		AccountMigrations:             accountmigrationService,
		Captcha:                       captchaProvider,
		OAuthProviderFactory:          oAuthProviderFactory,
		PasskeyRequestOptionsService:  requestOptionsService,
		PasskeyCreationOptionsService: creationOptionsService,
		PasskeyService:                passkeyService,
		IDPSessions:                   idpsessionProvider,
		Sessions:                      manager2,
		AuthenticationInfos:           authenticationinfoStoreRedis,
		SessionCookie:                 cookieDef,
		MFADeviceTokenCookie:          mfaCookieDef,
		Cookies:                       cookieManager,
		Events:                        eventService,
		RateLimiter:                   limiter,
		FlowEvents:                    eventStoreImpl,
		OfflineGrants:                 redisStore,
	}
	authenticationflowServiceLogger := authenticationflow.NewServiceLogger(factory)
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	authenticationflowService := &authenticationflow.Service{
		ContextDoNotUseDirectly: contextContext,
		Deps:                    dependencies,
		Logger:                  authenticationflowServiceLogger,
		Store:                   authenticationflowStoreImpl,
		Database:                appdbHandle,
		UIInfoResolver:          uiInfoResolver,
	}
	authenticationFlowV1InputHandler := &api.AuthenticationFlowV1InputHandler{
		LoggerFactory: factory,
		RedisHandle:   handle,
		JSON:          jsonResponseWriter,
		Cookies:       cookieManager,
		Workflows:     authenticationflowService,
	}
	return authenticationFlowV1InputHandler
}

func newAPIAuthenticationFlowV1GetHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.Redis
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	request := p.Request
	contextContext := deps.ProvideRequestContext(request)
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	featureConfig := config.FeatureConfig
	clockClock := _wireSystemClockValue
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	appID := appConfig.ID
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	appdbHandle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	logger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	workflowVerificationFacade := facade.WorkflowVerificationFacade{
		Verification: verificationService,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	accountMigrationConfig := appConfig.AccountMigration
	accountMigrationHookConfig := accountMigrationConfig.Hook
	hookDenoClient := accountmigration.NewHookDenoClient(denoEndpoint, hookLogger, accountMigrationHookConfig)
	denoMiddlewareLogger := accountmigration.NewDenoMiddlewareLogger(factory)
	accountMigrationDenoHook := &accountmigration.AccountMigrationDenoHook{
		DenoHook: denoHook,
		Client:   hookDenoClient,
		Logger:   denoMiddlewareLogger,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := accountmigration.NewHookHTTPClient(accountMigrationHookConfig)
	webhookMiddlewareLogger := accountmigration.NewWebhookMiddlewareLogger(factory)
	accountMigrationWebHook := &accountmigration.AccountMigrationWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
		Logger:  webhookMiddlewareLogger,
	}
	accountmigrationService := &accountmigration.Service{
		Config:   accountMigrationHookConfig,
		DenoHook: accountMigrationDenoHook,
		WebHook:  accountMigrationWebHook,
	}
	captchaConfig := appConfig.Captcha
	providerLogger := captcha.NewProviderLogger(factory)
	captchaCloudflareCredentials := deps.ProvideCaptchaCloudflareCredentials(secretConfig)
	cloudflareClient := captcha2.NewCloudflareClient(captchaCloudflareCredentials)
	captchaProvider := &captcha.Provider{
		RemoteIP:         remoteIP,
		Config:           captchaConfig,
		Logger:           providerLogger,
		CloudflareClient: cloudflareClient,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	requestOptionsService := &passkey2.RequestOptionsService{
		ConfigService:   configService,
		IdentityService: serviceService,
		Store:           store2,
	}
	creationOptionsService := &passkey2.CreationOptionsService{
		ConfigService:   configService,
		UserService:     queries,
		IdentityService: serviceService,
		Store:           store2,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	authenticationflowStoreImpl := &authenticationflow.StoreImpl{
		Redis:   handle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := authenticationflow.NewEventStore(appID, handle, authenticationflowStoreImpl)
	dependencies := &authenticationflow.Dependencies{
		Config:                        appConfig,
		FeatureConfig:                 featureConfig,
		Clock:                         clockClock,
		RemoteIP:                      remoteIP,
		HTTPOrigin:                    httpOrigin,
		HTTPRequest:                   request,
		Users:                         userProvider,
		Identities:                    identityFacade,
		Authenticators:                authenticatorFacade,
		MFA:                           mfaFacade,
		StdAttrsService:               stdattrsService,
		CustomAttrsService:            customattrsService,
		OTPCodes:                      otpService,
		OTPSender:                     messageSender,
		Verification:                  workflowVerificationFacade,
		ForgotPassword:                forgotpasswordService,
		ResetPassword:                 forgotpasswordService,
		AccountMigrations:             accountmigrationService,
		Captcha:                       captchaProvider,
		OAuthProviderFactory:          oAuthProviderFactory,
		PasskeyRequestOptionsService:  requestOptionsService,
		PasskeyCreationOptionsService: creationOptionsService,
		PasskeyService:                passkeyService,
		IDPSessions:                   idpsessionProvider,
		Sessions:                      manager2,
		AuthenticationInfos:           authenticationinfoStoreRedis,
		SessionCookie:                 cookieDef,
		MFADeviceTokenCookie:          mfaCookieDef,
		Cookies:                       cookieManager,
		Events:                        eventService,
		RateLimiter:                   limiter,
		FlowEvents:                    eventStoreImpl,
		OfflineGrants:                 redisStore,
	}
	authenticationflowServiceLogger := authenticationflow.NewServiceLogger(factory)
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	authenticationflowService := &authenticationflow.Service{
		ContextDoNotUseDirectly: contextContext,
		Deps:                    dependencies,
		Logger:                  authenticationflowServiceLogger,
		Store:                   authenticationflowStoreImpl,
		Database:                appdbHandle,
		UIInfoResolver:          uiInfoResolver,
	}
	authenticationFlowV1GetHandler := &api.AuthenticationFlowV1GetHandler{
		LoggerFactory: factory,
		RedisHandle:   handle,
		JSON:          jsonResponseWriter,
		Workflows:     authenticationflowService,
	}
	return authenticationFlowV1GetHandler
}

func newAPIAuthenticationFlowV1WebsocketHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	handle := appProvider.Redis
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	oAuthConfig := appConfig.OAuth
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	corsAllowedOrigins := environmentConfig.CORSAllowedOrigins
	corsMatcher := &middleware.CORSMatcher{
		Config:             httpConfig,
		OAuthConfig:        oAuthConfig,
		CORSAllowedOrigins: corsAllowedOrigins,
	}
	appID := appConfig.ID
	request := p.Request
	contextContext := deps.ProvideRequestContext(request)
	storeImpl := &authenticationflow.StoreImpl{
		Redis:   handle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := authenticationflow.NewEventStore(appID, handle, storeImpl)
	authenticationFlowV1WebsocketHandler := &api.AuthenticationFlowV1WebsocketHandler{
		LoggerFactory: factory,
		RedisHandle:   handle,
		OriginMatcher: corsMatcher,
		Events:        eventStoreImpl,
	}
	return authenticationFlowV1WebsocketHandler
}

func newWebAppAuthflowLoginHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	authflowControllerLogger := webapp.NewAuthflowControllerLogger(factory)
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	errorCookieDef := webapp2.NewErrorCookieDef()
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	clockClock := _wireSystemClockValue
	appID := appConfig.ID
	handle := appProvider.Redis
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: handle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	contextContext := deps.ProvideRequestContext(request)
	featureConfig := config.FeatureConfig
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	appdbHandle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	logger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	workflowVerificationFacade := facade.WorkflowVerificationFacade{
		Verification: verificationService,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	accountMigrationConfig := appConfig.AccountMigration
	accountMigrationHookConfig := accountMigrationConfig.Hook
	hookDenoClient := accountmigration.NewHookDenoClient(denoEndpoint, hookLogger, accountMigrationHookConfig)
	denoMiddlewareLogger := accountmigration.NewDenoMiddlewareLogger(factory)
	accountMigrationDenoHook := &accountmigration.AccountMigrationDenoHook{
		DenoHook: denoHook,
		Client:   hookDenoClient,
		Logger:   denoMiddlewareLogger,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := accountmigration.NewHookHTTPClient(accountMigrationHookConfig)
	webhookMiddlewareLogger := accountmigration.NewWebhookMiddlewareLogger(factory)
	accountMigrationWebHook := &accountmigration.AccountMigrationWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
		Logger:  webhookMiddlewareLogger,
	}
	accountmigrationService := &accountmigration.Service{
		Config:   accountMigrationHookConfig,
		DenoHook: accountMigrationDenoHook,
		WebHook:  accountMigrationWebHook,
	}
	captchaConfig := appConfig.Captcha
	providerLogger := captcha.NewProviderLogger(factory)
	captchaCloudflareCredentials := deps.ProvideCaptchaCloudflareCredentials(secretConfig)
	cloudflareClient := captcha2.NewCloudflareClient(captchaCloudflareCredentials)
	captchaProvider := &captcha.Provider{
		RemoteIP:         remoteIP,
		Config:           captchaConfig,
		Logger:           providerLogger,
		CloudflareClient: cloudflareClient,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	requestOptionsService := &passkey2.RequestOptionsService{
		ConfigService:   configService,
		IdentityService: serviceService,
		Store:           store2,
	}
	creationOptionsService := &passkey2.CreationOptionsService{
		ConfigService:   configService,
		UserService:     queries,
		IdentityService: serviceService,
		Store:           store2,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	authenticationflowStoreImpl := &authenticationflow.StoreImpl{
		Redis:   handle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := authenticationflow.NewEventStore(appID, handle, authenticationflowStoreImpl)
	dependencies := &authenticationflow.Dependencies{
		Config:                        appConfig,
		FeatureConfig:                 featureConfig,
		Clock:                         clockClock,
		RemoteIP:                      remoteIP,
		HTTPOrigin:                    httpOrigin,
		HTTPRequest:                   request,
		Users:                         userProvider,
		Identities:                    identityFacade,
		Authenticators:                authenticatorFacade,
		MFA:                           mfaFacade,
		StdAttrsService:               stdattrsService,
		CustomAttrsService:            customattrsService,
		OTPCodes:                      otpService,
		OTPSender:                     messageSender,
		Verification:                  workflowVerificationFacade,
		ForgotPassword:                forgotpasswordService,
		ResetPassword:                 forgotpasswordService,
		AccountMigrations:             accountmigrationService,
		Captcha:                       captchaProvider,
		OAuthProviderFactory:          oAuthProviderFactory,
		PasskeyRequestOptionsService:  requestOptionsService,
		PasskeyCreationOptionsService: creationOptionsService,
		PasskeyService:                passkeyService,
		IDPSessions:                   idpsessionProvider,
		Sessions:                      manager2,
		AuthenticationInfos:           authenticationinfoStoreRedis,
		SessionCookie:                 cookieDef,
		MFADeviceTokenCookie:          mfaCookieDef,
		Cookies:                       cookieManager,
		Events:                        eventService,
		RateLimiter:                   limiter,
		FlowEvents:                    eventStoreImpl,
		OfflineGrants:                 redisStore,
	}
	authenticationflowServiceLogger := authenticationflow.NewServiceLogger(factory)
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	authenticationflowService := &authenticationflow.Service{
		ContextDoNotUseDirectly: contextContext,
		Deps:                    dependencies,
		Logger:                  authenticationflowServiceLogger,
		Store:                   authenticationflowStoreImpl,
		Database:                appdbHandle,
		UIInfoResolver:          uiInfoResolver,
	}
	oauthsessionStoreRedis := &oauthsession.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	uiConfig := appConfig.UI
	authflowController := &webapp.AuthflowController{
		Logger:                  authflowControllerLogger,
		TesterEndpointsProvider: endpointsEndpoints,
		ErrorCookie:             errorCookie,
		TrustProxy:              trustProxy,
		Clock:                   clockClock,
		Cookies:                 cookieManager,
		Sessions:                sessionStoreRedis,
		SessionCookie:           sessionCookieDef,
		Authflows:               authenticationflowService,
		OAuthSessions:           oauthsessionStoreRedis,
		UIInfoResolver:          uiInfoResolver,
		UIConfig:                uiConfig,
		OAuthClientResolver:     oauthclientResolver,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	authflowViewModeler := &viewmodels.AuthflowViewModeler{
		Authentication: authenticationConfig,
		LoginID:        loginIDConfig,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	analyticredisHandle := appProvider.AnalyticRedis
	meterStoreRedisLogger := meter.NewStoreRedisLogger(factory)
	writeStoreRedis := &meter.WriteStoreRedis{
		Context: contextContext,
		Redis:   analyticredisHandle,
		AppID:   appID,
		Clock:   clockClock,
		Logger:  meterStoreRedisLogger,
	}
	meterService := &meter.Service{
		Counter: writeStoreRedis,
	}
	tutorialCookie := &httputil.TutorialCookie{
		Cookies: cookieManager,
	}
	authflowLoginHandler := &webapp.AuthflowLoginHandler{
		Controller:        authflowController,
		BaseViewModel:     baseViewModeler,
		AuthflowViewModel: authflowViewModeler,
		Renderer:          responseRenderer,
		MeterService:      meterService,
		TutorialCookie:    tutorialCookie,
		ErrorCookie:       errorCookie,
		Endpoints:         endpointsEndpoints,
	}
	return authflowLoginHandler
}

func newWebAppAuthflowSignupHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	authflowControllerLogger := webapp.NewAuthflowControllerLogger(factory)
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	errorCookieDef := webapp2.NewErrorCookieDef()
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	clockClock := _wireSystemClockValue
	appID := appConfig.ID
	handle := appProvider.Redis
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: handle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	contextContext := deps.ProvideRequestContext(request)
	featureConfig := config.FeatureConfig
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	appdbHandle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	logger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	workflowVerificationFacade := facade.WorkflowVerificationFacade{
		Verification: verificationService,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	accountMigrationConfig := appConfig.AccountMigration
	accountMigrationHookConfig := accountMigrationConfig.Hook
	hookDenoClient := accountmigration.NewHookDenoClient(denoEndpoint, hookLogger, accountMigrationHookConfig)
	denoMiddlewareLogger := accountmigration.NewDenoMiddlewareLogger(factory)
	accountMigrationDenoHook := &accountmigration.AccountMigrationDenoHook{
		DenoHook: denoHook,
		Client:   hookDenoClient,
		Logger:   denoMiddlewareLogger,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := accountmigration.NewHookHTTPClient(accountMigrationHookConfig)
	webhookMiddlewareLogger := accountmigration.NewWebhookMiddlewareLogger(factory)
	accountMigrationWebHook := &accountmigration.AccountMigrationWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
		Logger:  webhookMiddlewareLogger,
	}
	accountmigrationService := &accountmigration.Service{
		Config:   accountMigrationHookConfig,
		DenoHook: accountMigrationDenoHook,
		WebHook:  accountMigrationWebHook,
	}
	captchaConfig := appConfig.Captcha
	providerLogger := captcha.NewProviderLogger(factory)
	captchaCloudflareCredentials := deps.ProvideCaptchaCloudflareCredentials(secretConfig)
	cloudflareClient := captcha2.NewCloudflareClient(captchaCloudflareCredentials)
	captchaProvider := &captcha.Provider{
		RemoteIP:         remoteIP,
		Config:           captchaConfig,
		Logger:           providerLogger,
		CloudflareClient: cloudflareClient,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	requestOptionsService := &passkey2.RequestOptionsService{
		ConfigService:   configService,
		IdentityService: serviceService,
		Store:           store2,
	}
	creationOptionsService := &passkey2.CreationOptionsService{
		ConfigService:   configService,
		UserService:     queries,
		IdentityService: serviceService,
		Store:           store2,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	authenticationflowStoreImpl := &authenticationflow.StoreImpl{
		Redis:   handle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := authenticationflow.NewEventStore(appID, handle, authenticationflowStoreImpl)
	dependencies := &authenticationflow.Dependencies{
		Config:                        appConfig,
		FeatureConfig:                 featureConfig,
		Clock:                         clockClock,
		RemoteIP:                      remoteIP,
		HTTPOrigin:                    httpOrigin,
		HTTPRequest:                   request,
		Users:                         userProvider,
		Identities:                    identityFacade,
		Authenticators:                authenticatorFacade,
		MFA:                           mfaFacade,
		StdAttrsService:               stdattrsService,
		CustomAttrsService:            customattrsService,
		OTPCodes:                      otpService,
		OTPSender:                     messageSender,
		Verification:                  workflowVerificationFacade,
		ForgotPassword:                forgotpasswordService,
		ResetPassword:                 forgotpasswordService,
		AccountMigrations:             accountmigrationService,
		Captcha:                       captchaProvider,
		OAuthProviderFactory:          oAuthProviderFactory,
		PasskeyRequestOptionsService:  requestOptionsService,
		PasskeyCreationOptionsService: creationOptionsService,
		PasskeyService:                passkeyService,
		IDPSessions:                   idpsessionProvider,
		Sessions:                      manager2,
		AuthenticationInfos:           authenticationinfoStoreRedis,
		SessionCookie:                 cookieDef,
		MFADeviceTokenCookie:          mfaCookieDef,
		Cookies:                       cookieManager,
		Events:                        eventService,
		RateLimiter:                   limiter,
		FlowEvents:                    eventStoreImpl,
		OfflineGrants:                 redisStore,
	}
	authenticationflowServiceLogger := authenticationflow.NewServiceLogger(factory)
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	authenticationflowService := &authenticationflow.Service{
		ContextDoNotUseDirectly: contextContext,
		Deps:                    dependencies,
		Logger:                  authenticationflowServiceLogger,
		Store:                   authenticationflowStoreImpl,
		Database:                appdbHandle,
		UIInfoResolver:          uiInfoResolver,
	}
	oauthsessionStoreRedis := &oauthsession.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	uiConfig := appConfig.UI
	authflowController := &webapp.AuthflowController{
		Logger:                  authflowControllerLogger,
		TesterEndpointsProvider: endpointsEndpoints,
		ErrorCookie:             errorCookie,
		TrustProxy:              trustProxy,
		Clock:                   clockClock,
		Cookies:                 cookieManager,
		Sessions:                sessionStoreRedis,
		SessionCookie:           sessionCookieDef,
		Authflows:               authenticationflowService,
		OAuthSessions:           oauthsessionStoreRedis,
		UIInfoResolver:          uiInfoResolver,
		UIConfig:                uiConfig,
		OAuthClientResolver:     oauthclientResolver,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	authflowViewModeler := &viewmodels.AuthflowViewModeler{
		Authentication: authenticationConfig,
		LoginID:        loginIDConfig,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	analyticredisHandle := appProvider.AnalyticRedis
	meterStoreRedisLogger := meter.NewStoreRedisLogger(factory)
	writeStoreRedis := &meter.WriteStoreRedis{
		Context: contextContext,
		Redis:   analyticredisHandle,
		AppID:   appID,
		Clock:   clockClock,
		Logger:  meterStoreRedisLogger,
	}
	meterService := &meter.Service{
		Counter: writeStoreRedis,
	}
	tutorialCookie := &httputil.TutorialCookie{
		Cookies: cookieManager,
	}
	authflowSignupHandler := &webapp.AuthflowSignupHandler{
		Controller:        authflowController,
		BaseViewModel:     baseViewModeler,
		AuthflowViewModel: authflowViewModeler,
		Renderer:          responseRenderer,
		MeterService:      meterService,
		TutorialCookie:    tutorialCookie,
		ErrorCookie:       errorCookie,
		Endpoints:         endpointsEndpoints,
	}
	return authflowSignupHandler
}

func newWebAppAuthflowEnterPasswordHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	authflowControllerLogger := webapp.NewAuthflowControllerLogger(factory)
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	errorCookieDef := webapp2.NewErrorCookieDef()
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	clockClock := _wireSystemClockValue
	appID := appConfig.ID
	handle := appProvider.Redis
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: handle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	contextContext := deps.ProvideRequestContext(request)
	featureConfig := config.FeatureConfig
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	appdbHandle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	logger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	workflowVerificationFacade := facade.WorkflowVerificationFacade{
		Verification: verificationService,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	accountMigrationConfig := appConfig.AccountMigration
	accountMigrationHookConfig := accountMigrationConfig.Hook
	hookDenoClient := accountmigration.NewHookDenoClient(denoEndpoint, hookLogger, accountMigrationHookConfig)
	denoMiddlewareLogger := accountmigration.NewDenoMiddlewareLogger(factory)
	accountMigrationDenoHook := &accountmigration.AccountMigrationDenoHook{
		DenoHook: denoHook,
		Client:   hookDenoClient,
		Logger:   denoMiddlewareLogger,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := accountmigration.NewHookHTTPClient(accountMigrationHookConfig)
	webhookMiddlewareLogger := accountmigration.NewWebhookMiddlewareLogger(factory)
	accountMigrationWebHook := &accountmigration.AccountMigrationWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
		Logger:  webhookMiddlewareLogger,
	}
	accountmigrationService := &accountmigration.Service{
		Config:   accountMigrationHookConfig,
		DenoHook: accountMigrationDenoHook,
		WebHook:  accountMigrationWebHook,
	}
	captchaConfig := appConfig.Captcha
	providerLogger := captcha.NewProviderLogger(factory)
	captchaCloudflareCredentials := deps.ProvideCaptchaCloudflareCredentials(secretConfig)
	cloudflareClient := captcha2.NewCloudflareClient(captchaCloudflareCredentials)
	captchaProvider := &captcha.Provider{
		RemoteIP:         remoteIP,
		Config:           captchaConfig,
		Logger:           providerLogger,
		CloudflareClient: cloudflareClient,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	requestOptionsService := &passkey2.RequestOptionsService{
		ConfigService:   configService,
		IdentityService: serviceService,
		Store:           store2,
	}
	creationOptionsService := &passkey2.CreationOptionsService{
		ConfigService:   configService,
		UserService:     queries,
		IdentityService: serviceService,
		Store:           store2,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	authenticationflowStoreImpl := &authenticationflow.StoreImpl{
		Redis:   handle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := authenticationflow.NewEventStore(appID, handle, authenticationflowStoreImpl)
	dependencies := &authenticationflow.Dependencies{
		Config:                        appConfig,
		FeatureConfig:                 featureConfig,
		Clock:                         clockClock,
		RemoteIP:                      remoteIP,
		HTTPOrigin:                    httpOrigin,
		HTTPRequest:                   request,
		Users:                         userProvider,
		Identities:                    identityFacade,
		Authenticators:                authenticatorFacade,
		MFA:                           mfaFacade,
		StdAttrsService:               stdattrsService,
		CustomAttrsService:            customattrsService,
		OTPCodes:                      otpService,
		OTPSender:                     messageSender,
		Verification:                  workflowVerificationFacade,
		ForgotPassword:                forgotpasswordService,
		ResetPassword:                 forgotpasswordService,
		AccountMigrations:             accountmigrationService,
		Captcha:                       captchaProvider,
		OAuthProviderFactory:          oAuthProviderFactory,
		PasskeyRequestOptionsService:  requestOptionsService,
		PasskeyCreationOptionsService: creationOptionsService,
		PasskeyService:                passkeyService,
		IDPSessions:                   idpsessionProvider,
		Sessions:                      manager2,
		AuthenticationInfos:           authenticationinfoStoreRedis,
		SessionCookie:                 cookieDef,
		MFADeviceTokenCookie:          mfaCookieDef,
		Cookies:                       cookieManager,
		Events:                        eventService,
		RateLimiter:                   limiter,
		FlowEvents:                    eventStoreImpl,
		OfflineGrants:                 redisStore,
	}
	authenticationflowServiceLogger := authenticationflow.NewServiceLogger(factory)
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	authenticationflowService := &authenticationflow.Service{
		ContextDoNotUseDirectly: contextContext,
		Deps:                    dependencies,
		Logger:                  authenticationflowServiceLogger,
		Store:                   authenticationflowStoreImpl,
		Database:                appdbHandle,
		UIInfoResolver:          uiInfoResolver,
	}
	oauthsessionStoreRedis := &oauthsession.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	uiConfig := appConfig.UI
	authflowController := &webapp.AuthflowController{
		Logger:                  authflowControllerLogger,
		TesterEndpointsProvider: endpointsEndpoints,
		ErrorCookie:             errorCookie,
		TrustProxy:              trustProxy,
		Clock:                   clockClock,
		Cookies:                 cookieManager,
		Sessions:                sessionStoreRedis,
		SessionCookie:           sessionCookieDef,
		Authflows:               authenticationflowService,
		OAuthSessions:           oauthsessionStoreRedis,
		UIInfoResolver:          uiInfoResolver,
		UIConfig:                uiConfig,
		OAuthClientResolver:     oauthclientResolver,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	authflowEnterPasswordHandler := &webapp.AuthflowEnterPasswordHandler{
		Controller:    authflowController,
		BaseViewModel: baseViewModeler,
		Renderer:      responseRenderer,
	}
	return authflowEnterPasswordHandler
}

func newWebAppAuthflowEnterOOBOTPHandler(p *deps.RequestProvider) http.Handler {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	authflowControllerLogger := webapp.NewAuthflowControllerLogger(factory)
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	errorCookieDef := webapp2.NewErrorCookieDef()
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	clockClock := _wireSystemClockValue
	appID := appConfig.ID
	handle := appProvider.Redis
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: handle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	contextContext := deps.ProvideRequestContext(request)
	featureConfig := config.FeatureConfig
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	appdbHandle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	logger := event.NewLogger(factory)
	localizationConfig := appConfig.Localization
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	customattrsService := &customattrs.Service{
		Config:         userProfileConfig,
		ServiceNoEvent: customattrsServiceNoEvent,
		Events:         eventService,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	serviceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     serviceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	workflowVerificationFacade := facade.WorkflowVerificationFacade{
		Verification: verificationService,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	accountMigrationConfig := appConfig.AccountMigration
	accountMigrationHookConfig := accountMigrationConfig.Hook
	hookDenoClient := accountmigration.NewHookDenoClient(denoEndpoint, hookLogger, accountMigrationHookConfig)
	denoMiddlewareLogger := accountmigration.NewDenoMiddlewareLogger(factory)
	accountMigrationDenoHook := &accountmigration.AccountMigrationDenoHook{
		DenoHook: denoHook,
		Client:   hookDenoClient,
		Logger:   denoMiddlewareLogger,
	}
	hookWebHookImpl := &hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	hookHTTPClient := accountmigration.NewHookHTTPClient(accountMigrationHookConfig)
	webhookMiddlewareLogger := accountmigration.NewWebhookMiddlewareLogger(factory)
	accountMigrationWebHook := &accountmigration.AccountMigrationWebHook{
		WebHook: hookWebHookImpl,
		Client:  hookHTTPClient,
		Logger:  webhookMiddlewareLogger,
	}
	accountmigrationService := &accountmigration.Service{
		Config:   accountMigrationHookConfig,
		DenoHook: accountMigrationDenoHook,
		WebHook:  accountMigrationWebHook,
	}
	captchaConfig := appConfig.Captcha
	providerLogger := captcha.NewProviderLogger(factory)
	captchaCloudflareCredentials := deps.ProvideCaptchaCloudflareCredentials(secretConfig)
	cloudflareClient := captcha2.NewCloudflareClient(captchaCloudflareCredentials)
	captchaProvider := &captcha.Provider{
		RemoteIP:         remoteIP,
		Config:           captchaConfig,
		Logger:           providerLogger,
		CloudflareClient: cloudflareClient,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	requestOptionsService := &passkey2.RequestOptionsService{
		ConfigService:   configService,
		IdentityService: serviceService,
		Store:           store2,
	}
	creationOptionsService := &passkey2.CreationOptionsService{
		ConfigService:   configService,
		UserService:     queries,
		IdentityService: serviceService,
		Store:           store2,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	mfaCookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	authenticationflowStoreImpl := &authenticationflow.StoreImpl{
		Redis:   handle,
		AppID:   appID,
		Context: contextContext,
	}
	eventStoreImpl := authenticationflow.NewEventStore(appID, handle, authenticationflowStoreImpl)
	dependencies := &authenticationflow.Dependencies{
		Config:                        appConfig,
		FeatureConfig:                 featureConfig,
		Clock:                         clockClock,
		RemoteIP:                      remoteIP,
		HTTPOrigin:                    httpOrigin,
		HTTPRequest:                   request,
		Users:                         userProvider,
		Identities:                    identityFacade,
		Authenticators:                authenticatorFacade,
		MFA:                           mfaFacade,
		StdAttrsService:               stdattrsService,
		CustomAttrsService:            customattrsService,
		OTPCodes:                      otpService,
		OTPSender:                     messageSender,
		Verification:                  workflowVerificationFacade,
		ForgotPassword:                forgotpasswordService,
		ResetPassword:                 forgotpasswordService,
		AccountMigrations:             accountmigrationService,
		Captcha:                       captchaProvider,
		OAuthProviderFactory:          oAuthProviderFactory,
		PasskeyRequestOptionsService:  requestOptionsService,
		PasskeyCreationOptionsService: creationOptionsService,
		PasskeyService:                passkeyService,
		IDPSessions:                   idpsessionProvider,
		Sessions:                      manager2,
		AuthenticationInfos:           authenticationinfoStoreRedis,
		SessionCookie:                 cookieDef,
		MFADeviceTokenCookie:          mfaCookieDef,
		Cookies:                       cookieManager,
		Events:                        eventService,
		RateLimiter:                   limiter,
		FlowEvents:                    eventStoreImpl,
		OfflineGrants:                 redisStore,
	}
	authenticationflowServiceLogger := authenticationflow.NewServiceLogger(factory)
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	authenticationflowService := &authenticationflow.Service{
		ContextDoNotUseDirectly: contextContext,
		Deps:                    dependencies,
		Logger:                  authenticationflowServiceLogger,
		Store:                   authenticationflowStoreImpl,
		Database:                appdbHandle,
		UIInfoResolver:          uiInfoResolver,
	}
	oauthsessionStoreRedis := &oauthsession.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	uiConfig := appConfig.UI
	authflowController := &webapp.AuthflowController{
		Logger:                  authflowControllerLogger,
		TesterEndpointsProvider: endpointsEndpoints,
		ErrorCookie:             errorCookie,
		TrustProxy:              trustProxy,
		Clock:                   clockClock,
		Cookies:                 cookieManager,
		Sessions:                sessionStoreRedis,
		SessionCookie:           sessionCookieDef,
		Authflows:               authenticationflowService,
		OAuthSessions:           oauthsessionStoreRedis,
		UIInfoResolver:          uiInfoResolver,
		UIConfig:                uiConfig,
		OAuthClientResolver:     oauthclientResolver,
	}
	uiFeatureConfig := featureConfig.UI
	forgotPasswordConfig := appConfig.ForgotPassword
	googleTagManagerConfig := appConfig.GoogleTagManager
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	authflowEnterOOBOTPHandler := &webapp.AuthflowEnterOOBOTPHandler{
		Controller:    authflowController,
		BaseViewModel: baseViewModeler,
		Renderer:      responseRenderer,
		FlashMessage:  flashMessage,
		Clock:         clockClock,
	}
	return authflowEnterOOBOTPHandler
}

// Injectors from wire_middleware.go:

func newRequestMiddleware(w http.ResponseWriter, r *http.Request, p *deps.RootProvider, configSource *configsource.ConfigSource) httproute.Middleware {
	environmentConfig := p.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpHost := deps.ProvideHTTPHost(r, trustProxy)
	manager := p.BaseResources
	defaultLanguageTag := _wireDefaultLanguageTagValue
	supportedLanguageTags := _wireSupportedLanguageTagsValue
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	oAuthConfig := ProvideOAuthConfig()
	uiConfig := ProvideUIConfig()
	uiFeatureConfig := ProvideUIFeatureConfig()
	contextContext := deps.ProvideRequestContext(r)
	localizationConfig := ProvideLocalizationConfig(defaultLanguageTag, supportedLanguageTags)
	httpProto := deps.ProvideHTTPProto(r, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := p.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	forgotPasswordConfig := ProvideForgotPasswordConfig()
	authenticationConfig := ProvideAuthenticationConfig()
	googleTagManagerConfig := ProvideGoogleTagManagerConfig()
	errorCookieDef := webapp2.NewErrorCookieDef()
	cookieManager := ProvideCookieManager(r, trustProxy)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	clockClock := _wireSystemClockValue
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	requestMiddleware := &deps.RequestMiddleware{
		HTTPHost:        httpHost,
		RootProvider:    p,
		ConfigSource:    configSource,
		TemplateEngine:  engine,
		BaseViewModeler: baseViewModeler,
	}
	return requestMiddleware
}

var (
	_wireDefaultLanguageTagValue    = template.DefaultLanguageTag(intl.BuiltinBaseLanguage)
	_wireSupportedLanguageTagsValue = template.SupportedLanguageTags([]string{intl.BuiltinBaseLanguage})
)

func newPanicMiddleware(p *deps.RootProvider) httproute.Middleware {
	factory := p.LoggerFactory
	panicMiddlewareLogger := middleware.NewPanicMiddlewareLogger(factory)
	panicMiddleware := &middleware.PanicMiddleware{
		Logger: panicMiddlewareLogger,
	}
	return panicMiddleware
}

func newSentryMiddleware(p *deps.RootProvider) httproute.Middleware {
	hub := p.SentryHub
	environmentConfig := p.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	sentryMiddleware := &middleware.SentryMiddleware{
		SentryHub:  hub,
		TrustProxy: trustProxy,
	}
	return sentryMiddleware
}

func newBodyLimitMiddleware(p *deps.RootProvider) httproute.Middleware {
	bodyLimitMiddleware := &middleware.BodyLimitMiddleware{}
	return bodyLimitMiddleware
}

func newPanicWebAppMiddleware(p *deps.RequestProvider) httproute.Middleware {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	panicMiddlewareLogger := webapp.NewPanicMiddlewareLogger(factory)
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	featureConfig := config.FeatureConfig
	uiFeatureConfig := featureConfig.UI
	request := p.Request
	contextContext := deps.ProvideRequestContext(request)
	localizationConfig := appConfig.Localization
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	manager := appContext.Resources
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	forgotPasswordConfig := appConfig.ForgotPassword
	authenticationConfig := appConfig.Authentication
	googleTagManagerConfig := appConfig.GoogleTagManager
	errorCookieDef := webapp2.NewErrorCookieDef()
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	clockClock := _wireSystemClockValue
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	panicMiddleware := &webapp.PanicMiddleware{
		Logger:        panicMiddlewareLogger,
		BaseViewModel: baseViewModeler,
		Renderer:      responseRenderer,
	}
	return panicMiddleware
}

func newPublicOriginMiddleware(p *deps.RequestProvider) httproute.Middleware {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	factory := appProvider.LoggerFactory
	publicOriginMiddlewareLogger := webapp2.NewPublicOriginMiddlewareLogger(factory)
	publicOriginMiddleware := &webapp2.PublicOriginMiddleware{
		Config:     httpConfig,
		TrustProxy: trustProxy,
		Logger:     publicOriginMiddlewareLogger,
	}
	return publicOriginMiddleware
}

func newCORSMiddleware(p *deps.RequestProvider) httproute.Middleware {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	oAuthConfig := appConfig.OAuth
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	corsAllowedOrigins := environmentConfig.CORSAllowedOrigins
	corsMatcher := &middleware.CORSMatcher{
		Config:             httpConfig,
		OAuthConfig:        oAuthConfig,
		CORSAllowedOrigins: corsAllowedOrigins,
	}
	factory := appProvider.LoggerFactory
	corsMiddlewareLogger := middleware.NewCORSMiddlewareLogger(factory)
	corsMiddleware := &middleware.CORSMiddleware{
		Matcher: corsMatcher,
		Logger:  corsMiddlewareLogger,
	}
	return corsMiddleware
}

func newDynamicCSPMiddleware(p *deps.RequestProvider, allowInlineScript webapp2.AllowInlineScript, allowFrameAncestors webapp2.AllowFrameAncestors) httproute.Middleware {
	request := p.Request
	appProvider := p.AppProvider
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	oAuthConfig := appConfig.OAuth
	webAppCDNHost := environmentConfig.WebAppCDNHost
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	dynamicCSPMiddleware := &webapp2.DynamicCSPMiddleware{
		Cookies:             cookieManager,
		HTTPOrigin:          httpOrigin,
		OAuthConfig:         oAuthConfig,
		WebAppCDNHost:       webAppCDNHost,
		AuthUISentryDSN:     authUISentryDSN,
		AllowInlineScript:   allowInlineScript,
		AllowFrameAncestors: allowFrameAncestors,
	}
	return dynamicCSPMiddleware
}

func newCSRFMiddleware(p *deps.RequestProvider) httproute.Middleware {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	secretConfig := config.SecretConfig
	csrfKeyMaterials := deps.ProvideCSRFKeyMaterials(secretConfig)
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	csrfCookieDef := webapp2.NewCSRFCookieDef(httpConfig)
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	csrfMiddleware := &webapp2.CSRFMiddleware{
		Secret:     csrfKeyMaterials,
		CookieDef:  csrfCookieDef,
		TrustProxy: trustProxy,
	}
	return csrfMiddleware
}

func newAuthEntryPointMiddleware(p *deps.RequestProvider) httproute.Middleware {
	appProvider := p.AppProvider
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	featureConfig := config.FeatureConfig
	uiFeatureConfig := featureConfig.UI
	request := p.Request
	contextContext := deps.ProvideRequestContext(request)
	localizationConfig := appConfig.Localization
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	manager := appContext.Resources
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	forgotPasswordConfig := appConfig.ForgotPassword
	authenticationConfig := appConfig.Authentication
	googleTagManagerConfig := appConfig.GoogleTagManager
	errorCookieDef := webapp2.NewErrorCookieDef()
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	clockClock := _wireSystemClockValue
	flashMessage := &httputil.FlashMessage{
		Cookies: cookieManager,
	}
	authUISentryDSN := environmentConfig.AuthUISentryDSN
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	baseViewModeler := &viewmodels.BaseViewModeler{
		TrustProxy:            trustProxy,
		OAuth:                 oAuthConfig,
		AuthUI:                uiConfig,
		AuthUIFeatureConfig:   uiFeatureConfig,
		StaticAssets:          staticAssetResolver,
		ForgotPassword:        forgotPasswordConfig,
		Authentication:        authenticationConfig,
		GoogleTagManager:      googleTagManagerConfig,
		ErrorCookie:           errorCookie,
		Translations:          translationService,
		Clock:                 clockClock,
		FlashMessage:          flashMessage,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
		AuthUISentryDSN:       authUISentryDSN,
		OAuthClientResolver:   oauthclientResolver,
	}
	responseRenderer := &webapp.ResponseRenderer{
		TemplateEngine: engine,
	}
	appHostSuffixes := environmentConfig.AppHostSuffixes
	authEntryPointMiddleware := &webapp.AuthEntryPointMiddleware{
		BaseViewModel:       baseViewModeler,
		Renderer:            responseRenderer,
		AppHostSuffixes:     appHostSuffixes,
		TrustProxy:          trustProxy,
		OAuthConfig:         oAuthConfig,
		UIConfig:            uiConfig,
		OAuthClientResolver: oauthclientResolver,
	}
	return authEntryPointMiddleware
}

func newSessionMiddleware(p *deps.RequestProvider, idpSessionOnly bool) httproute.Middleware {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	sessionConfig := appConfig.Session
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	request := p.Request
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	contextContext := deps.ProvideRequestContext(request)
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	userAgentString := deps.ProvideUserAgentString(request)
	appID := appConfig.ID
	handle := appProvider.Redis
	clockClock := _wireSystemClockValue
	factory := appProvider.LoggerFactory
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	storeRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	provider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           storeRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	resolver := &idpsession.Resolver{
		Cookies:         cookieManager,
		CookieDef:       cookieDef,
		Provider:        provider,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		TrustProxy:      trustProxy,
		Clock:           clockClock,
	}
	oAuthConfig := appConfig.OAuth
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	appdbHandle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	logger := redis.NewLogger(factory)
	store := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      logger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	userStore := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: userStore,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	loginidProvider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	templateResolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: templateResolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	siweStoreRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           siweStoreRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               loginidProvider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         userStore,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   userStore,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              userStore,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	accessTokenEncoding := &oauth2.AccessTokenEncoding{
		Secrets:    oAuthKeyMaterials,
		Clock:      clockClock,
		UserClaims: idTokenIssuer,
		BaseURL:    endpointsEndpoints,
		Events:     eventService,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    provider,
		ClientResolver: oauthclientResolver,
	}
	oauthResolver := &oauth2.Resolver{
		RemoteIP:            remoteIP,
		UserAgentString:     userAgentString,
		OAuthConfig:         oAuthConfig,
		Authorizations:      authorizationStore,
		AccessGrants:        store,
		OfflineGrants:       store,
		AppSessions:         store,
		AccessTokenDecoder:  accessTokenEncoding,
		Sessions:            provider,
		Cookies:             cookieManager,
		Clock:               clockClock,
		OfflineGrantService: offlineGrantService,
	}
	middlewareLogger := session.NewMiddlewareLogger(factory)
	analyticredisHandle := appProvider.AnalyticRedis
	meterStoreRedisLogger := meter.NewStoreRedisLogger(factory)
	writeStoreRedis := &meter.WriteStoreRedis{
		Context: contextContext,
		Redis:   analyticredisHandle,
		AppID:   appID,
		Clock:   clockClock,
		Logger:  meterStoreRedisLogger,
	}
	meterService := &meter.Service{
		Counter: writeStoreRedis,
	}
	sessionMiddleware := &session.Middleware{
		SessionCookie:              cookieDef,
		Cookies:                    cookieManager,
		IDPSessionResolver:         resolver,
		AccessTokenSessionResolver: oauthResolver,
		AccessEvents:               eventProvider,
		Users:                      queries,
		Database:                   appdbHandle,
		Logger:                     middlewareLogger,
		MeterService:               meterService,
		IDPSessionOnly:             idpSessionOnly,
	}
	return sessionMiddleware
}

func newWebAppSessionMiddleware(p *deps.RequestProvider) httproute.Middleware {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	serviceLogger := webapp2.NewServiceLogger(factory)
	request := p.Request
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	handle := appProvider.Redis
	sessionStoreRedis := &webapp2.SessionStoreRedis{
		AppID: appID,
		Redis: handle,
	}
	sessionCookieDef := webapp2.NewSessionCookieDef()
	signedUpCookieDef := webapp2.NewSignedUpCookieDef()
	authenticationConfig := appConfig.Authentication
	cookieDef := mfa.NewDeviceTokenCookieDef(authenticationConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	oAuthConfig := appConfig.OAuth
	uiConfig := appConfig.UI
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	clockClock := _wireSystemClockValue
	promptResolver := &oauth2.PromptResolver{
		Clock: clockClock,
	}
	secretConfig := config.SecretConfig
	oAuthKeyMaterials := deps.ProvideOAuthKeyMaterials(secretConfig)
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	contextContext := deps.ProvideRequestContext(request)
	appdbHandle := appProvider.AppDatabase
	sqlExecutor := appdb.NewSQLExecutor(contextContext, appdbHandle)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	localizationConfig := appConfig.Localization
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	logger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  logger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: handle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	idTokenIssuer := &oidc.IDTokenIssuer{
		Secrets: oAuthKeyMaterials,
		BaseURL: endpointsEndpoints,
		Users:   queries,
		Clock:   clockClock,
	}
	userAgentString := deps.ProvideUserAgentString(request)
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  handle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	eventStoreRedis := &access.EventStoreRedis{
		Redis: handle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	sessionConfig := appConfig.Session
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           handle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       handle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	idTokenHintResolver := &oidc.IDTokenHintResolver{
		Issuer:        idTokenIssuer,
		Sessions:      idpsessionProvider,
		OfflineGrants: redisStore,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	uiInfoResolver := &oidc.UIInfoResolver{
		Config:              oAuthConfig,
		EndpointsProvider:   endpointsEndpoints,
		PromptResolver:      promptResolver,
		IDTokenHintResolver: idTokenHintResolver,
		Clock:               clockClock,
		Cookies:             cookieManager,
		ClientResolver:      oauthclientResolver,
	}
	interactionLogger := interaction.NewLogger(factory)
	eventLogger := event.NewLogger(factory)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: appdbHandle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, eventLogger, appdbHandle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	cookieDef2 := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef2,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := facade.IdentityFacade{
		Coordinator: coordinator,
	}
	authenticatorFacade := facade.AuthenticatorFacade{
		Coordinator: coordinator,
	}
	anonymousStoreRedis := &anonymous.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
		Clock:   clockClock,
	}
	messagingLogger := messaging.NewLogger(factory)
	usageLogger := usage.NewLogger(factory)
	usageLimiter := &usage.Limiter{
		Logger: usageLogger,
		Clock:  clockClock,
		AppID:  appID,
		Redis:  handle,
	}
	messagingConfig := appConfig.Messaging
	messagingRateLimitsConfig := messagingConfig.RateLimits
	messagingFeatureConfig := featureConfig.Messaging
	rateLimitsEnvironmentConfig := &environmentConfig.RateLimits
	limits := messaging.Limits{
		Logger:        messagingLogger,
		RateLimiter:   limiter,
		UsageLimiter:  usageLimiter,
		RemoteIP:      remoteIP,
		Config:        messagingRateLimitsConfig,
		FeatureConfig: messagingFeatureConfig,
		EnvConfig:     rateLimitsEnvironmentConfig,
	}
	whatsappServiceLogger := whatsapp.NewServiceLogger(factory)
	devMode := environmentConfig.DevMode
	testModeWhatsappSuppressed := deps.ProvideTestModeWhatsappSuppressed(testModeFeatureConfig)
	whatsappConfig := messagingConfig.Whatsapp
	whatsappOnPremisesCredentials := deps.ProvideWhatsappOnPremisesCredentials(secretConfig)
	tokenStore := &whatsapp.TokenStore{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	onPremisesClient := whatsapp.NewWhatsappOnPremisesClient(whatsappConfig, whatsappOnPremisesCredentials, tokenStore)
	whatsappService := &whatsapp.Service{
		Context:                    contextContext,
		Logger:                     whatsappServiceLogger,
		DevMode:                    devMode,
		TestModeWhatsappSuppressed: testModeWhatsappSuppressed,
		Config:                     whatsappConfig,
		OnPremisesClient:           onPremisesClient,
		TokenStore:                 tokenStore,
	}
	sender := &messaging.Sender{
		Limits:                 limits,
		TaskQueue:              queue,
		Events:                 eventService,
		Whatsapp:               whatsappService,
		MessagingFeatureConfig: messagingFeatureConfig,
	}
	messageSender := &otp.MessageSender{
		Translation:     translationService,
		Endpoints:       endpointsEndpoints,
		Sender:          sender,
		WhatsappService: whatsappService,
	}
	oAuthSSOProviderCredentials := deps.ProvideOAuthSSOProviderCredentials(secretConfig)
	normalizer := &stdattrs2.Normalizer{
		LoginIDNormalizerFactory: normalizerFactory,
	}
	oAuthProviderFactory := &sso.OAuthProviderFactory{
		Endpoints:                    endpointsEndpoints,
		IdentityConfig:               identityConfig,
		Credentials:                  oAuthSSOProviderCredentials,
		Clock:                        clockClock,
		WechatURLProvider:            endpointsEndpoints,
		StandardAttributesNormalizer: normalizer,
	}
	mfaFacade := &facade.MFAFacade{
		Coordinator: coordinator,
	}
	forgotpasswordLogger := forgotpassword.NewLogger(factory)
	forgotpasswordService := &forgotpassword.Service{
		Logger:         forgotpasswordLogger,
		Config:         appConfig,
		FeatureConfig:  featureConfig,
		Identities:     identityFacade,
		Authenticators: authenticatorFacade,
		OTPCodes:       otpService,
		OTPSender:      messageSender,
	}
	responseWriter := p.ResponseWriter
	nonceService := &nonce.Service{
		Cookies:        cookieManager,
		Request:        request,
		ResponseWriter: responseWriter,
	}
	challengeProvider := &challenge.Provider{
		Redis: handle,
		AppID: appID,
		Clock: clockClock,
	}
	userProvider := &user.Provider{
		Commands: commands,
		Queries:  queries,
	}
	authenticationinfoStoreRedis := &authenticationinfo.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	manager2 := &session.Manager{
		IDPSessions:         idpsessionManager,
		AccessTokenSessions: sessionManager,
		Events:              eventService,
	}
	interactionContext := &interaction.Context{
		Request:                         request,
		RemoteIP:                        remoteIP,
		Database:                        sqlExecutor,
		Clock:                           clockClock,
		Config:                          appConfig,
		FeatureConfig:                   featureConfig,
		OAuthClientResolver:             oauthclientResolver,
		OfflineGrants:                   redisStore,
		Identities:                      identityFacade,
		Authenticators:                  authenticatorFacade,
		AnonymousIdentities:             anonymousProvider,
		AnonymousUserPromotionCodeStore: anonymousStoreRedis,
		BiometricIdentities:             biometricProvider,
		OTPCodeService:                  otpService,
		OTPSender:                       messageSender,
		OAuthProviderFactory:            oAuthProviderFactory,
		OAuthRedirectURIBuilder:         endpointsEndpoints,
		MFA:                             mfaFacade,
		ForgotPassword:                  forgotpasswordService,
		ResetPassword:                   forgotpasswordService,
		Passkey:                         passkeyService,
		Verification:                    verificationService,
		RateLimiter:                     limiter,
		Nonces:                          nonceService,
		Challenges:                      challengeProvider,
		Users:                           userProvider,
		StdAttrsService:                 stdattrsService,
		Events:                          eventService,
		CookieManager:                   cookieManager,
		AuthenticationInfoService:       authenticationinfoStoreRedis,
		Sessions:                        idpsessionProvider,
		SessionManager:                  manager2,
		SessionCookie:                   cookieDef2,
		MFADeviceTokenCookie:            cookieDef,
	}
	interactionStoreRedis := &interaction.StoreRedis{
		Redis: handle,
		AppID: appID,
	}
	interactionService := &interaction.Service{
		Logger:  interactionLogger,
		Context: interactionContext,
		Store:   interactionStoreRedis,
	}
	webappService2 := &webapp2.Service2{
		Logger:               serviceLogger,
		Request:              request,
		Sessions:             sessionStoreRedis,
		SessionCookie:        sessionCookieDef,
		SignedUpCookie:       signedUpCookieDef,
		MFADeviceTokenCookie: cookieDef,
		ErrorCookie:          errorCookie,
		Cookies:              cookieManager,
		OAuthConfig:          oAuthConfig,
		UIConfig:             uiConfig,
		TrustProxy:           trustProxy,
		UIInfoResolver:       uiInfoResolver,
		OAuthClientResolver:  oauthclientResolver,
		Graph:                interactionService,
	}
	oauthsessionStoreRedis := &oauthsession.StoreRedis{
		Context: contextContext,
		Redis:   handle,
		AppID:   appID,
	}
	sessionMiddleware := &webapp2.SessionMiddleware{
		Sessions:       webappService2,
		OAuthSessions:  oauthsessionStoreRedis,
		States:         sessionStoreRedis,
		UIInfoResolver: uiInfoResolver,
		CookieDef:      sessionCookieDef,
		Cookies:        cookieManager,
	}
	return sessionMiddleware
}

func newWebAppColorSchemeMiddleware(p *deps.RequestProvider) httproute.Middleware {
	request := p.Request
	appProvider := p.AppProvider
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	colorSchemeMiddleware := &webapp2.ColorSchemeMiddleware{
		Cookies: cookieManager,
	}
	return colorSchemeMiddleware
}

func newWebAppUIParamMiddleware(p *deps.RequestProvider) httproute.Middleware {
	request := p.Request
	appProvider := p.AppProvider
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	uiParamMiddleware := &webapp2.UIParamMiddleware{
		Cookies: cookieManager,
	}
	return uiParamMiddleware
}

func newWebAppWeChatRedirectURIMiddleware(p *deps.RequestProvider) httproute.Middleware {
	request := p.Request
	appProvider := p.AppProvider
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	weChatRedirectURIMiddleware := &webapp2.WeChatRedirectURIMiddleware{
		Cookies: cookieManager,
	}
	return weChatRedirectURIMiddleware
}

func newWebAppVisitorIDMiddleware(p *deps.RequestProvider) httproute.Middleware {
	request := p.Request
	appProvider := p.AppProvider
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	visitorIDMiddleware := &webapp2.VisitorIDMiddleware{
		Cookies: cookieManager,
	}
	return visitorIDMiddleware
}

func newRequireAuthenticationEnabledMiddleware(p *deps.RequestProvider) httproute.Middleware {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	uiConfig := appConfig.UI
	requireAuthenticationEnabledMiddleware := &webapp2.RequireAuthenticationEnabledMiddleware{
		AuthUI: uiConfig,
	}
	return requireAuthenticationEnabledMiddleware
}

func newRequireSettingsEnabledMiddleware(p *deps.RequestProvider) httproute.Middleware {
	appProvider := p.AppProvider
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	uiConfig := appConfig.UI
	requireSettingsEnabledMiddleware := &webapp2.RequireSettingsEnabledMiddleware{
		AuthUI: uiConfig,
	}
	return requireSettingsEnabledMiddleware
}

func newSettingsSubRoutesMiddleware(p *deps.RequestProvider) httproute.Middleware {
	appProvider := p.AppProvider
	handle := appProvider.AppDatabase
	request := p.Request
	contextContext := deps.ProvideRequestContext(request)
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	appID := appConfig.ID
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	remoteIP := deps.ProvideRemoteIP(request, trustProxy)
	userAgentString := deps.ProvideUserAgentString(request)
	factory := appProvider.LoggerFactory
	logger := event.NewLogger(factory)
	clockClock := _wireSystemClockValue
	localizationConfig := appConfig.Localization
	secretConfig := config.SecretConfig
	databaseCredentials := deps.ProvideDatabaseCredentials(secretConfig)
	sqlBuilder := appdb.NewSQLBuilder(databaseCredentials)
	sqlExecutor := appdb.NewSQLExecutor(contextContext, handle)
	storeImpl := event.NewStoreImpl(sqlBuilder, sqlExecutor)
	sqlBuilderApp := appdb.NewSQLBuilderApp(databaseCredentials, appID)
	store := &user.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	rawQueries := &user.RawQueries{
		Store: store,
	}
	authenticationConfig := appConfig.Authentication
	identityConfig := appConfig.Identity
	featureConfig := config.FeatureConfig
	identityFeatureConfig := featureConfig.Identity
	serviceStore := &service.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginidStore := &loginid.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	loginIDConfig := identityConfig.LoginID
	manager := appContext.Resources
	typeCheckerFactory := &loginid.TypeCheckerFactory{
		Config:    loginIDConfig,
		Resources: manager,
	}
	checker := &loginid.Checker{
		Config:             loginIDConfig,
		TypeCheckerFactory: typeCheckerFactory,
	}
	normalizerFactory := &loginid.NormalizerFactory{
		Config: loginIDConfig,
	}
	provider := &loginid.Provider{
		Store:             loginidStore,
		Config:            loginIDConfig,
		Checker:           checker,
		NormalizerFactory: normalizerFactory,
		Clock:             clockClock,
	}
	oauthStore := &oauth3.Store{
		SQLBuilder:     sqlBuilderApp,
		SQLExecutor:    sqlExecutor,
		IdentityConfig: identityConfig,
	}
	oauthProvider := &oauth3.Provider{
		Store:          oauthStore,
		Clock:          clockClock,
		IdentityConfig: identityConfig,
	}
	anonymousStore := &anonymous.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	anonymousProvider := &anonymous.Provider{
		Store: anonymousStore,
		Clock: clockClock,
	}
	biometricStore := &biometric.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	biometricProvider := &biometric.Provider{
		Store: biometricStore,
		Clock: clockClock,
	}
	passkeyStore := &passkey.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	appredisHandle := appProvider.Redis
	store2 := &passkey2.Store{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
	}
	defaultLanguageTag := deps.ProvideDefaultLanguageTag(config)
	supportedLanguageTags := deps.ProvideSupportedLanguageTags(config)
	resolver := &template.Resolver{
		Resources:             manager,
		DefaultLanguageTag:    defaultLanguageTag,
		SupportedLanguageTags: supportedLanguageTags,
	}
	engine := &template.Engine{
		Resolver: resolver,
	}
	httpProto := deps.ProvideHTTPProto(request, trustProxy)
	httpHost := deps.ProvideHTTPHost(request, trustProxy)
	httpOrigin := httputil.MakeHTTPOrigin(httpProto, httpHost)
	webAppCDNHost := environmentConfig.WebAppCDNHost
	globalEmbeddedResourceManager := rootProvider.EmbeddedResources
	staticAssetResolver := &web.StaticAssetResolver{
		Context:           contextContext,
		Localization:      localizationConfig,
		HTTPOrigin:        httpOrigin,
		HTTPProto:         httpProto,
		WebAppCDNHost:     webAppCDNHost,
		Resources:         manager,
		EmbeddedResources: globalEmbeddedResourceManager,
	}
	translationService := &translation.Service{
		Context:        contextContext,
		TemplateEngine: engine,
		StaticAssets:   staticAssetResolver,
	}
	configService := &passkey2.ConfigService{
		Request:            request,
		TrustProxy:         trustProxy,
		TranslationService: translationService,
	}
	passkeyService := &passkey2.Service{
		Store:         store2,
		ConfigService: configService,
	}
	passkeyProvider := &passkey.Provider{
		Store:   passkeyStore,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	siweStore := &siwe.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	web3Config := appConfig.Web3
	storeRedis := &siwe2.StoreRedis{
		Context: contextContext,
		Redis:   appredisHandle,
		AppID:   appID,
		Clock:   clockClock,
	}
	ratelimitLogger := ratelimit.NewLogger(factory)
	storageRedis := &ratelimit.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	rateLimitsFeatureConfig := featureConfig.RateLimits
	limiter := &ratelimit.Limiter{
		Logger:  ratelimitLogger,
		Storage: storageRedis,
		Config:  rateLimitsFeatureConfig,
	}
	siweLogger := siwe2.NewLogger(factory)
	siweService := &siwe2.Service{
		RemoteIP:             remoteIP,
		HTTPOrigin:           httpOrigin,
		Web3Config:           web3Config,
		AuthenticationConfig: authenticationConfig,
		Clock:                clockClock,
		NonceStore:           storeRedis,
		RateLimiter:          limiter,
		Logger:               siweLogger,
	}
	siweProvider := &siwe.Provider{
		Store: siweStore,
		Clock: clockClock,
		SIWE:  siweService,
	}
	serviceService := &service.Service{
		Authentication:        authenticationConfig,
		Identity:              identityConfig,
		IdentityFeatureConfig: identityFeatureConfig,
		Store:                 serviceStore,
		LoginID:               provider,
		OAuth:                 oauthProvider,
		Anonymous:             anonymousProvider,
		Biometric:             biometricProvider,
		Passkey:               passkeyProvider,
		SIWE:                  siweProvider,
	}
	store3 := &service2.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	passwordStore := &password.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorConfig := appConfig.Authenticator
	authenticatorPasswordConfig := authenticatorConfig.Password
	passwordLogger := password.NewLogger(factory)
	historyStore := &password.HistoryStore{
		Clock:       clockClock,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorFeatureConfig := featureConfig.Authenticator
	passwordChecker := password.ProvideChecker(authenticatorPasswordConfig, authenticatorFeatureConfig, historyStore)
	housekeeperLogger := password.NewHousekeeperLogger(factory)
	housekeeper := &password.Housekeeper{
		Store:  historyStore,
		Logger: housekeeperLogger,
		Config: authenticatorPasswordConfig,
	}
	passwordProvider := &password.Provider{
		Store:           passwordStore,
		Config:          authenticatorPasswordConfig,
		Clock:           clockClock,
		Logger:          passwordLogger,
		PasswordHistory: historyStore,
		PasswordChecker: passwordChecker,
		Housekeeper:     housekeeper,
	}
	store4 := &passkey3.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	provider2 := &passkey3.Provider{
		Store:   store4,
		Clock:   clockClock,
		Passkey: passkeyService,
	}
	totpStore := &totp.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	authenticatorTOTPConfig := authenticatorConfig.TOTP
	totpProvider := &totp.Provider{
		Store:  totpStore,
		Config: authenticatorTOTPConfig,
		Clock:  clockClock,
	}
	oobStore := &oob.Store{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	oobProvider := &oob.Provider{
		Store:                    oobStore,
		LoginIDNormalizerFactory: normalizerFactory,
		Clock:                    clockClock,
	}
	testModeFeatureConfig := featureConfig.TestMode
	codeStoreRedis := &otp.CodeStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	lookupStoreRedis := &otp.LookupStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	attemptTrackerRedis := &otp.AttemptTrackerRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	otpLogger := otp.NewLogger(factory)
	otpService := &otp.Service{
		Clock:                 clockClock,
		AppID:                 appID,
		TestModeFeatureConfig: testModeFeatureConfig,
		RemoteIP:              remoteIP,
		CodeStore:             codeStoreRedis,
		LookupStore:           lookupStoreRedis,
		AttemptTracker:        attemptTrackerRedis,
		Logger:                otpLogger,
		RateLimiter:           limiter,
	}
	rateLimits := service2.RateLimits{
		IP:          remoteIP,
		Config:      authenticationConfig,
		RateLimiter: limiter,
	}
	authenticationLockoutConfig := authenticationConfig.Lockout
	lockoutLogger := lockout.NewLogger(factory)
	lockoutStorageRedis := &lockout.StorageRedis{
		AppID: appID,
		Redis: appredisHandle,
	}
	lockoutService := &lockout.Service{
		Logger:  lockoutLogger,
		Storage: lockoutStorageRedis,
	}
	serviceLockout := service2.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	service3 := &service2.Service{
		Store:          store3,
		Config:         appConfig,
		Password:       passwordProvider,
		Passkey:        provider2,
		TOTP:           totpProvider,
		OOBOTP:         oobProvider,
		OTPCodeService: otpService,
		RateLimits:     rateLimits,
		Lockout:        serviceLockout,
	}
	verificationConfig := appConfig.Verification
	userProfileConfig := appConfig.UserProfile
	storePQ := &verification.StorePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	verificationService := &verification.Service{
		Config:            verificationConfig,
		UserProfileConfig: userProfileConfig,
		Clock:             clockClock,
		ClaimStore:        storePQ,
	}
	imagesCDNHost := environmentConfig.ImagesCDNHost
	pictureTransformer := &stdattrs.PictureTransformer{
		HTTPProto:     httpProto,
		HTTPHost:      httpHost,
		ImagesCDNHost: imagesCDNHost,
	}
	serviceNoEvent := &stdattrs.ServiceNoEvent{
		UserProfileConfig: userProfileConfig,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		ClaimStore:        storePQ,
		Transformer:       pictureTransformer,
	}
	customattrsServiceNoEvent := &customattrs.ServiceNoEvent{
		Config:      userProfileConfig,
		UserQueries: rawQueries,
		UserStore:   store,
	}
	nftIndexerAPIEndpoint := environmentConfig.NFTIndexerAPIEndpoint
	web3Service := &web3.Service{
		APIEndpoint: nftIndexerAPIEndpoint,
		Web3Config:  web3Config,
	}
	queries := &user.Queries{
		RawQueries:         rawQueries,
		Store:              store,
		Identities:         serviceService,
		Authenticators:     service3,
		Verification:       verificationService,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	resolverImpl := &event.ResolverImpl{
		Users: queries,
	}
	hookLogger := hook.NewLogger(factory)
	hookConfig := appConfig.Hook
	webhookKeyMaterials := deps.ProvideWebhookKeyMaterials(secretConfig)
	webHookImpl := hook.WebHookImpl{
		Secret: webhookKeyMaterials,
	}
	syncHTTPClient := hook.NewSyncHTTPClient(hookConfig)
	asyncHTTPClient := hook.NewAsyncHTTPClient()
	eventWebHookImpl := &hook.EventWebHookImpl{
		WebHookImpl: webHookImpl,
		SyncHTTP:    syncHTTPClient,
		AsyncHTTP:   asyncHTTPClient,
	}
	denoHook := hook.DenoHook{
		Context:         contextContext,
		ResourceManager: manager,
	}
	denoEndpoint := environmentConfig.DenoEndpoint
	syncDenoClient := hook.NewSyncDenoClient(denoEndpoint, hookConfig, hookLogger)
	asyncDenoClient := hook.NewAsyncDenoClient(denoEndpoint, hookLogger)
	eventDenoHookImpl := &hook.EventDenoHookImpl{
		DenoHook:        denoHook,
		SyncDenoClient:  syncDenoClient,
		AsyncDenoClient: asyncDenoClient,
	}
	sink := &hook.Sink{
		Logger:             hookLogger,
		Config:             hookConfig,
		Clock:              clockClock,
		EventWebHook:       eventWebHookImpl,
		EventDenoHook:      eventDenoHookImpl,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
	}
	auditLogger := audit.NewLogger(factory)
	writeHandle := appProvider.AuditWriteDatabase
	auditDatabaseCredentials := deps.ProvideAuditDatabaseCredentials(secretConfig)
	auditdbSQLBuilderApp := auditdb.NewSQLBuilderApp(auditDatabaseCredentials, appID)
	writeSQLExecutor := auditdb.NewWriteSQLExecutor(contextContext, writeHandle)
	writeStore := &audit.WriteStore{
		SQLBuilder:  auditdbSQLBuilderApp,
		SQLExecutor: writeSQLExecutor,
	}
	auditSink := &audit.Sink{
		Logger:   auditLogger,
		Database: writeHandle,
		Store:    writeStore,
	}
	elasticsearchLogger := elasticsearch.NewLogger(factory)
	elasticsearchCredentials := deps.ProvideElasticsearchCredentials(secretConfig)
	client := elasticsearch.NewClient(elasticsearchCredentials)
	queue := appProvider.TaskQueue
	elasticsearchService := elasticsearch.Service{
		AppID:     appID,
		Client:    client,
		Users:     queries,
		OAuth:     oauthStore,
		LoginID:   loginidStore,
		TaskQueue: queue,
	}
	elasticsearchSink := &elasticsearch.Sink{
		Logger:   elasticsearchLogger,
		Service:  elasticsearchService,
		Database: handle,
	}
	eventService := event.NewService(contextContext, appID, remoteIP, userAgentString, logger, handle, clockClock, localizationConfig, storeImpl, resolverImpl, sink, auditSink, elasticsearchSink)
	storeDeviceTokenRedis := &mfa.StoreDeviceTokenRedis{
		Redis: appredisHandle,
		AppID: appID,
		Clock: clockClock,
	}
	storeRecoveryCodePQ := &mfa.StoreRecoveryCodePQ{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	mfaLockout := mfa.Lockout{
		Config:   authenticationLockoutConfig,
		RemoteIP: remoteIP,
		Provider: lockoutService,
	}
	mfaService := &mfa.Service{
		IP:            remoteIP,
		DeviceTokens:  storeDeviceTokenRedis,
		RecoveryCodes: storeRecoveryCodePQ,
		Clock:         clockClock,
		Config:        authenticationConfig,
		RateLimiter:   limiter,
		Lockout:       mfaLockout,
	}
	rawCommands := &user.RawCommands{
		Store: store,
		Clock: clockClock,
	}
	commands := &user.Commands{
		RawCommands:        rawCommands,
		RawQueries:         rawQueries,
		Events:             eventService,
		Verification:       verificationService,
		UserProfileConfig:  userProfileConfig,
		StandardAttributes: serviceNoEvent,
		CustomAttributes:   customattrsServiceNoEvent,
		Web3:               web3Service,
	}
	stdattrsService := &stdattrs.Service{
		UserProfileConfig: userProfileConfig,
		ServiceNoEvent:    serviceNoEvent,
		Identities:        serviceService,
		UserQueries:       rawQueries,
		UserStore:         store,
		Events:            eventService,
	}
	authorizationStore := &pq.AuthorizationStore{
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
	}
	storeRedisLogger := idpsession.NewStoreRedisLogger(factory)
	idpsessionStoreRedis := &idpsession.StoreRedis{
		Redis:  appredisHandle,
		AppID:  appID,
		Clock:  clockClock,
		Logger: storeRedisLogger,
	}
	sessionConfig := appConfig.Session
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	cookieDef := session.NewSessionCookieDef(sessionConfig)
	idpsessionManager := &idpsession.Manager{
		Store:     idpsessionStoreRedis,
		Config:    sessionConfig,
		Cookies:   cookieManager,
		CookieDef: cookieDef,
	}
	redisLogger := redis.NewLogger(factory)
	redisStore := &redis.Store{
		Context:     contextContext,
		Redis:       appredisHandle,
		AppID:       appID,
		Logger:      redisLogger,
		SQLBuilder:  sqlBuilderApp,
		SQLExecutor: sqlExecutor,
		Clock:       clockClock,
	}
	oAuthConfig := appConfig.OAuth
	eventStoreRedis := &access.EventStoreRedis{
		Redis: appredisHandle,
		AppID: appID,
	}
	eventProvider := &access.EventProvider{
		Store: eventStoreRedis,
	}
	idpsessionRand := _wireRandValue
	idpsessionProvider := &idpsession.Provider{
		Context:         contextContext,
		RemoteIP:        remoteIP,
		UserAgentString: userAgentString,
		AppID:           appID,
		Redis:           appredisHandle,
		Store:           idpsessionStoreRedis,
		AccessEvents:    eventProvider,
		TrustProxy:      trustProxy,
		Config:          sessionConfig,
		Clock:           clockClock,
		Random:          idpsessionRand,
	}
	endpointsEndpoints := &endpoints.Endpoints{
		HTTPHost:  httpHost,
		HTTPProto: httpProto,
	}
	oauthclientResolver := &oauthclient.Resolver{
		OAuthConfig:     oAuthConfig,
		TesterEndpoints: endpointsEndpoints,
	}
	offlineGrantService := oauth2.OfflineGrantService{
		OAuthConfig:    oAuthConfig,
		Clock:          clockClock,
		IDPSessions:    idpsessionProvider,
		ClientResolver: oauthclientResolver,
	}
	sessionManager := &oauth2.SessionManager{
		Store:   redisStore,
		Config:  oAuthConfig,
		Service: offlineGrantService,
	}
	accountDeletionConfig := appConfig.AccountDeletion
	accountAnonymizationConfig := appConfig.AccountAnonymization
	coordinator := &facade.Coordinator{
		Events:                     eventService,
		Identities:                 serviceService,
		Authenticators:             service3,
		Verification:               verificationService,
		MFA:                        mfaService,
		UserCommands:               commands,
		UserQueries:                queries,
		StdAttrsService:            stdattrsService,
		PasswordHistory:            historyStore,
		OAuth:                      authorizationStore,
		IDPSessions:                idpsessionManager,
		OAuthSessions:              sessionManager,
		IdentityConfig:             identityConfig,
		AccountDeletionConfig:      accountDeletionConfig,
		AccountAnonymizationConfig: accountAnonymizationConfig,
		Clock:                      clockClock,
	}
	identityFacade := &facade.IdentityFacade{
		Coordinator: coordinator,
	}
	settingsSubRoutesMiddleware := &webapp2.SettingsSubRoutesMiddleware{
		Database:   handle,
		Identities: identityFacade,
	}
	return settingsSubRoutesMiddleware
}

func newSuccessPageMiddleware(p *deps.RequestProvider) httproute.Middleware {
	request := p.Request
	appProvider := p.AppProvider
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	errorCookieDef := webapp2.NewErrorCookieDef()
	errorCookie := &webapp2.ErrorCookie{
		Cookie:  errorCookieDef,
		Cookies: cookieManager,
	}
	successPageMiddleware := &webapp2.SuccessPageMiddleware{
		Cookies:     cookieManager,
		ErrorCookie: errorCookie,
	}
	return successPageMiddleware
}

func newAPIRRequireAuthenticatedMiddlewareMiddleware(p *deps.RequestProvider) httproute.Middleware {
	appProvider := p.AppProvider
	factory := appProvider.LoggerFactory
	jsonResponseWriterLogger := httputil.NewJSONResponseWriterLogger(factory)
	jsonResponseWriter := &httputil.JSONResponseWriter{
		Logger: jsonResponseWriterLogger,
	}
	requireAuthenticatedMiddleware := &api2.RequireAuthenticatedMiddleware{
		JSON: jsonResponseWriter,
	}
	return requireAuthenticatedMiddleware
}

func newTutorialMiddleware(p *deps.RequestProvider) httproute.Middleware {
	request := p.Request
	appProvider := p.AppProvider
	rootProvider := appProvider.RootProvider
	environmentConfig := rootProvider.EnvironmentConfig
	trustProxy := environmentConfig.TrustProxy
	appContext := appProvider.AppContext
	config := appContext.Config
	appConfig := config.AppConfig
	httpConfig := appConfig.HTTP
	cookieManager := deps.NewCookieManager(request, trustProxy, httpConfig)
	tutorialCookie := &httputil.TutorialCookie{
		Cookies: cookieManager,
	}
	tutorialMiddleware := &webapp2.TutorialMiddleware{
		TutorialCookie: tutorialCookie,
	}
	return tutorialMiddleware
}

func newWorkflowUIParamMiddleware(p *deps.RequestProvider) httproute.Middleware {
	uiParamMiddleware := &workflow.UIParamMiddleware{}
	return uiParamMiddleware
}

func newWorkflowIntlMiddleware(p *deps.RequestProvider) httproute.Middleware {
	intlMiddleware := &workflow.IntlMiddleware{}
	return intlMiddleware
}
